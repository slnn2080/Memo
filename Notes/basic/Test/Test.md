### root & 111111
- centos 密码


### 测试概念

> 功能测试 (手工测试):
- 针对程序的功能来进行验证(手动) 保证软件的功能正常的实现

- 在测试的过程中 我们不仅要验证正向功能测试(正向也是我们首先要覆盖的) 还要考虑其他的场景
- 1. 正常的功能是否完成
- 2. 当出现错误的时候应该怎么样


> 自动化测试
- 使用代码或者工具代替人工验证项目功能


> 接口测试
- 针对模块与模块或系统与系统之间数据请求地址进行测试


> 性能测试
- 模拟多人使用软件 查找服务器缺陷
- 性能测试是关注我们的程序能多少人使用

----------------

### 常见的测试分类

> 按测试阶段划分
- 按照 软件开发 从无到有 分的阶段

- 1. 单元测试 (白盒测试)
- 针对程序 *源代码* 进行测试 开发边写代码边进行单元测试 按照程序一个一个功能来作为单元进行测试

- 单元测试一般都是开发在做
<!-- 
  我们写了20行代码 然后我们将程序运行起来 20行代码执行是不是按照我们的意愿 能不能覆盖

  比如条件成立要执行 第五行代码 条件不成立应该执行 第七行代码 我们要验证代码是否按照我们的逻辑去执行

  比如阶段性的测自己写的代码发现bug很容易 不是说整个项目都写完了2万行代码再测试找bug就很难了

  当测试发现bug之后提交给开发 开发处理bug 开发的修复率会很低和很慢 这个时候就会要求下一个模块进行的时候必须做单测
 -->

---

- 2. 集成测试 (接口测试)
- 针对 模块 之间访问地址进行测试
- 单元测试是按照功能块来分别测试 集成测试就是将几个功能组合起来来进行测试
- 也就是说针对功能与功能之间的互相调用来进行测试
<!-- 
  软件里面任何功能都有业务关系 比如订单和库存 库存和订单都是单独的模块 比如下订单要检测库存里面有没有数量 

  集成测试现在说的就是接口测试 这个部分是最简单的
 -->

---

- 3. 系统测试
- 对整个系统全面进行测试包括 功能 *兼容* 文档 等测试
- 就是针对集成测试进行测试(针对几个功能集合一起测试性能)

---

- 4. 验收测试
- 主要分内测 公测 使用不同人群来挖掘项目缺陷
- 性能测试(系统测试)完毕后 验收测试主要是针对指定的项目类型
<!-- 
  比如游戏当中的 公测 和 内测 公测和内测就是验收
  内测: 阿尔法测试  α 
  公测: 贝塔测试    β

  这些字母代表要测试的顺序
 -->

---


> 按代码可见度划分
- 1. 黑盒测试 (系统测试)
- 看不见源代码 主要针对程序 *功能* 进行测试

- 2. 灰盒测试 (集成测试)
- 看见部分代码 主要针对程序 *接口* 进行测试

- 3. 白盒测试 (单元测试)
- 看见全部代码 主要针对程序 *源代码* 进行测试


> 自动化测试归属什么测试?
- 理论上说黑盒测试, 实际中属于功能测试 因为自动化测试*只针对程序的功能*

> 总结:
- 1. 系统测试 和 黑盒测试 重点核心是 功能测试
- 2. 集成测试 和 灰盒测试 又称 接口测试
- 3. 单元测试 和 白盒测试 是对 代码 进行测试
- 4. 自动化测试 归属于 功能测试
- 5. 性能测试 安全测试 归属于 专项测试

---


> 测试策略
- 指的是做某个测试之前采用的一种方法
- 我们这里介绍一个 *冒烟测试*

<!-- 
  举例:
    本月20号 开发要交付给测试4个模块 给测试3天时间 要把这几个模块测试完毕 

    4个模块要投入6个人 测试验证的时候发现 主功能都跑不通 登录都登录不进去 依赖登录以后要验证的点都需要等着开发修复

    开发修复 修复了2天 3天后项目经理说要交付完成 
    找开发 开发会说找测试 测试还没测完呢
    找测试 测试会说找开发 开发修复还没修复完呢

  这样就会耽误工期 开发不写bug 测试能耽误工期么
 -->

> 冒烟测试:
- 大规模执行测试之前 针对程序的主功能进行验证 保证程序具备可测性

- 上述的情况下最好的解决方案就是冒烟测试
- *冒烟就是跑模块的主功能*确保可以进入到正常的测试环节

<!-- 
  交付上来的4个模块我们要先试用一下 如果没具备可测性(主功能都跑不通) 那开发晚上加班自己搞定
 -->

> 面试题:
- 提测标准是什么?  -- 冒烟测试通过
- 测试之前要怎么做?  -- 进行冒烟测试

----------------

### 质量模型 & 测试模型
- 测试怎么测？ 比如一个功能(需求)我们应该考虑哪些方面？

> 质量模型: 
- 提供测试设计不同角度视野 和 *验证方向*
- 衡量一个软件一个硬件的质量如何 应该从哪几个方面考虑 就从哪几个方面进行测试就可以了

<!-- 
  软件质量模型: 
    - 1. 功能性     - 重点
      - 验证软件的功能是否满足需求(根据需求文档里面会有要求的功能)
      - 功能的数量是对的 而且都实现了

    - 2. 性能效率     - 重点
      - 验证软件的性能是否满足需求
      - 比如要求软件能满足20000人的需求

    - 3. 兼容性     - 重点
      - 验证软件与主流硬件和软件兼容
      - 比如我们开发的app跟抖音冲突

    - 4. 易用性     - 重点
      - 便于使用 体验感

    - 5. 可靠性
      - 性能和功能应用可靠

    - 6. 信息安全性     - 重点
      - 信息在传输或者存储过程的安全程度

    - 7. 可维护性
      - 便于维护

    - 8. 可移植性
      - 具备迁移和便捷性
 -->


- 通过 上面的知识点 最起码我们应该知道 对方给我们任何需求 我们可以从上述的几点来考虑

---


> 测试模型 (开发模型)
- 在现在的企业中 开发和测试 处于什么样的环节
- 不同角色对项目开发的一种模式或者说流程 不同的角色在项目中应该做什么样的事情 每一种角色应该匹配哪个环节

> W模型
- 简称 双V 即以开发主导的一个 V 和 以测试主导的一个 V 构成

- 开发V:

    用户需求                交付

      需求分析            实施

        概要设计        集成

          详细设计    单元测试

                编码
<!-- 
  用户需求: 
    产品来处理

  需求分析: 
    跟开发一起分析

  概要设计: 
    开发要进行概要设计 应该有哪些功能和哪些模块

  详细设计: 
    每个功能里面具体应该怎么去写 应该有哪些内容 生成文档 对着文档进行编码实现
 -->


- 测试V:

      验收测试设计

        系统测试设计            验收测试

          集成测试设计        系统测试

            单元测试设计    集成测试

                    单元测试

- 根据需求文档提取需求 根据需求设计测试点 根据测试点写用例覆盖测试点


> 结论:
- 测试 和 开发 每一个环节都一一对应 也就是说 测试从产品的需求文档一旦确定以后测试就要从最开发介入 测试伴随着整个产品的开发周期

- 测试对象不仅是程序还有需求 设计文档
- 测试介入较早 及早发现问题 降低修复成本


> 问题:
- 实施起来比较复杂 难度大 对于需求阶段和设计阶段的测试设计要求较高
- 需求不熟悉对单功能就没有办法覆盖

----------------

### 测试流程 (需求分析)
- 进入企业后该怎么进行测试

> 1. 需求分析
- 确保各部门需求理解一致
- 各部分站在自己的角度上 对需求进行查漏补缺
<!-- 
  产品调研 调研后会确定需求文档 公司通过 进行立项 才会有项目组
  立项后 肯定是有完整的需求了

  项目中的角色一般会有 开发 测试 产品

  产品会给大家先讲需求 项目是干啥的 主要有哪些功能 有什么需求 
  这个环节就是需求分析评审

  可能会有的问题:
   站在测试角度对需求文档进行查漏补缺
 -->


> 2. 计划编写
- 测什么(测试目标和范围) 谁来测(人员安排) 怎么测(测试工具 测试策略) 这3点是测试计划的核心
<!-- 
  各个部分要开始写计划

  开发部门: 写研发的计划
  测试部门: 写测试的计划
 -->

- 整个的测试团队都是围绕这个计划进行的 单个人拿到他负责的需求 会写一个个人的计划(什么时候开始提取测试点 什么时候开始写用例 什么时候进行评审 什么时候进行交付 什么时候执行冒烟)

- 这个计划会跟开发一起用 因为测试计划要和开发进行同步 *这个计划公司会有现成的模版*

- 测试驱动开发


> 3. 测试用例设计
- 验证测试时执行的文档项目是否符合需求的操作文档(按照写好的东西执行就完了 这个也叫做用例)


> 4. 用例执行
- 项目模块开发完成开始执行 用例文档 实施测试
<!-- 
  当我们输入错误的密码 发现也能登录成功 这就是 缺陷
 -->


> 5. 缺陷管理
- 对缺陷进行管理的过程
- 提交 -- 修复 -- 验证 -- 关闭
<!-- 
  缺陷本身是一个闭环 比如测试发现缺陷了需要提交给开发 开发进行修复 修复完成了告知测试 测试说发版本吧 把修复的代码更新一下 更新完之后 测试会再次的验证 验证正确关闭bug

  缺陷管理使用的工具
    excel
    jira
    qq 微信都可以
 -->


> 6. 测试报告
- 实施测试结果文档 
- 测试完之后会写结果文档 比如A模块总共有多少个bug 负责人是谁 bug的分析 bug的总结 bug的描述 发现的问题是怎么解决的

----------------

### 测试用例
- 用为测试项目而设计的*执行文档* 看着我们的执行文档 去进行测试

> 什么是测试用例
- 用例:
- 用户使用的案例的简称 这些案例中我们选哪些测试 那我们可以从质量模型的角度来着手

- 比如我们要测试一款手机 比如:
- 1. 是否能开机:
  - 打开手机按下电源键3秒钟 看是否能开机

- 2. 验证内存:
  - 打开手机设置查看内存是否为64G

- 3. 验证屏幕:
  - 打开手机在白屏北京下检查屏幕是否有黑色点

- 4. 检查运行速度
  - 打开手机下载吃鸡游戏 是否运行流畅


> 测试用例的作用
- 防止漏测 实施测试的标准(操作文档 - 点点点)
- 大厂中一般不会让自己写的用例自己执行

- 一般来说 测试分为 
  执行用例(放入职的会做这个 认识中国字的都能执行)
  设计用例(业务不熟悉的人设计不了)


> 测试用例的编写格式  
- 作用: 防止漏测 和 实施测试的步骤(标准)

> 8大要素:
- 用例编号:
  - 项目 + 模块 + 编号

- 用例标题:
  - 预期结果 + 操作步骤

- 模块/项目:
  - 所属项目或模块

- 前置条件:
  - 要执行此条用例 有哪些前置操作

- 优先级: 
  - 表示用例的重要程度或者影响力p0 ~ p4 (p0最高)

- 测试步骤:
  - 描述操作步骤

- 测试数据:
  - 操作的数据 没有的话可以为空

- 预期结果:
  - 期望达到的结果


> 如何设计用例
- *不同的场景和需求 有不同的用例设计方法* 需要学习用例的设计方法
- 我们学了设计方法 根据需求往方法里面套就可以了

- 设计用例的时候是定要先覆盖业务 然后再覆盖单模块 单功能

----------------

### 目标
> 能够针对穷举场景设计测试点
> 能够针对限定边界规则设计测试点
> 能够对条件依赖关系进行设计测试点
> 能够使用对于项目业务进行设计用例

- 下面一一进行展开说明

----------------

### 等价类划分法 (取其中一个代表其他)
- 等价类划分法是用来解决穷举问题的 使用的方法就是等价类

> 等价类说明
- 在所有测试数据中 具有某种*共同特征(看分类)*的数据集合进行划分

> 等价类分类
- 有效等价类: 满足需求的数据集合
- 无效等价类: 不满足需求的数据集合
<!-- 
  说白了 只要是有效的都是一个特点 有效和无效我们只取一个 我们不用去穷举(一百个情况 要想一百种测试方案 不用)

  比如 注册的昵称为6-8位字符串

  有效: 6 7 8 位都可以注册成功
  无效: 小于6位 大于8位的时候也可以注册成功

  比如我们测试的时候 就可以 来一个4位 来一个7位 进行测试
  因为站在等价类划分 分别进行了 有效 和 无效 的情况测试

  不用再去测别的
 -->


> 等价类步骤
- 使用等价类方法的步骤

- 1. 明确需求
- 2. 确定有效和无效等价类
- 3. 提取数据编写测试用例


> 等价类的适用场景
- 需要大量数据测试输入 但是*没有办法穷举测试*的地方
- 比如:
  - 输入框
  - 下拉列表
  - 单选复选框

- 典型代表: 页面级的输入框类测试 *输入框一定会用 等价类*


> 案例:
- 需求: 验证 QQ账号 的合法性
- 要求: 6 ~ 10位自然数

- 测试人员在写用例的时候 软件是没有的 只有需求文档

- 步骤:
- 下面就是使用等价类 我们编写的测试用例 用来覆盖需求(不是真正的完整的覆盖, 完整的覆盖需要结合下一个知识点)

- 1. 明确需求:
    6 - 10位自然数

- 2. 确定有效和无效等价类
    有效          无效
    8位自然数     4位自然数
                 8位非自然数
<!-- 
  选择8位非自然数的原因: 
  在测试类型符合与否的时候 位数一定要合格 我们在验证一个点的时候 其它点必须符合条件
 -->

- 3. 提取数据编写用例(要用什么数据进行测试)
    有效           无效
    12345678      1234
                  1234567a

> 总结:
- 需求是 6 - 10位自然数
- 怎么确定有效 和 无效?  
- 我们可以根据需求 列出有效和无效的范围 然后在其中选择任何一个即可
- 有效
  - (6 7 8 9 10) 我们取其中的任何一个即可

- 无效
  - x < 6位, x > 10位 在这两个范围内取一个就可以


> 分类:
- 1. 有效等价: 所有有效数据集合 取一个即可
- 2. 无效等价: 所有无效数据集合 取一个即可

---

> 案例2
- 需求: 验证某城市电话号码正确性

- 要求:
- 1. 区号: 空 或者 三位数字
- 2. 前缀码: 非 0 且 非 1 开头的三位数字
- 3. 后缀码: 四位数字

> 需求分析:
- 参数: 区号 + 前缀 + 后缀
- 类型: 数字 或 空
- 长度: 3位, 4位
- 规则: 非0 且 非1


- 1. 明确需求
- 根据需求分析如下
<!-- 
    参数    类型      长度      规则

    区号    数字    空, 3位      -
    前缀    数字    3位         非0 且 非1
    后缀    数字    4位         -
 -->

- 2. 确定有效和无效等价类
<!-- 
    参数                  有效等价        无效等价

    区号                  1.为空 2.3位    1位(要求是3位)
    前缀      长度         3位            2位
    后缀                  4位            3位


    区号                  数字            非数字
    前缀      类型         数字            非数字
    后缀                  数字            非数字


    区号                  -             -
    前缀      规则        非0非1         0开头 或 1开头
    后缀                  -             -
 -->

> 技巧:
- 正向(正确的用例):  尽量覆盖组合
- 逆向(错误的用例):  逆向不可组合 每一条都是一个用例



- 3. 测试数据进行验证
<!-- 
  用例编号
    tel_001

  用例标题
    合格(区号为空+3位数字前缀且非0非1开头+4位数字后缀)

  项目/模块
    无

  前置条件
    无

  优先级
    p0 因为正向就是p0

  测试步骤
    1. 输入区号
    2. 输入前缀
    3. 输入后缀

  测试数据
    1. 区号: 为空
    2. 前缀: 234
    3. 后缀: 4567

  预期结果
    合格

  实际结果

---

  用例编号
    tel_002

  用例标题
    合格(区号3位数字+3位数字前缀且非0非1开头+4位数字后缀)

  项目/模块
    无

  前置条件
    无

  优先级
    p0 因为正向就是p0

  测试步骤
    1. 输入区号
    2. 输入前缀
    3. 输入后缀

  测试数据
    1. 区号: 123
    2. 前缀: 234
    3. 后缀: 4567

  预期结果
    合格

  实际结果

---

  用例编号
    tel_003

  用例标题
    不合格(区号1位数字+3位数字前缀且非0非1开头+4位数字后缀)

  项目/模块
    无

  前置条件
    无

  优先级
    p0 因为正向就是p0

  测试步骤
    1. 输入区号
    2. 输入前缀
    3. 输入后缀

  测试数据
    1. 区号: 1
    2. 前缀: 234
    3. 后缀: 4567

  预期结果
    不合格

  实际结果

---

  用例编号
    tel_004

  用例标题
    不合格(区号为空+2位数字前缀且非0非1开头+4位数字后缀)

  项目/模块
    无

  前置条件
    无

  优先级
    p0 因为正向就是p0

  测试步骤
    1. 输入区号
    2. 输入前缀
    3. 输入后缀

  测试数据
    1. 区号: 为空
    2. 前缀: 23
    3. 后缀: 4567

  预期结果
    不合格

  实际结果

---

  用例编号
    tel_005

  用例标题
    不合格(区号为空+3位数字前缀且非0非1开头+3位数字后缀)

  项目/模块
    无

  前置条件
    无

  优先级
    p0 因为正向就是p0

  测试步骤
    1. 输入区号
    2. 输入前缀
    3. 输入后缀

  测试数据
    1. 区号: 为空
    2. 前缀: 234
    3. 后缀: 456

  预期结果
    不合格

  实际结果

---

  用例编号
    tel_006

  用例标题
    不合格(区号为3非位数字+3位数字前缀且非0非1开头+4位数字后缀)

  项目/模块
    无

  前置条件
    无

  优先级
    p0 因为正向就是p0

  测试步骤
    1. 输入区号
    2. 输入前缀
    3. 输入后缀

  测试数据
    1. 区号: a12
    2. 前缀: 234
    3. 后缀: 4567

  预期结果
    不合格

  实际结果

---

  用例编号
    tel_007

  用例标题
    不合格(区号为空+3位非数字前缀且非0非1开头+4位数字后缀)

  项目/模块
    无

  前置条件
    无

  优先级
    p0 因为正向就是p0

  测试步骤
    1. 输入区号
    2. 输入前缀
    3. 输入后缀

  测试数据
    1. 区号: 为空
    2. 前缀: 23a
    3. 后缀: 4567

  预期结果
    不合格

  实际结果

---

  用例编号
    tel_008

  用例标题
    不合格(区号为空+3位数字前缀且非0非1开头+4位非数字后缀)

  项目/模块
    无

  前置条件
    无

  优先级
    p0 因为正向就是p0

  测试步骤
    1. 输入区号
    2. 输入前缀
    3. 输入后缀

  测试数据
    1. 区号: 为空
    2. 前缀: 234
    3. 后缀: 456a

  预期结果
    不合格

  实际结果

---

  用例编号
    tel_009

  用例标题
    不合格(区号为空+3位数字前缀且0非1开头+4位数字后缀)

  项目/模块
    无

  前置条件
    无

  优先级
    p0 因为正向就是p0

  测试步骤
    1. 输入区号
    2. 输入前缀
    3. 输入后缀

  测试数据
    1. 区号: 为空
    2. 前缀: 023
    3. 后缀: 4567

  预期结果
    不合格

  实际结果

---

  用例编号
    tel_010

  用例标题
    不合格(区号为空+3位数字前缀且非01开头+4位数字后缀)

  项目/模块
    无

  前置条件
    无

  优先级
    p0 因为正向就是p0

  测试步骤
    1. 输入区号
    2. 输入前缀
    3. 输入后缀

  测试数据
    1. 区号: 为空
    2. 前缀: 134
    3. 后缀: 4567

  预期结果
    不合格

  实际结果

 -->

----------------

### 边界值分析法
- 用来解决边界限制

- 需求:
- 判断输入的数据是否小于 -99 或者大于 99, 如果 小于 -99 或 大于 99 给出错误提示

- -99 ~ 99 之间是正常范围 两侧的时候需要给出错误提示

- 后台代码:
```python
if a >= -99 or a <= 99:
    print("输入的参数值必须大于-99同时小于99")

if b >= -99 or b <= 99:
    print("输入的参数值必须大于-99同时小于99")
```

- 上面不应该加上 "=" 所以出错


**提示:**
- 输入的数据包含99或者-99的时候
- 边界条件设置出错: 代码中 将 ">" 写成了 ">=", 将 "<" 写成了 "<="


- 当出现 >= 类似的场景下 我们需要测边界值 边界值需要测哪些呢？

> 边界值分析法:
> 1. 边界范围节点
- 选取 *正好等于*, *刚好大于*, *刚好小于* 边界的值 作为测试数据
  - 上点: 边界上的点(正好等于)
  - 离点: 距离上点最近的点(刚好大于 刚好小于)
  - 内点: 范围内的点(区间范围内的数据)

<!--    
            -99              99
      ----x--o--x----0----x--o--x----

        -100   -98   0    98   100


      o: 就是上点 也就是边界  2个o
      x: 就是离点 离边界最近的点  4个x
      0: 就是内点 范围内的点
 -->


> 总结: 
- 有关边界值 不管几条用例 
  最多7条 因为一共7个点
  最少5条


> 2. 应用设计步骤
- 1. 明确需求
- 2. 确定有效和无效等价类
<!-- 
  疑问:
    上面的图 不是覆盖了有效等价 和 无效等价了么？
    那可以不用再次确定有效和无效等价类了么？

  不能:
    因为边界值只能覆盖位数(长度) 无法覆盖非数字 不是数字的情况是解决不了的
    边界值只能覆盖数字 类型(a b | *)只能由等价类覆盖

  总结:
    等价类和边界值通常都是配合使用的
 -->

- 3. 确定边界范围值
- 4. 提取数据编写测试用例


> 3. 案例
- 需求:
- 通过边界值法验证标题长度的合法性

- 要求:
- 标题长度大于0 小于等于30个字符

- 接下来我们按照步骤来下
- 1. 明确需求:
  - 标题长度大于0 小于等于30个字符
  - str.length > 0 && str.length <= 30


- 2. 确定有效等价和无效等价
  - 有效:
    > 0, <= 30

  - 无效:
    = 0, > 30

- 3. 确定边界范围值:
  - -1 0 1 ---- 29 30 31
  - 有效需要测: 1 29 30 单位: 字符
  - 无效需要测: 0 31 单位: 字符
<!-- 
  (-1不用测 字符咋能输出来个-1)
 -->

- 有效需要测的 和 无效需要测的 一共5个用例

- 4. 编写用例:
<!-- 
  用例编号: title_001
  用例标题: 合格(1个字符)
  项目/模块: 标题
  前置条件: 打开工具
  优先级: p0
  测试步骤: 输入数据 点击验证
  测试数据: a
  预期结果: 合格
  实际结果:

  用例编号: title_002
  用例标题: 合格(29个字符)
  项目/模块: 标题
  前置条件: 打开工具
  优先级: p0
  测试步骤: 输入数据 点击验证
  测试数据: 29个a
  预期结果: 合格
  实际结果:

  用例编号: title_003
  用例标题: 合格(30个字符)
  项目/模块: 标题
  前置条件: 打开工具
  优先级: p0
  测试步骤: 输入数据 点击验证
  测试数据: 30个b
  预期结果: 合格
  实际结果:

  用例编号: title_004
  用例标题: 不合格(0个字符 为空)
  项目/模块: 标题
  前置条件: 打开工具
  优先级: p1
  测试步骤: 输入数据 点击验证
  测试数据: 空
  预期结果: 合格
  实际结果:

  用例编号: title_005
  用例标题: 不合格(31个字符)
  项目/模块: 标题
  前置条件: 打开工具
  优先级: p1
  测试步骤: 输入数据 点击验证
  测试数据: 31个c
  预期结果: 合格
  实际结果:
 -->

---

- 我们再看看上面的案例
- 需求:
- 通过边界值法验证QQ号码的合法性

- 要求:
- 6 ~ 10 位自然数

- 1. 确定边界值:
- 5 6 7 ---8--- 9 10 11

- 2. 确定有效和无效等价类
- 有效:
  6 7 8 9 10

- 无效:
  5 11 非自然数

- 这样有效和无效的测试用例加起来需要 8 条

> 上面的用例优化
- 我们会发现 当我们测试有效用例的时候 会覆盖
  6位自然数 
  7位自然数 
  8位自然数 
  9位自然数 
  10位自然数 

- 这样会比较冗余, 下面我们讲讲怎么针对类似的场景进行优化
- 上面我们说过 凡是涉及到边界的一定是7条用例

- 可以优化成5个点
**优化要求**
- 1. 上点必选 2个
- 2. 内点必选 1个
- 3. 离点要求 开内闭外
(
  考虑开闭区间 
  *开*区间选择*内部离点* 
  *闭*区间选择*外部离点*
)
<!-- 
  - 理解: 带=的一侧带有 ] (包含)
    开区间: 
      10 < a <= 20  -> (10, 20] 

    开区间是 不包含  ()
    闭区间是 包含  []
 -->

- 现在我们测的是 6 - 10 写成开闭区间就是 [6, 10]
- 闭区间的话 我们会选择外部离点 也就是 5 和 11


> 4. 应用场景
- 1. 在等价类的基础上针对边界范围的测试数据输入的地方(重点关注边界)
- 2. 常见词语描述: 大小 尺寸 重量 最大 最小 至多 至少等修饰词语
- 3. 典型代表: 有边界范围的输入框类测试

**等价类和边界值是测试用例中最常用的两种方式**

- 等价类解决的是: 穷举场景的问题
- 边界值解决的是: 边界范围限制的问题

----------------

### 判定表法
- 解决多条件依赖 
- 当我们遇到条件和条件之间的依赖关系的时候 需要使用 判定表法


> 判定表法
> 1. 判定表法的引入

---

> 2. 判定表定义以及组成部分
> 定义:
- 一种以表格形式表达多条件逻辑判断的工具

> 组成:
- 条件桩:
  列出问题中的所有条件 列出条件的次序无关紧要

- 动作桩:
  列出问题中可能采取的操作 操作的排列顺序没有约束

- 条件项:
  列出条件对应的取值 所有可能情况下的真假值
  *条件项的个数是用例的个数*

- 动作项:
  列出条件项的 各种取值情况下应该采取的动作结果
  *动作项是预期结果*

<!-- 
      条件桩        条件项

      ↗ 是否欠费 是 是 否 否
  条件
      ↘ 是否关机 是 是 否 否

---

      动作桩        动作项

  操作  是否允许主被叫
               否 否 否 否
 -->

> 规则:
- *判定表中贯穿条件项和动作项的一列就是一条规则*
- 假设有n个条件 每个条件的取值有两个(0,1) 全组合有2的n次方种规则(一共有2^n个用例)

- n是条件
- 几种取值底数就是几

---

> 3. 判定表法设计用例步骤
- 1. 明确需求
- 2. 画出判定表

  - 列出条件桩和动作桩 
  (if条件 and {代码块中的逻辑对应的动作桩})

  - 填写条件项 对条件进行全组合
  - 根据条件项的组合确定动作项
  - 简化 合并相似规则(有相同的动作)

- 根据规则编写测试用例

---

> 4. 案例
- 验证: 
- 若用户欠费或者关机 则不允许主被叫(欠费就不能呼入 呼出了) 功能的测试 

- 说明:
- *等价类边界值分析法主要关注单个输入类条件的测试* 并没有考虑输入条件之间的各种组合 输入条件 与 输出结果之间有相互制约关系的测试

---

> 5. 使用场景
- 有多个输入条件 多个输出结果 输入条件之间有组合关系 输入条件和输出结果之间有依赖(制约)关系
- 判定表一般*适用于条件组合*数量较少的情况(比如4个条件以下)
<!-- 
  如果给我们了5个条件 但是5个条件是独立的(没有组合)情况下
  我们就不能使用判定表 而要使用等价例和边界值
 -->

- 在等价类的基础上 针对有边界范围的测试数据 输入的地方(重点关注边界)
- 常见词语描述:
  大小 尺寸 重量 最大 最小 至多 至少等修饰词语

- 典型代表:
  有边界范围的输入框类测试

> 提示:
- 如果碰到项目中多条件组合大于4个相互依赖 可以使用 正交表 和 因果图 来实现

---

> 案例:
- 1. 如果金额 > 500元 又未过期 则发出批准单和提货单
- 2. 如果金额 < 500元 但过期了 则不发批准单和提货单
- 3. 如果金额 <= 500元 则不论是否过期都发出批准单和提货单
- 4. 在过期的情况下 无论金额大小还需要发出通知单

- 画出判定表
- 1. 列出所有的条件状和动作桩
- 2. 填写条件项 对条件进行组合
- 3. 根据条件项的组合确定动作项
- 4. 简化 合并相似规则(有相同的动作)

<!-- 
  条件:
  > 500 && not expiration
  < 500 && expiration
  <= 500
  expiration

  操作:
  operation
 -->

- 上面是我写的 而实际上 条件就2个 大于500 和 未过期 因为大于500写个否就是<=500, 未过期写个否就是过期

条件:
  大于500   是   是   否    否
  未过期    是   否   是    否

动作:
  批准单    ✅   ❎   ✅    ✅
  提货单    ✅   ❎   ✅    ✅
  通知单    ❎   ✅   ❎    ✅
  

- 写用例:
- 几列就是几个用例
<!-- 
  order_001:
    用例标题: 发批准单和提货单(>500 & 未过期)
    项目/模块: 订单
    前置条件: 软件打开
    优先级: p1
    测试步骤: 输入金额 查看是否过期
    测试数据: 501 未过期
    预期结果: 发批准单 提货单 不发通知单
    实际结果:

  order_002:
    用例标题: 发批准单(>500 & 过期)
    项目/模块: 订单
    前置条件: 软件打开
    优先级: p1
    测试步骤: 输入金额 查看是否过期
    测试数据: 501 过期
    预期结果: 不发批准单 提货单 发通知单
    实际结果:

  order_003:
    用例标题: 发批准单和提货单(<=500 & 未过期)
    项目/模块: 订单
    前置条件: 软件打开
    优先级: p1
    测试步骤: 输入金额 查看是否过期
    测试数据: 500 未过期
    预期结果: 发批准单 提货单 不发通知单
    实际结果:

  order_004:
    用例标题: 发批准单和提货单(<500 & 过期)
    项目/模块: 订单
    前置条件: 软件打开
    优先级: p1
    测试步骤: 输入金额 查看是否过期
    测试数据: 400 过期
    预期结果: 发批准单 提货单 通知单
    实际结果:
 -->

> 案例2
- 1. 输入的第一列字符必须是a或者b
- 2. 第二列字符必须是数字
- 3. 如果第一列字符不正确 则给出信息L
- 4. 如果第二列字符不正确 则给出信息M
- 5. 如果两列字符输入正确 则修改文件成功

- 画出判定表
- 1. 列出所有的条件状和动作桩
- 2. 填写条件项 对条件进行组合
- 3. 根据条件项的组合确定动作项
- 4. 简化 合并相似规则(有相同的动作)

条件:
  是A或B   是   是   否    否
  是数字   是   否   是    否

动作:
  L         ❎   ❎   ✅   ✅
  M         ❎   ✅   ❎   ✅
  SUCCESS   ✅   ❎   ❎   ❎
<!-- 
  file_001:
    用例标题: 修改成功(第一列为a或b 第二列为数字)
    项目/模块: 文件
    前置条件: 软件打开
    优先级: p1
    测试步骤: 输入第一列 输入第二列
    测试数据: a 1
    预期结果: 修改成功
    实际结果:

  file_002:
    用例标题: 输出m(第一列为a或b 第二列是非数字)
    项目/模块: 文件
    前置条件: 软件打开
    优先级: p1
    测试步骤: 输入第一列 输入第二列
    测试数据: a a
    预期结果: 输出m
    实际结果:

  file_003:
    用例标题: 输出l(第一列非a或b 第二列是数字)
    项目/模块: 文件
    前置条件: 软件打开
    优先级: p1
    测试步骤: 输入第一列 输入第二列
    测试数据: c 1
    预期结果: 输出l
    实际结果:

  file_004:
    用例标题: 输出ml(第一列非a或b 第二列非数字)
    项目/模块: 文件
    前置条件: 软件打开
    优先级: p1
    测试步骤: 输入第一列 输入第二列
    测试数据: c c
    预期结果: 输出ml
    实际结果:
 -->

----------------

### 场景法
- 解决业务问题
- 核心: 基于流程图梳理业务 *流程图应该优先于单功能*

- 说明:
- 它也可以叫做流程图法 是用流程图描述用户的使用场景 然后通过覆盖流程路径来设计测试用例

- 意义:
- 用户使用角度:
  用户平时使用的不是单个功能 而是多个功能组合起来进行使用

- 测试人员角度
  平时测试的都是单个功能点进行测试 容易忽略多个功能的组合测试


> 场景法 -- 流程图
- 要用场景法 必须要做流程图
- 使用标准图形 和 箭头来表达程序或业务的走向
<!-- 
      开始
       ↓
           y
      判断  →  语句 (条件成立执行语句 不成立则结束)
    n  ↓        ↙

      结束
 -->

- 标准图形:
- 1. 开始 结束 使用kinto按钮形状的图形
- 2. 判断 使用菱形
- 3. 语句 使用长方形

- 流程图对测试人员的作用
- 1. 能够看懂流程图 设计业务用例
- 2. 当需求文档信息不全的时候 能够根据需求 梳理出流程图

- 网页版工具: https://processon.com
- windows工具: visio

<!--  
  正常的情况下 流程图不需要测试话 在需求文档里面有
 -->


> 流程图练习
- 用户名为admin 密码为123456 输出: 登录成功
- 登录 搜索商品 添加购物车 去结算 支付
  - 如果支付成功 则提示下单成功
  - 否则 则提示支付失败


> 示例: ATM取款流程
<!-- 
  用户           ATM机         银行主机

插入银行卡  →  验证银行卡

          ↙                 ↗   密码正确    
  
输入密码    →   传送密码到主机
                                  ↙
          ↙        ←        ↙

取款输入金额 →  系统验证金额    →   余额充足

                            ↙
选择退出银行卡 →  出钞打印凭据    

      ↘
              吐出银行卡
 -->


> 扩展:
- 我们一般都业务正向作为冒烟用例 


> 根据流程图 写 测试用例
- 写用例的时候 先覆盖成功

- 这个部分没听 可以补下
- https://www.bilibili.com/video/BV1bg411V7pp?p=37&spm_id_from=pageDriver&vd_source=66d9d28ceb1490c7b37726323336322b

----------------

### 错误推测法
> 定义
- 通过经验推测系统可能出现的问题

> 思想
- 根据经验列举出可能出现问题的清单 根据清单分析问题可能原因 推测发现缺陷

> 场景
- 1. 时间紧 任务量大时 根据之前项目类似经验找出易出错的模块重点测试
- 2. 实践宽裕通过该方法列出之前出现问题较多的模块再次测试

----------------

### 缺陷

> 缺陷定义
- 软件在使用过程中存在的*任何问题(不光光是错误)*都叫做软件的缺陷 简称bug


> 缺陷判定标准
- 符合下面的任意一点都为缺陷

- 1. 软件未实现需求(规格)说明书中
    明确要求的功能 - *少功能*
<!-- 
  说明书中要求有10个功能你只写了8个
 -->

- 2. 软件出现了需求(规格)说明书中
    指明不应该出现的错误 - *功能错误*
 
- 3. 软件实现的功能超出需求(规格)说明书指明的范围 - *多功能*
<!-- 
  说明书中要求有10个功能你写了12个
 -->

- 4. 软件未实现需求(规格)说明书中
    虽未明确指明但应该实现的要求 - *隐形功能错误!!!*

- 5. 软件难以理解 不易使用 运行缓慢 用户体验不好 - *不易使用*

---

> 缺陷产生原因
- 缺陷一定会存在

- 1. 需求阶段:
  需求描述不易理解 有歧义 错误等
<!-- 
  需求文档写错了, 这个文档就是产品写的
 -->

- 2. 设计阶段:
  设计文档存在错误或者缺陷
<!-- 
  高级项目开发(架构师 设计软件架构的) 按照需求文档 将文档转成给开发看的文档
 -->

- 3. 编码阶段:
  代码出现错误

- 4. 运行阶段:
  软硬件系统本身故障导致软件缺陷

---

> 缺陷的生命周期
- 生命周期从 *需求文档开始* 到 *解决bug结束*

  需求规格说明                        故障解决
  (缺陷)    
        ↘                           ↗
        设计                    故障隔离
        (缺陷)
              ↘               ↗ 
              编码        故障分类
              (缺陷)
                  ↘     ↗
                    测试
                  (发现bug)

- 注入bug -> 发现bug -> 解决bug

---

> 缺陷核心内容
> 1. 缺陷的标题
- 描述缺陷的核心问题(让别人能够看的懂)
- 从标题就能看出问题的所在

> 2. 缺陷的预置条件
- 缺陷产生的前提
- bug发给开发了 开发需要复现 所以要提供复现条件(我们可以提供测试的前提条件)

> 3. 缺陷的复现步骤
- 复现缺陷的过程
- 测试需要提供操作步骤 + 测试数据

> 4. 缺陷的预期结果
- 希望得到的结果

> 5. 缺陷的实际结果
- 实际得到的结果

> 6. 缺陷的必要附件
- 图片 日志等信息(凭据), 比如截图

---

> 缺陷提交要素
- 这个部分是基于有项目的管理工具 沟通缺陷的时候要用的 和上面的内容不冲突

- 1. 缺陷报告的编号
- 缺陷的唯一编码 (和用例编号一致)

- 2. 严重程度
- 严重(51): 主功能
- 一般(52): 次要功能
- 微小(53): 易用性 界面
- 建议(54): 建议性问题

- 3. 缺陷优先级
- priority0: 24小时之内解决
- priority1: 发布前必须修复
- priority2: 可以在下一个版本中修复

- 4. Bug类型
- 代码错误 兼容性问题 设计缺陷 性能问题

- 5. 缺陷状态
- new: 新建
- open: 打开
- closed: 关闭
- postponed: 延期

---

> 缺陷类型
- 功能错误
  - 界面UI错误
  - 兼容性
          上面两个前端问题

  - 数据
  - 易用性
  - 改进 / 建议
  - 架构

---

> 缺陷分类
- 怎么区分是 前端bug 还是 后台bug
- 如果是 界面ui错误 和 兼容性错误的话 是前端问题

- 但是 如果是 功能性的错误怎么分前端问题 还是 后台问题？
- 比如我们点了一个按钮 白屏 那是前端问题还是后台问题

- **抓包!**
- 核心: 检查请求和响应的数据

- 前端点击按钮 和 后台进行交互 数据都是通过网络传输的 我们点击按钮是看不见的

- 抓包就是将前端发送给后台的所有信息拦截下来 如果我们在这些信息中对请求参数和信息检测是没有问题的情况下 请求没问题但没有响应 那就是后台的问题 请求的错误的话 就前端错误

----------------

### 缺陷的编写

> 1. 缺陷报告示例

- excel的示例:

缺陷ID  缺陷标题  缺陷状态 严重程度  优先级 所属模块 缺陷描述 附件

- 对照上面标题 下面竖排写

---
bug101
---
正常下单成功后支付失败
---
new
--- 
p0
--- 
p0
---
Ego核心业务
---
1. 打开小程序
2. 选中商品添加购物车进行下单
3. 在订单详情点击去付款
预期结果:能够呼起微信支付
实际结果: 无响应
---
 
> 2. 缺陷跟踪流程
- https://www.bilibili.com/video/BV1bg411V7pp?p=50&spm_id_from=pageDriver&vd_source=66d9d28ceb1490c7b37726323336322b

- 02:37 的图
 

> 3. 提交缺陷注意事项
- 1. 可重现
- 发现bug后自己要复现下bug 

- 2. 唯一性
- 一个缺陷上报一个问题

- 3. 规范性
- 符合公司或者项目要求

----------------

### 扩展: it常见岗位 以及 作用

> 1. 前端
- 写页面

> 2. 后端
- 后台服务程序

> 3. 测试
- 找缺陷

> 4. ui (美工)
- 产品先设计页面的原型(结构) ui根据原型设计样式

> 5. 运维
- 后台把软件开发完成 软件需要找台电脑装起来给别人使用
- 这个电脑就是服务器 一般放在linux系统里面 比如百度的服务器数量很多 这些集群就是交给运维来管理

- 管理服务器(部署软件项目的电脑)

> 6. 产品
- 设计需求 和 产品原型(这个原型才是真正的设计) ui只是提供原型中需要添加的图和配色 ui相当于化妆师

- 梳理需求 设计原型图


> 7. 运营
- 上线运营策划

----------------

### 缺陷管理工具 禅道
- 网址:
- https://www.zentao.net/

- 特点:
- 国产 免费 开源 简单 轻量级
- 三管融合(产品管理 项目管理 质量管理)


> 禅道特点
- 1. 三权分立
  - 产品部门 - 构想者
  - 研发部门 - 执行者
  - 测试部门 - 保证者

- 2. 四角协同
  - 产品经理
  - 项目经理
  - 研发团队
  - 测试团队


> 禅道使用流程
- 对于测试来说 有以下两个功能需要测试去完成
- 管理用例
- 管理缺陷

----------------

### 抓包
- 对于测试而言特别的重要 
- 抓包指的是抓客户端和服务器之间通信时的数据包

----------------

### html要点:
> 1. 前端页面注释 上线之前 必须检查或删除注释
> 2. img标签的src最多从项目根目录开始加载

----------------

### 项目实战
> 登录需求 - 1
- 1. 输入正确的中国手机号(11位)
- 当文本框失去焦点的时候验证 红色为失败 绿色为成功

- 2. 点击发送验证码
- 如果手机号文本框状态为绿色 弹出 点击按钮进行验证
- 如果手机号文本框状态为红色 提示 手机号不正确

- 3. 点击按钮进行验证
- 拖拽图形到指定为止 按钮消失
- 拖拽图形未到指定为止 晃动提醒 滑块回到初始位置
- 超过5次 提示尝试过多 请点击重试


> 登录需求 - 2
- 1. 输入验证码
- 正确的验证码 并 勾选我已阅读并同意 点击登录 进入系统
- 错误的验证码 并 勾选我已阅读并同意 点击登录 提示验证码错
- 正确的验证码 未 勾选我已阅读并同意 点击登录 提示请勾选

- 2. 点击登录
- 手机号 验证码都为绿色 勾选 我已阅读并同意 登录成功


> 测试点分析
- 用 xmind 比较清晰

> 1. 登录模块
  - 手机号
    - 正向: 11位正确手机号
    - 逆向:
      - 为空
      - 10位纯数字
      - 12位纯数字
      - 11位数字(非手机端)
      - 11位非数字
      - 未注册(格式正确)

  - 点击验证按钮
    - 发送成功
    - 发送失败
    - 规则: 
      - 5次错误
      - 晃动提醒 (这属于体验感的测试)
      - 回到初始位置

  - 输入验证码
    - 正向:
      - 正确

    - 逆向:
      - 为空
      - 错误
      - 过期

  - 勾选协议
    - 正向: 勾选
    - 逆向: 未勾


> 验证码获取功能
- 正向: 发送成功
- 逆向: 
  - 发送失败(未到位置)
  - 发送失败(重试)


> 编写用例:
- https://www.bilibili.com/video/BV1bg411V7pp?p=89&spm_id_from=pageDriver&vd_source=66d9d28ceb1490c7b37726323336322b

- 这个视频前面的部分都没听

----------------

### Linux命令
- 服务器是承载项目的位置 服务器大部分都是Linux系统 服务器没有显示器 没有鼠标 没有键盘

- 那我们要操作服务器的话 只能通过自己的电脑远程连接这台设备 通过命令去实现操作

> Linux命令使用
- 目的:
- 为了将来工作中与服务器设备进行交互而准备的技能
- 远程连接
- 命令使用

> 数据库的使用:
- 数据库存储在服务器上 mysql(增删改查)
- 测试的话 操作数据库的最主要的要求 *查询数据库*

- *没事的时候找点sql联系做做*

----------------

### Linux操作系统相关内容

> 操作系统
- 所有硬件设备组装完成后的第一层软件 *能够使用户使用硬件设备*的软件就是操作系统

- 管理计算机硬件和软件资源的计算机程序 即OS是计算的核心和基石

- 通过操作系统对硬件做各种操作 *操作系统的职责就是链接用户和硬件之间的途径*

  计算机硬件
    ↑ ↓
  操作系统
    ↑ ↓
    用户


> 常见主流操作系统
- 1. 桌面操作系统
  - window
  - mac

- 2. 服务器操作系统
  - linux
  - window server

- 3. 嵌入式操作系统:
  - linux

- 4. 移动端操作系统
  - 安卓
  - ios


> Linux简介
- Linux是一套免费使用自由传播的操作系统

- 学习的时候 需要安装虚拟机 然后再在虚拟机里面安装Linux
- 老师用的是centos7 发行版本

> Linux特点 (好用 不要钱)
- 开源免费
- 安全稳定
- 性能可靠
- 可移植性
  - 多用户 多任务 多平台 多语言

> Linux发行版本
- Linux本身就是小黑屏什么都没有 但是方便别人去用它有很多公司会推出包含自己家桌面(可视化)以及一些常用软件的额外的附加品 这些附加品和Linux系统结合起来 就变成了 Linux 发行版本

- 在原版 Linux 系统的基础上 额外的正价一些常用软件的操作系统

- 扩展: 虚拟机 - VMware Fusion
<!-- 
  账号:
    admin - ack123??
    root - 123456
 -->

              RHEL
              Centos(常见)    小红帽系列
              Fedora
  Linux发行版
              Debian          大便系列
              Ubuntu(常见, 乌班图)

- 类似于原生安卓系统和现行的华为系统/小米系统等之间的关系
- 安卓身上套壳 出来的小米等系统 这个例子中的安卓就相当于Linux原生 小米等系统就相当于Linux发行版

----------------

### 文件和路径的特点说明
> windows 和 Linux 文件系统区别
- windows系统:
- 起点是各个*盘符*

- Linux系统:
- 这个系统是没有各个盘符  起点为 */*

- Linux没有盘符的概念 只有一个根目录 / 所有文件都在他下面

                  /

                  ↓

/root /usr /etc */home* /var /bin /lib

                  ↓

/home/desktop  /home/documents  /home/downloads


**注意:**
- *Linux在根目录下的所有文件夹是不能够动的*

> /
- 根目录:
- 一般根目录下只存放目录 在linux下有且只有一个根目录 所有的东西都是从这里开始

> /root
- 系统管理员 root 的目录 一级目录

> /usr
- 系统*应用程序*存放的目录 一般安装的软件在该目录下

> /etc
- 系统*配置文件*存放的目录 不建议在此目录下存放可执行文件

> /home
- 系统普通用户的家目录
- 当前普通用户登录后 都会在home下

> /var
- 放置系统执行过程中经常变化的文件 例如 日志文件

----------------

### 远程连接操作
- 我们前面说了 我们需要使用自己的电脑去连接远程的服务器
- 远程连接的主要目的就是为了操作服务器


> 连接服务器需要具备哪些条件
- 1. 服务器的 ip 地址
- 2. 服务器的 账号 和 密码


> 常用连接工具
- 通过远程连接工具连接到服务器的操作 即为 远程连接

- finalshell (*推荐*)

- xshell
  - 个人使用免费 商用收费
  - 功能强大 有颜值 好入门 好操作
  - 高级功能需要订阅

- putty
  - 免费开源

- secureCRT
  - 收费

- MobaXterm
  - 免费


> 远程连接基本步骤
- 1. 入职后需要向相关人员(运维 开发) 获取服务器 ip 地址以及账号密码登信息

- 2. 配合远程连接工具(根据公司要求使用对应工具) 配置连接使用服务器即可


> finalshell 工具
> ifconfig:
- 查看Linux的ip地址


----------------

### finalshell使用方式
- 安装地址:
- http://www.hostbuf.com/t/988.html

- 1. 创建链接
- 新标签页的左侧有一个 *文件夹图标* 点击进入到连接管理器

- 2. 点击第一个 *白色文件夹图标* 创建 ssh连接(Linux)

- 3. 输入配置
  - 默认端口号: 22 (ssh远程连接默认端口)
  - 名称: 设置连接名(区分多台设备)
  - 主机: 目标服务器ip地址

  - 密码: 目标服务器账号 和 密码

- 4. 添加完成后 就会多出 服务器的信息 以后使用双击就可以了

**虚拟机可能会导致ip地址的变化从而链接不上 可以通过修改重新编辑**

----------------

