# 终端命令的格式:
一般会由 3个部分 组成
```
命令 [-选项] [参数]

comman [-options] [parameter]
```

**command:**  
具体命令 相应功能的英文单词或单词的缩写 执行基本功能

**-options:**  
可选选项 根据命令可以显示更加丰富的数据

**parameter:**  
可选选项 参数 命令的操作对象 一般文件 目录 用户和进程等都可以做为参数被命令操作

比如删除哪个文件路径
```js
ls
ls-a
ls-l /home/xx
```

<br><br>

# Linux系统安装 nginx
我们的 nginx 一般会放在 阿里云上的服务器 比如该服务器是 centOS  
centOS就是一个Linux服务器 服务器就相当于一台电脑 我们可以在服务器上安装 各种软件 下面我们就在Linux系统下 安装 Nginx

<br>

## 安装步骤:

### **1. 安装 gcc**  
安装 nginx 需要先将官网下载的源码进行编译 编译依赖gcc环境 如果没有gcc 则需要安装该环境

yum相当于nodejs的包管理工具

```
yum install gcc-c++
```

<br>

**注意:**  
如果安装上面的包的时候出现了404警告 那就是系统是 centOS8 的问题 7是没有的

<br>

### **解决方式: yum install 404解决方案**  

进入配置文件内，删除所有的.repo文件（也可以备份）
```js
// 进入配置文件夹

cd /etc/yum.repos.d/
// 删除旧的配置文件

rm *.repo
// 输入“y”回车确认
```

``ls``确保该目录下的 .repo文件 已完全删除  
下载可以用的.repo文件
```
wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo
```

如果你没有 **安装wget**，也可以用下面命令：
```
curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo
```

运行 yum makecache 生成缓存  
```
yum makecache
```

<br>

### **2. PCRE pcre-devel安装:**  
它是一个 perl 库 包括perl兼容的正则表达式库  
nginx的http模块使用 pcre 来解析正则表达式 所以需要在 linux 上安装pcre库 

pcre-devel 是使用 pcre 开发的一个二次开发库。nginx也需要此库。

```
yum install -y pcre pcre-devel
```

<br>

### **3. zlib 安装:**  
zlib 库提供了很多种压缩和解压缩的方式， nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 Centos 上安装 zlib 库。
```
yum install -y zlib zlib-devel
```

<br>

### **4. OpenSSL 安装**  
OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。

nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要在 Centos 安装 OpenSSL 

```
yum install -y openssl openssl-devel
```

<br>

### **5. 下载Nginx**
```
wget https://nginx.org/download/nginx-1.19.9.tar.gz 
```


<br>

### **6. 解压nginx**
```
tar -zxvf nginx-1.19.9.tar.gz
cd nginx-1.19.9
```

<br>

### **7. 执行nginx-configure文件**  
```
./configure
```

<br>

### **8. make命令编译**  
上面7中执行完 configure 后会有一个MakeFile文件夹

这时我们要执行 make 命令 类似安装的操作

make 是一个命令工具，它解释 Makefile 中的指令（应该说是规则）。在 Makefile文件中描述了整个工程所有文件的编译顺序、编译规则
```
make
make install
```

<br>

### **9. 查询nginx 安装目录**  
会输出号 nginx 所在的目录
```
whereis nginx
```

<br>

### **10. 进入安装目录执行nginx**  
前往安装目录找到sbin 进去后 能找到nginx可执行文件 执行nginx
```
./nginx
```

执行完该命令后我们进入 公网地址 比如 192.168.60.29 就能打开nginx的欢迎页面

<br><br>


# Nginx 服务器占用的端口
默认占用 80 端口  

如果80端口已经开启 但是访问公网地址 还是没有欢迎界面 那我们就需要检查Linux的防火墙
我们先执行 Linux 打开的所有防火墙的端口

<br>

### **查看所有打开的端口:**
```
firewall-cmd --zone=public --list-ports
```

如果没有开启80端口 我们执行下面的命令打开Linux的防火墙

<br>

### **添加:**  
--permanent永久生效，没有此参数重启后失效
```
firewall-cmd --zone=public --add-port=80/tcp --permanent    
```

添加之后我们要 reload 防火墙

<br>

### **重新载入:**
```
firewall-cmd --reload
```

<br><br>

# 配置 Nginx 环境变量
如果不配置的话 我们只能每次去 sbin 下面敲命令

```js
cd /
cd etc
vim profile

// 最后的行上添加如下的信息
export PATH=$PATH:/nodexxxx/bin:/usr/local/nginx/sbin

source profile
```

<br>

# Nginx的常用命令

### **启动 Nginx**  
启动后我们可以访问网址
```
nginx
```

<br>

### **停止 Nginx**   
启动后我们可以访问网址
```js
nginx -s stop

// Quit 是一个优雅的关闭方式，Nginx在退出前完成已经接受的请求处理
nginx -s quit
```

<br>

### **查看nginx版本号:**
```
nginx -v
nginx -V
```

<br>

### **查看nginx进程:**
```
ps -ef | grep nginx
```

<br>

### **重载Nginx配置文件:**
```js
nginx -s reload


// 配置文件在
cd /usr/local/nginx
cd conf
vim nginx.conf
```

<br><br>

# Linux 防火墙 

<br>

## 1. firewalld的基本使用

### **启动:** 
```
systemctl start firewalld
```

<br>

### **查看状态:**
```
systemctl status firewalld 
```

<br>

### **停止:**
```
systemctl stop firewalld 
```

<br>

### **禁用:**
```
systemctl disable firewalld
```

<br>

## 2. systemctl是CentOS7的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。

### **启动一个服务:**
```
systemctl start firewalld.service
```

<br>

### **关闭一个服务:**
```
systemctl stop firewalld.service
```

<br>

### **重启一个服务:**
```
systemctl restart firewalld.service
```

<br>

### **显示一个服务的状态:**
```
systemctl status firewalld.service
```

<br>

### **在开机时启用一个服务:**
```
systemctl enable firewalld.service
```

<br>

### **在开机时禁用一个服务:**
```
systemctl disable firewalld.service
```

<br>

### **查看服务是否开机启动:**
```
systemctl is-enabled firewalld.service
```

<br>


### **查看已启动的服务列表:**
```
systemctl list-unit-files|grep enabled
```

<br>


### **查看启动失败的服务列表:**
```
systemctl --failed
```

<br>

## 3.配置firewalld-cmd

### **查看版本:**
```
firewall-cmd --version
```

<br>

### **查看帮助:**
```
firewall-cmd --help
```

<br>

### **显示状态:**
```
firewall-cmd --state
```

<br>

### **查看所有打开的端口:**
```
firewall-cmd --zone=public --list-ports
```

<br>

### **更新防火墙规则:**
```
firewall-cmd --reload
```

<br>

### **查看区域信息:**
```
firewall-cmd --get-active-zones
```

<br>


### **查看指定接口所属区域:**
```
firewall-cmd --get-zone-of-interface=eth0
```

<br>

### **拒绝所有包:**
```
firewall-cmd --panic-on
```

<br>

### **取消拒绝状态:**
```
firewall-cmd --panic-off
```

<br>

### **查看是否拒绝:**
```
firewall-cmd --query-panic
```

<br>

## 那怎么开启一个端口呢?

### **添加:**
--permanent永久生效，没有此参数重启后失效
```
firewall-cmd --zone=public --add-port=80/tcp --permanent    
```

<br>

### **重新载入:**
```
firewall-cmd --reload
```

<br>

### **查看:**
```
firewall-cmd --zone= public --query-port=80/tcp
```

<br>

### **删除:**
```
firewall-cmd --zone= public --remove-port=80/tcp --permanent
```

<br>

# ssh链接到远程服务器
```
ssh 账户名@公网ip

ssh root@192.168.60.29
```

<br>

# 在远程服务器上安装nodejs
首先打开 nodejs 网站
```
nodejs.cn/download/current/
```

<br>

选择 Linux二进制文件 x64 选择64位, 然后下载下来后 我们能在谷歌浏览器上找到下载内容选项卡 能看到我们的下载包下面有网址 复制下来

<br>

回到终端 通过命令下载nodejs
```
wget 复制的网址
```

<br>

查看是是不是下载到目录里面了
```
ls

xxx.tar.xz
```

<br>

解压 下载的压缩包
```
tar -xvf 压缩包 
```

<br>

然后我们进入到 解压后的文件夹中 找到 bin 目录后进去 就能使用 node 的命令  
但是我们在bin目录下是可以 但是出了bin目录就不好用了 所以我们要配置环境变量

<br>

# linux下配置node全局环境变量
先复制下 node文件夹下的bin目录的地址
```
cd node-v14.19.1
cd bin
pwd
```

<br>

linux的环境变量叫做 $PATH, 我们可以通过下面的命令 查看已有的环境变量
```
echo $PATH
```
我们能看到 它是以 : 来分割各个路径的


<br>

去 / 目录下 的 etc 文件目录中 我们要先进去
```
cd etc
```

<br>

使用 vim 打开 profile 文件
```
vim profile
```

使用i 然后在最后追加下面的内容
```
export PATH=$PATH:我们复制的node的bin路径
```

<br>

保存退出后我们还要使用下面的命令执行下
```
source profile
```

<br>

在 linux 上安装好node后 我们就可以在 linux上通过 node 安装 pm2 了

<br><br>

# SSH
```
https://www.wangdoc.com/ssh/basic.html
```

<br><br>

# Bash
```
https://www.wangdoc.com/bash/intro.html
```

<br><br>

# Linux文件系统
Linux系统环境下的文件系统与Windows有很大区别。 在Windows中, 每一个盘符下是一个独立的文件系统, 硬盘有多少个分区就有多少个文件系统。

Linux系统中不管创建了多少个硬盘分区都只有一个文件系统。*整个文件系统的根目录是“/”*, 从“/”出发可以找到Linux系统中的所有目录和文件。

<br>

## 用户的家目录:
Linux是一个多用户系统, 每个登录到系统的用户都需要有一个自己专属的目录保存自己私有的文件。系统当然看到了这个需求, 所以每创建一个普通用户, 系统就会在 **/home** 目录下创建一个和用户同名的目录作为这个用户的家目录。

比如: 创建一个名为tom的用户, 它的家目录就是/home/tom

<br>

### **~ 表示家目录:**
可以使用“~”代表用户的家目录。
特殊的是作为系统的超级管理员, root用户的家目录是/root目录

<br>

### **进入 根目录**
我们进入的是 Macintosh HD
```
cd /
```

<br>

### **进入 家目录**
我们进入的是 ユーザ - *LIUCHUNSHAN*
```
cd ~
```

<br><br>

# Linux系统的目录介绍:
### **/bin:**
bin是binary的缩写, 这个目录存放着最经常使用的命令。

<br>

### **/boot:**
这里存放的是启动Linux时用到的引导程序文件。

<br>

### **/dev:**	
device(设备)的缩写, 该目录下存放的是Linux的外部设备。

<br>

### **/etc:**	
存放系统和第三方应用程序的配置文件。比如配置环境变量就是在这个文件夹中

<br>

### **/opt:**
存放安装第三方应用程序时使用的压缩包文件

<br>

### **/home:**
存放普通用户家目录。

<br>

### **/lib和/lib64:**
系统开机所需要最基本的动态连接共享库。

<br>

### **/media:**	
挂载Linux系统会自动识别的设备, 例如U盘、光驱等。

<br>

### **/mnt:**	
专门用于挂载操作的目录。

<br>

### **/proc:**
这个目录是一个虚拟的目录, 它是系统内存的映射。

<br>

### **/root:**
超级管理员root用户的家目录。

<br>

### **/run:**
存放进程产生的临时文件, 关机重启后会消失。

<br>

### **/sbin:**
s是Super User的意思, 这里存放的是系统管理员使用的系统管理程序。

<br>

### **/srv:**	
service缩写, 该目录存放一些服务启动之后需要提取的数据。

<br>

### **/sys:**	
该目录下安装了2.6内核中新出现的一个文件系统sysfs。

<br>

### **/tmp:**	
存放临时文件。

<br>

### **/usr:**	
应用程序的默认安装目录, 类似于Windows下的program files目录。

<br>

### **/var:**	
存放经常变化的内容, 例如日志文件。

<br><br>

# Linux 常用命令
因为服务器没有鼠标键盘 所以移动文件 删除文件等常规操作 是必须要熟练的

### **查看当前路径位置:**
```
pwd
```

<br><br>

# 文件 和 目录 相关命令

### **快捷键:**
```
Ctrl+l	      清屏
Ctrl+c	      强制终止程序
Ctrl+Insert	  复制
Shift+Insert	粘贴
Ctrl+s	      锁屏
Ctrl+q	      解除锁屏
tab	          自动补全
```

<br>

### **进入目录:**
切换到当前用户的主目录(/home/用户目录)   
用户登录的时候 默认的目录就是用户的主目录
```js
cd 目录名
cd [相对路径/绝对路径]

cd

// 切换到当前用户的主目录(如果我是root就切换到root 如果我是admin则切换到admin)
cd ~

// 切换到根目录
cd /

// 上一次所在的目录 (回退上一步呗)
cd -
```

**注意:**  
如果路径是从根路径开始的 则路径的前面需要加上 /  
如 /home 通常进入某个目录里面文件夹 前面不用加 /  

绝对路径是从  / 或 ~ 开头的   
相对路径是从 ./ 或 ../开头

<br>

### **创建目录:**
```js
// 单层
mkdir 路径

// 创建多个文件夹
mkdir 目录名1 目录名2

// 其中aaa/bbb是存在的目录, 要创建的仅仅是ccc
mkdir aaa/bbb/ccc

// 多层
mkdir -p 路径

// 其中bbb/ccc/ddd都不存在, 现在想一次性把这些目录都建出来
mkdir -p aaa/bbb/ccc/ddd
```

**注意:**  
如果文件已存在则创建失败

<br>

### **查看目录内容(list):**
查看目录下的内容 会列出名称 
```js
ls 
ls 其它目录

ll

// 不用特定切换到指定文件在ls 直接后面直接跟路径
ls /home/damin
```
**作用:**   
列出目录中的内容, 这里所说的目录可以是当前目录也可以是其他目录(需要指定路径。

命令的参数既可以单独使用也可以组合使用。同时ls -l可以简写为ll。
<br>

**参数:**  
**<font color="#C2185B">-a:</font>**  
显示指定目录下所有子目录与文件 包括隐藏文件

**<font color="#C2185B">-l:</font>**  
以列表的方式显示文件的详细信息

**<font color="#C2185B">-R:</font>**  
递归查看目录内容

<br>

我们以 ls -l 查看的信息 会出现下方的格式:

**第一列:**
```
lrwxrwxrwx
dr-xr-xr-x
```

上面的首字母的意义为:
```
文件对应的是          -
目录对应的是          d
快捷方式对应的是       l 
U盘对应的是           b
鼠标键盘等硬件对应的是  c
```

**第二列:**   
代表的是该目录下的文件数量

**第三列:**  
用户名 组名

**第四列:**  
文件夹 或 文件的体积

**第五列:**  
文件的创建日期

<br>

### **查看当前所在的目录(print work directory):**
```
pwd
```

<br>

### **新建文件:**
```js
touch 文件.后缀

// 创建空文件
touch 文件.js
touch 新建文件的路径


// 创建多个文件
touch aa bb
```

**说明:**
如果文件不存在 新建空白文件  
如果文件已存在 可以修改文件的末次修改日期

这个命令本体是为了修改文件修改时间的 它有一个附带的效果 如果文件不存在则创建

<br>

### **新建文件并往里输入内容:**
```js
// 将内容写入到index.js 中 覆盖
echo 内容>index.js

// 追加新内容
echo 内容>>index.js


// 只创建没内容
echo >index.js
```

<br>

### **复制(copy):**
复制文件 或者 目录 到另一个 文件 或 目录中
```js
cp [选项] 数据源 目的地


// 复制文件: 
cp 被复制的文件的路径 目标目录的路径

// 复制目录: 
cp -r 被复制的目录的路径 目标目录的路径
```

**参数:**  
**-i:**  
交互式复制 在覆盖目标文件之前将给出提示要求用户确认

**-f:**  
覆盖已经存在的目标文件而不提示

**-r:**  
若给出的源文件是目录(文件夹) 则cp将递归复制该目录下的所有子目录和文件 目标文件必须为一个目录名

**-v:**  
显示拷贝进度

<br>

**注意:**
复制的时候 源文件和新文件都在 如果是复制的文件夹 需要加上 -r 参数
```js
cp -r bdir cdir
```

<br>

### **移动(move) - 重命名:**
移动文件或目录  
将目录或文件在当前位置移动可以起到重命名的作用
```
mv [选项] 数据源 目的地

mv 被移动的文件或目录的路径 目标目录
```

**参数:** 
**-f:**  
禁止交互式操作 如有覆盖也不会给出提示

**-i:**  
确认交互式操作 如果mv操作将导致对已存在的目标文件的覆盖 系统会询问是否重写 要求用户回答以避免覆盖文件

**-v:**
显示移动进度


移动文件的时候 源文件是不保留的哦

<br>

### **删除(remove):**
删除目录或文件

**注意:**  
使用rm命令要小心 因为文件删除后不能恢复 为了防止文件误删  
*可以在rm后使用 -i 参数 以逐个确认要删除的文件*

```js
rm [选项] 文件/目录


// 删除文件: 
rm 被删除的文件的路径

// 强制删除文件: 
rm -f 被删除的文件的路径

// 递归删除目录: 
rm -r 被删除的目录的路径

// 强制删除目录: 
rm -rf 被删除的目录的路径
```


**参数:**  
**-i:**  
以进行交互式方式执行

**-f:**  
强制删除 忽略不存在的文件 无须提示(可以忽视报错)  
因为如果删除的文件不存在 就会报错 删除的动作就会被终止 有些场景下 不希望被终止 所以加上 -f

**-r:**  
递归地删除目录下的内容 删除文件夹时必须要加上此参数

<br>

**注意:**  
删除命令是危险命令 *一定要加上 -i*   
因为删除的命令 删除的文件想要找回来特别困难 所以要加上 -i

类似的命令有 都要使用 -i
- rm
- mv
- cp


**删除文件夹的时候** 要加上 -r
```js
rm -ir adir
```

**示例:**
删除当前目录下所有文件和文件夹
```sql
-- 移除 当前文件目录下 所有文件
rm -rf *

-- 干掉了 根目录下所有的文件
rm -rf /*   // 慎用！！！！！！！
```

<br>

### **vim:**
在命令行环境下编辑文本文件  
在命令行模式下没有鼠标, 所以刚开始使用的时候会觉得非常不习惯。但是慢慢的熟练之后你会发现, 不需要鼠标全部用键盘就可以操作效率很高 

<br>

### **三种模式:**
1. 一般模式:   
通过按键控制 vim 工作 按 i l a A o 等 键位

2. 编辑模式:  
可以自由输入 按 ? : / 等 键位

3. 指令模式:   
通过执行指令完成一些特殊的操作 按 enter 键位 执行指令

<br>

### **打开一个文件:**
如果文件不存在 **那么就是新建一个文件**
```
vim content.txt
```

```js
  // 进入的画面 为一般模式 一般模式的模版
  ~
  ~
  ~
  ~
  ~
  ~
```

<br>

### **回到一般模式:**
按下 esc

<br>

### **回到一般模式后 输入":"**
:会进去指令模式

<br>

### **进入编辑模式:**
进入编辑模式有很多种方法

**方式1:**  
按下 i 键

<br>

### **显示行号 set nu:**
当我们回到 一般模式的时候 输入 : 后 再输入 set nu 会显示行号

<br>

### **保存文件 :w:**
回到一般模式的之后 输入 w

<br>

### **退出 q:**
退出vim

<br>

### **保存退出 wq:**

<br>

### **不保存直接退出就使用 q!:**

<br>

### **上下左右移动光标:**
**方法1:** 上下左右键
**方法二:**
```
hjkl
←↓↑→
```

<br>

### **前往指定行:**
在 按esc后回到一般模式后 按下面的命令(英文输入法的状态下)

**第一行: gg:**  
将光标定位到第一行开头的位置。此时屏幕上并不会显示你输入了什么, 需要你自己心里面知道。

<br>

**最后一行: G:**  
将光标定位到最后一行开头的位置。

<br>

**指定行号:**  
假设我们要去第12行, 那么依次输入“1”、“2”、“G”即可。

<br>

### **改:**
这里我们说的是在一般模式下通过按键来编辑文件, 并不是进入编辑模式。

**dd:**  
删除光标所在的行

<br>

**d5d:**  
从光标所在行开始, 向下连续删除5行(包括光标所在行)

<br>

**u:**  
撤销刚才的操作

<br>

**Ctrl+r:**  
重做刚才撤销的操作

<br>

**yy:**
复制光标所在的行

<br>

**p:**  
将当前复制的行粘贴到光标所在位置的下一行

<br>

**y3y:**  
从光标所在行开始, 向下连续复制3行(包括光标所在行)

<br>

**r:**  
替换光标所在位置的一个字符  
第一步: 按一下r键  
第二步: 输入新的字符  

<br>

### **进入编辑模式的方式:**
**i:**  
不动, 就在当前位置, 开始输入

<br>

**I:**  
移动到行的开头, 开始输入

<br>

**a:**  
光标向后移动一格, 然后开始输入

**A:**  
光标移动到行的末尾, 然后开始输入

**o:**  
先在光标所在行的下面插入空行 然后把光标移动到空行的开头, 再开始输入

<br>

### **搜索:**
**进入指令模式下 输入 /:**  
进入专门用于搜索关键词的指令模式

然后输入关键词 回车执行搜索 遍历匹配内容
- 输入n向下找
- 输入N向上找

取消高亮显示 使用 :noh 指令即可取消高亮

<br>

### **替换 %s/被替换内容/新内容:**
在: 的状态下输入 %s/被替换内容/新内容 /g  
/g 全局匹配

<br><br>

# 文件和目录相关命令 cat
服务器上没有鼠标 怎么打开文件 可以用 cat 命令, 会一次显示所有内容 *适合 查看内容较少 的文本文件*

<br>

### **显示文件全部内容:**
适用场景: 较短小的文件
```
cat [选项] 文件名
```

**参数:**  
**-b:**  
对 非空输出行 编号

**n:**  
对 输出的所有行 编号

<br>

### **查看 文件 中的内容 (分屏):**
在服务器查看文件内容 如果文件内容太多的话 cat命令查看文件内容的时候 是展示不全的  

用于分屏显示文件内容 每次只显示一页内容 适合于 查看内容较多 的文本文件
```js
less [参数] 文件名

// more命令会用百分比提示我们当前在什么位置
more [参数] 文件名
```

**空格:**	  
向下滚动一屏

**b:**
向上滚动一屏

**回车:**	
向下滚动一行

**f:**
前滚一屏

**q:**	
退出

**-N:**  
对输出的所有行编号
```
less -N demo
```

**/ 关键词**  
搜索 指定单词 字符串

```
n向下找
N向上找
= 显示详细的文件信息
```
	
<br>

### **查看开头的内容:**
用来显示文件前10行的内容(如果不加参数默认显示文件前10行内容)
```
head [-num] 文件名

head -10 temp.txt
```

**参数:**  
**-f:**  
*实时监控文件内容* 用于查看线上服务的运行日志 实时显示写入日志的信息

<br>

### **显示文件末尾的部分内容:**
```js
tail [-num] 文件名

// 查看文件末尾5行的内容
tail -n 5 文件

// 打开要监视的文件
tail -F 文件
```

**参数:**  
-F 实时查看文件末尾新增的内容 Ctrl+c 退出实时监控

<br>

head tail 命令多用于查看日志文件(一种负责记录系统或程序运行过程信息的文件)内容时使用
测试人员可以通过查看日志文件信息 帮助判断bug出现的原因

<br>

### **示例:**
使用 ping 命令 模拟日志不断写入 我们将日志内容写入到 demo 文件中 通过 tail -f 实时监控文件
```js
// 将不断出现的ping结果信息 追加到 ping_log 文件中 用于模拟日志文件内容时不断变化的场景
ping 127.0.0.1 >> ping_log

// 查看ping_log内容 第一屏进来的时候是5条
tail -5f ping_log
```

<br>

### **找bug技巧:**
在程序要出错的时候 我们需要复现 比如点了某个按钮系统崩了 我们在复现的时候还是要点这个按钮 在点按钮之前 我们把日志准备好 我们写上 

```
tail -20f ping_log
```

这个命令和点击按钮的操作同时进行 按钮一敲程序就崩了 这样蹦的信息就会写入到 ping_log 文件中 *首屏进来的20行里面肯定有导致程序崩溃的信息*


**技巧:**  
查看文件中 指定行数 如 查看文件中的第10-15行信息
比如一共22行

我们可以用 head 命令查看1-15行信息 然后通过 tail 命令查看后5行信息
```
head -15n demo | tail -5
```

最后不用写文件名了 因为左边会作为数据源传递到右边


<br>

### **搜索 文本文件 内容:**
根据关键词 搜索文本文件的内容 将包含关键词的内容过滤出来后显示
```
grep [选项] 关键词 文件名
```

**参数:**
**-v:**  
显示不包含匹配文本的所有行(相当于求反)

**-n:**   
显示匹配行以及行号

**-i:**  
忽略大小写

<br>

### **管道符 |:**
将一个有结果的命令 通过管道 做为数据源 自动输入到 需要读的命令中被当做数据源  
可以理解为现实生活中的管子 管子的一头塞东西进去 另一头取出来 这里可以理解为

有结果的命令 | grep 关键词 (这里省略的数据源)

```js
// 要提取包含mysql的信息 但是没有指定从哪检索, | 管道符的左边就是 数据源 也就是从ls的内容里面进行检索指定的数据
ls -al /usr/bin/ | grep mysql
```

通过管道符可以方便快捷的讲两条指令结合起来 以省去需要先将结果写入到文件 再进行查找的操作 在测试工作中 我们只需要掌握管道符右侧使用grep命令就可以

<br>

### **查找文件或目录:**
```
find 路径 -name 文件名

find /root -name "*.txt"
```

/root: 查找范围  
-name: 根据名称查找  
"查找内容的表达式"

<br>

**注意:**
root根目录下是没有办法查找的
文件名 可以加引号 也可以不加引号
如果当前用户对目标路径咩有访问权限 则无法执行查找文件动作

<br>

**总结:**
grep 命令多用于 查看文件内容
which 命令多用于 查找可执行文件的位置

find 命令多用于 查找普通文件  
find命令功能非常强大 通常用来在特定的目录下 搜索符合条件的文件

<br><br>

# tar包解压命令
在Linux系统环境中, 很多程序安装包都是以tar包的形式提供下载的: 

### **tar包解压命令:**
默认<font color="#C2185B">解压到当前目录下</font>, 如果当前目录下有同名的目录或文件会被直接覆盖, 没有任何提示, 这一点请大家注意。
```
tar -zxvf tar包路径
```

**参数:**  
**-z:**	 
用 gzip 对存档压缩或解压

**-x:**	   
解压

**-v:**	 
详细显示处理的文件

**-f:**	 
指定存档或设备 (缺省为 /dev/rmt0), 该参数必须指定且在最后一位

<br><br>

# 进程相关命令
进程可以说跟软件是对应关系 软件运行过程中在后台运行的某个信息叫做进程 因为进程和软件是对应的关系 我们可以通过关闭进程从而关闭软件

在 Linux 系统中 没有图形化页面 我们没有办法像操作windows图形化界面那样找到任务管理器 找到程序进程 点击结束任务 我们要想结束再linux中的一个程序 

那我们只能通过命令行的方式来进行操作但是不是说所有软件的进程信息只有对应的一条

### **查看当前正在运行的进程(process status):**
```
ps -ef
```

**参数:**  

**a:**  
显示终端上的所有进程 包括其他用户的进程

**u:**  
显示进程的详细状态

**x:**  
显示没有控制终端的进程

**-e:**  
对应单词entire, 表示全部。具体指显示系统中全部的进程信息。

**-f:**   
对应单词full-formate, 表示完整格式。

<br>

**注意:**
ps 默认只会显示当前用户通过终端启动的应用程序
每一个进程拥有唯一的 pid 可以根据 pid 杀死进程 如

```
kill 12378 或 kill -9 12378(强制杀死)
```

<br>

### **查看当前系统重正在执行程序的详细状况:**
ps -aux 是将我们执行这个命令的那一刻的进程信息 展示在控制台上 并不是动态连续的 如果想对进程运行时间监控 应用使用 top 命令
```
ps -aux
```

<br>

**示例:**
```js
// 第一行的信息头
USER

PID       // 进程 id

%CPU      // cpu使用率
%MEM      // 内存使用率

VSZ
RSS
TTY
STAT
START
TIME

COMMAND   // 当前的 id 对应的软件是哪一个 我们可以看到知道我们要关闭的目标软件是谁
```

<br>

### **展示信息解析:**

**UID**	 
进程的用户信息

**PID**	  
进程id。由系统分配, 不会重复。

**PPID**	 
父进程的id。父进程和子进程的关系是: 父进程启动了子进程。

**CMD**	  
当前进程所对应的程序。

**C**	  
用整数表示的CPU使用率

**STIME**	  
进程启动时间

**TTY**	  
进程所在终端。所谓终端就是用户输入命令的操作界面。

**TIME**	
进程所占用的CPU时间

<br>

### **分屏查看进程信息:**
全部进程的信息太多了, 一屏无法全部显示, 所以我们希望可以分屏显示并由我们来控制翻页。为了达到这个目标, 我们可以使用管道符号将ps -ef命令的输出数据传送给less命令。

```
ps -ef | less
```

<br>

### **获取 特定或指定程序 的pid:**
我们使用 ps -aux 会提取所有的进程 太多了 我们只想要我们想要的 所以可以利用 | 搭配 grep 进行过滤

```
ps -aux | grep nmon
```

<br>

### **杀死进程:**
终止指定代号的进程, -9 表示强行终止
```
kill [-9] 进程代号(pid)

kill -s kill 3325
kill -9 3325
```

<br>

### **实时查看系统运行情况和健康状态:**
动态显示运行中的进程并且排序
```js
// 直接输入这个命令就可以 它就是命令行版的任务管理器
top
```

<br><br>

# 辅助命令

### **用来打印环境变量的值:**
在Linux系统中通过$来引用环境变量 比如: $PATH
```js
echo

// 使用echo输出环境变量
echo $PATH
```

<br>

### **``\``**
如果一个命令特别长, 那么可以使用反斜杠表示到下一行继续输入

<br>

### **工具: curl (client url)**
通过命令给服务器发送请求  
这个工具是 Linux 下面的命令 默认情况下 系统没装 需要我们自己安装

当我们用来做测试的时候更纯粹更简单一些 因为浏览器为了让我们加速访问会在多个地方设置缓存 有可能刷不到最新的页面 使用 curl 的话 就能很有效的解决这个问题

### **安装:**
```
yum install -y curl
```

### **curl 命令**
```js
curl 请求地址

// 会显示完整的页面
curl http://192.168.44.101/
```

**参数:**

**-I**  
不会将内容返回 而是返回头信息
```
curl -I http://192.168.44.101/img/logo.png
```


**-e**
可以设置指定的referer
```
curl -e "http://baidu.com" -I http://192.168.44.101/img/logo.png
```

**-v**  
发起请求 响应回的是完整的http响应  
有请求行 请求头 请求体 响应行 响应头 空行 响应体
```
curl -v http://baidu.com
```

**-X**  
指定请求方式
```
curl -X POST [请求地址]
```

<br><br>

# 字符串命令

### **返回路径字符串中的 资源(文件或目录本身) 部分:**  
如果指定了后缀, basename会帮我们把后缀部分也去掉
```
basename 路径
basename /aa/bb/cc/dd --> 返回dd
```



### **返回路径字符串中的 目录 部分:**
```
dirname 路径
dirname /aa/bb/cc/dds --> 返回/aa/bb/cc
```

<br><br>

# Linux系统的权限控制

### **权限:**
权限=权力+限制。  

对任何计算机系统来说, 我们都不能允许用户在系统中为所欲为。我们必须知道“谁在什么时候对什么资源做了什么操作”, 这就是系统日志要记录的内容。不仅如此, 系统还必须有能力禁止用户操作没有访问权限的资源。

<br>

## 基础命令:

### **创建用户组:**
```
groupadd 组名
```

<br>

### **返回用户信息, 检查用户是否存在:**
```
id 用户名
```

<br>

### **创建用户, 同时指定所属用户组:**
```
useradd -g 组名 用户名
```

<br>

### **给用户账号设置密码:**
```
passwd 用户名
```

<br>

### **文件权限信息说明:**
权限信息共分三组, 每组三位: 
```
rwx r-x r-x
```

**第一部分:**  
文件所属用户的访问权限

**第二部分:**  
文件所属用户组的访问权限

**第三部分呢:**  
其他人的访问权限

<br>

**r: 数字4**  
读(read) 读文件 查看文件内容

**w: 数字2**  
写(write)  
写文件: 向文件中写入新内容  
写目录: 在目录里面增删内容

**x: 数字1**  
执行(execute)  
执行文件: 把文件当作可执行文件来运行  
执行目录: 使用cd命令进入目录

**-:**  
无权限

<br>

### **: 修改权限信息:**
```
chmod 权限数字 文件名

chmod 777 文件名
```

<br>

### **修改文件或目录的所属主: chown 命令**
### **修改文件或目录的所属组: chgrp 命令**

<br>

### **创建新用户 并为新用户设置密码:**
添加的新用户可以在 home 目录下看到

```js
adduser 用户名
passwd 用户名

// 使用新用户连接远程服务器
ssh 新用户名@公网地址
```

<br>

### **修改权限命令 - 数字法:**
需要根据需求 先行计算每个位置的权限结果  
```
r:4 w:2 x:1 -:0
```

无论目标文件的权限做何修改 每一个部分都必须有结果 数字一定是3位 706  
如果某一个部分没有任何权限 直接给0  
文件权限是可以进行多次修改的 不要害怕修改错误  

<br>

### **chmod 数字权限数值 文件名:**
在设置权限时 可以简单的使用三个数字分别对 用户/用户组/其他人 表示用户的权限
```
chmod 755 文件名  
```

常见数字组合有(u表示用户 g表示用户组 o表示其他)
```
777 -> rwx rwx rwx
755 -> rwx r-x r-x
644 -> rw- r-- r--
```

**注意事项:**
1. 必须文件权限的含义
2. 使用数字法海是字母法全凭个人喜好
3. 尽量注意不要随意赋予文件最高权限: 777/rwx
4. 建议适当修改文件权限
  - 比如: 数字法: 755
  - 比如: 纯内容文件(不可执行文件) 权限给644就可以了

<br>

### **普通用户提升权限:**
在公司参与开发的过程中, 通常我们不会拿到服务器系统的 root 权限, 而是普通用户权限。但是普通用户很多操作无法执行。

**解决方案:**  
将需要提权的普通用户加入到/etc/sudoers文件中
``` 
91 ## Allow root to run any commands anywhere 
92 root    ALL=(ALL)       ALL
93 luozhixiang ALL=(ALL)   ALL
```

不需要重启系统, 我们再次测试提权: 
```
sudo mkdir aaa
```

再修改/etc/sudoers文件
```
luozhixiang ALL=(ALL)   NOPASSWD:ALL
```

这样再使用sudo命令就不需要输入密码了

<br><br>

# Linux系统提供的Shell解析器
其中最常用的是 /bin/sh 和 /bin/bash  
Linux默认的解析器是bash

<br>

### **bash 和 sh 的关系:**
sh是bash的软链接

<br>

### **Shell语法总述:**
变量 + 运算符 + 变量 = 表达式 -> 流程控制

<br>

### **Shell编程HelloWorld:**
1. 创建脚本文件  
通常以.sh作为扩展名

2. 脚本内容  
第一行指定当前脚本的解析器: #!/bin/bash

**实现具体功能:**  
```
echo "hello world"
```

<br>

### **Shell脚本的运行方式:**
```js
// 在当前进程运行
source

// 在当前进程运行 其中“.”是source的另一种写法
.

// 新建子进程运行
sh

// 新建子进程运行
bash

// chmod +x后直接运行
新建子进程运行
```

<br>

### **系统预定义变量:**
常用系统变量包括: 
- $USER
- $HOME
- $PWD
- $SHELL等

可以使用echo命令输出它们的值。

<br>

### **自定义变量:**
定义变量
```
USER_NAME=tom
```

<br>

### **显示 command 命令的帮助信息:**
```
command --help
```

<br>

### **查阅 command 命令的使用手册:**
```
man command
```

<br>

### **查看 ip 地址:**
```
ifconfig

ip addr
```
```
所有用于远程连接的ip地址的最后一位永远不能是1

在一个网络范围内 一般有 1-255 个ip地址 1 和 255 会被入网以及出网设备给占用
在任何一个网络环境内 如果ip地址有顺序的话 大致上说第一个设备的结尾是1 最后一个设备的结尾是255 这两个被用掉了

inet 10.211.55.3
```

<br>

### **ping其他的网络:**
```
curl www.baidu.com
```

在本机上ping下与服务器(虚拟机)ip地址检查连通性
```js
// 打开终端(在本机上 ping)
ping 10.211.55.3
```

<br><br>

# Linux 系统信息命令

### **输出 信息 到文件中 (重定向符号 > >>):** 
Linux允许将命令执行结果 *重定向* 到一个文件  
将本应显示在**终端上的内容 输出/追加 到指定文件**中

<br>

**语法:**  
**<font color="#C2185B">控制台中的信息 > 目标文件(路径):</font>**  
控制台中的信息 是通过 命令得到的 比如 ls -al

```js
// 表示输出 会覆盖文件原有内容
> 

// 表示追加 会将内容追加到已有文件的末尾
>>


// 将 / 目录下的详细信息 输出到 demo 文件中
ls -al / > demo
```

<br><br>

# 查看系统版本 重启 和 关机
我们在 window 里面点击我的电脑 能看到系统的版本

版本: windows 10 专业版  
操作系统内部版本: 190431110 (开发人员关注的)

不同的系统版本信息查看都是通过查看特定文件内容来获取 不同系统文件名可能不一样  
其他系统需要获取系统版本信息 可以搜索 
  
*系统类型-内核版本/发行版本*

<br>

### **查看当前系统内核版本信息:**
```
cat /proc/version
```

<br>

### **查看当前系统发行版本信息:**
套壳的那个版本(增加了发行商自己的界面和功能)
```
cat /etc/redhat-release
```

<br>

### **重启当前系统:**
重新启动操作系统 执行命令后立即重启操作系统
```
reboot
```

<br>

### **关闭当前系统:**
关闭操作系统 执行命令后 提示1分钟后关闭操作系统
```js
shutdown

// 重新启动操作系统 shutdown会给别的用户提示
shutdown -r now 

// 立刻关机 其中 now 相当于时间为0的状态
shutdown -h now

// 系统在今天的20:25会关机
shutdown -h 20:25

// 系统再过10分钟后自动关机
shutdown -h +10

// 这个命令是也关机的指令
poweroff
```

<br><br>

# 文件的上传:

## 方式1:
finalshell 里面下方有可视化面板 面板中有上传和下载的按钮

将文件上传到指定的目录里面 从本地上传到服务器

<br><br>

# 文件的下载:
从服务器下载文件到本地

<br><br>

# 端口号相关命令
端口号: 门牌号

想要连接至服务器 需要使用 ip 地址 再想获取在服务器上运行程序 需要通过端口号

同一台服务器不能有多个程序同时使用同一个端口号 因此在运行程序时 如果提示 端口号被占用 需要先找到占用端口号的程序 并结束掉它 然后才能运行自己的程序

常见的端口号:
```
http: 80
https: 443
ssh: 22
mysql: 3306
```

<br>

### **显示各种网络相关信息:**
用于查看显示网络状态 *常用于查看软件打开的端口信息*
```
netstat
```

查看所有的进程和端口使用情况 一般用来查看端口被哪些程序使用 但是我们不单独使用
```
netstat -anptu
```

结合grep查找指定程序打开的端口 比如这里查找的就是mysql正在使用的端口号
```
netstat -anptu | grep mysql(或者找指定端口3306)
```

<br>

**参数:**
```
a: 显示所有已打开的端口
n: 不用别名显示 只用数字显示
p: 显示进程号(pid)和进程名
t: 显示所有tcp协议端口 
u: 显示所有udp协议端口
```

<br>

**注意:**
一般需要root用户权限 才能看到更详细的端口信息 否则 pid 一栏没有信息  
端口号会在 Local Address 这一列展示出来

Local Address 是本机(基于服务器角度的话就是服务器)  
Foreign Address 是外来(是别的ip连接服务器)  

黑客就是根据 Foreign Address 反向追踪看看谁连接的服务器

<br>

### **查看系统中正在使用端口的详细信息:**
有的系统可能没有这个指令
```js
// 它会将当前系统打开的所有程序罗列出来
lsof
```

**注意:**
一般需要root权限 才能看到详细的端口信息

<br>

**参数:**
**-i:**
可以查看哪个端口被占用
```js
// 列出符合条件的进程 如果不给出条件则默认显示所有进程打开的所有文件
lsof -i

// 列出使用端口3306的进程信息 这里查看3306这个端口被哪个应用程序占用了 
lsof -i:3306
```

<br>

**技巧:**  
linux系统中安装软件时 会出现因为端口占用而无法安装的情况 这个时候就需要我们用 lsof -i 命令查看安装软件要使用的端口是否被占用


<br><br>

# 查看程序位置
在服务器的情况下 我们的程序是以进程的形式存在的 不是windows系统下那种图形化图标的形式存在

比如 我们在服务器上装了一个程序 因为没有图标 时间长了 我们就不知道它所在的位置了 所有需要这个命令

### **查看 程序 的位置:**
```
which 程序名

which mysql

/usr/bin/mysql
```

<br><br>

# 用户切换
比如当我们执行一些操作的时候 会提示当前用户的权限不足 我们需要进行用户切换 切换到root用户

### **切换账号:**
centos下切换到root的简单命令  
使用su切换用户 当前路径不会发生变化 比如我们是在 /home/admin 下切换的用户 换成root后 还是在 /home/admin
```
su
```

<br>

### **切换到 root 用户:**
使用它切换后 路径为 /root
```
su -
```

<br>

### **切换到指定的用户 并切换目录:**
可以切换到用户家目录 否则位置保持不变, 要将 - 和 用户之间使用空格隔开 还有人说不用加 -
```
su - 用户名
```
 


### **授权允许:**
在实际应用中 一般都是通过 sudo 进行授权允许 只需输入当前账户密码即可 安全性比su更好一些
```
sudo
```

<br><br>

# 查看用户信息

### **查看当前的用户是谁:**
```
whoami
```

<br>

### **显示目前登录系统的用户信息:**
```
who [选项] [参数]

who
```

**注意:**  
who命令是显示目前登录系统的用户信息 执行who命令可得知目前有哪些用户登入系统 单独执行who命令会列出登入账号 使用的终端机 登入时间以及从何处登入或正在使用哪个x显示器


**选项:**  
**q或count:**  
只显示登入系统的账号名称和总人数

**w:**  
显示用户的信息状态栏

<br><br>

# 退出终端
```
exit
```
如果是图形界面 退出当前终端  
如果是使用 ssh 远程登录 退出登录账户  
如果是切换后的登录用户 退出则返回上一个登录账号

<br><br>

# 连接文件(软连接)
跟windows下的快捷方式一样 我们会在一个存放文件比较深 想快速进行调用 我们可以创建快捷方式放在桌面上进行调用

Linux叫做连接文件 分为两种  
1. 软链接: 快捷方式
2. 硬链接: 

<br>

### **软链接:**
ldemo文件指向了demo 如果对连接文件进行操作 源文件会发生变化 反过来也一样
```
ln -s 目标文件名 链接文件名

ln -s demo ldemo
```

<br>

### **硬链接:**
运维需要掌握的东西
https://www.bilibili.com/video/BV1bg411V7pp?p=133&spm_id_from=pageDriver&vd_source=66d9d28ceb1490c7b37726323336322b
 
<br><br>

# Linux 打包压缩 和 解压解包
跟 window 的压缩和解压不同 Linux下多了一个打包的动作  
要想对一个文件进行压缩 它的前置步骤为 打包 先将文件装起来 然后进行压缩

*一般会在部署的时候 将文件上传到服务器 要把文件从包里面拿出来*

### **打包 和 压缩:**  
它是日常工作中备份文件的一种方式 在不同操作系统中 常用的打包压缩方式是不同的

windows: 常用 rar  
Mac: 常用 zip  
Linux: 常用 tar.gz  

<br>

### **打包 / 解包:**
*tar* 是Linux中最常用的备份工具 此命令*可以把一系列文件 打包到 一个大文件中* 也可以把打包的文件恢复成一系列文件

### **打包文件:**
将多个文件打包到 .tar 文件中
```
tar -cvf 包名.tar 被打包的文件/路径
```

<br>

### **解包文件:**
```
tar -xvf 打包文件.tar
```

**参数:**
**-c:**   
生成档案文件 创建打包文件 (*打包的话主要靠c*)

**-v:**   
列出归档解档的详细过程 *显示打包或解包的进度*

**-f:**   
指定档案文件名称 f后面一定是.tar文件 所以必须放选项最后

**-t:**   
列出档案中包含的文件 

**-x:**   
解开档案文件(*解包的话主要靠x*)

**注意:f选项必须放在最后 其他的参数顺序任意**

<br><br>

# **压缩 / 解压缩:**
我们更关注这个部分

### **gzip:**
tar 和 gzip 命令结合使用实现文件 打包 压缩

tar 只负责打包文件 但不压缩  
gzip 压缩 tar 打包后的文件 其扩展名一般用 xxx.tar.gz


### **打包并压缩文件:**
```
tar -zcvf 包名.tar.gz 被压缩的文件/路径
```

<br>

### **解压缩文件:**
```
tar -zxvf 包名.tar.gz
```

<br>

### **解压缩到指定路径:**
```
tar -zxvf 包名.tar.gz -C 目标路径
```

<br>

### **示例:**
```js
// 创建两个文件夹
mkdir atdir btdir

// 在 atdir 下创建aa bb cc三个文件
touch aa bb cc

// 打包压缩 atdir
// 我们要返回到atdir的父目录 这样在对它进行压缩
tar -zcvf atdir.tar.gz atdir/

// 解压
tar -zxvf atdir.tar.gz -C btdir
```

<br><br>

# **zip unzip:**
通过 zip 压缩文件的目标文件不需要指定扩展名 默认扩展名为zip


### **压缩文件:**
```
zip [-r] 包名 被压缩的文件
```

<br>

### **解压缩文件:**
```
unzip -d 解压后的目录 包名.zip
```

<br>

### **就地解压:**
```
unzip 包名.zip
```

**参数: -r**  
递归处理 将指定目录下所有文件和子目录一并处理

<br><br>

# Linux软件安装
yum 是一个在linux系统中常用的软件包管理器  
yum 提供了查找 安装 删除某一个 一组甚至全部软件包的命令

比如往虚拟机里面安装软件  

```
yum [options] [command] [package ...]
```

**optiosn:**  
**-h:** 查看帮助  
**-y:** 当安装过程提示选择全部为 yes  
**-q:** 不显示安装的过程  

**command:**  
要进行的操作

**package:**   
操作的对象

<br>

### **yum常用命令:**

**列出所有可安装的软件清单**
```
yum list
```
  
**查找软件包**
```
yum search
```

**安装指定软件**
```
yum install <package_name>
```

**更新指定的软件**
```
yum update <package_name>
```

**更新所有软件**
```
yum update
```

**删除软件包**  
```
yum remove <package_name>
```


<br>

### **虚拟机软件 和 虚拟机系统 之间的关系:**
虚拟机是模拟一个服务器 本地自己用  
虚拟机软件里面装什么系统 就是什么系统

<br>

### 环境变量相关:

**profile（/etc/profile）:**  
用于设置系统级的环境变量和启动程序，在这个文件下配置会对所有用户生效。

当用户登录（login）时，文件会被执行，并从/etc/profile.d目录的配置文件中查找shell设置。

**注意:**  
一般不建议在/etc/profile文件中添加环境变量，因为在这个文件中添加的设置会对所有用户起作用。

<br>

**bash_profile:**  
只有单一用户有效，文件存储位于~/.bash_profile，该文件是一个用户级的设置，可以理解为某一个用户的profile目录下。这个文件同样也可以用于配置环境变量和启动程序，但只针对单个用户有效。

和profile文件类似，bash_profile也会在用户登录（login）时生效，也可以用于设置环境变理。但与profile不同，**bash_profile只会对当前用户生效**