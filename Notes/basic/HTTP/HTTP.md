# Get 和 Post 的区别
最直观的区别就是: 

- GET把参数包含在URL中
- POST通过request body传递参数

<br>

**以往的认知是 get 和 post 之前请求是有区别的 比如:**
- GET在浏览器回退(刷新)时是无害的, 而POST会再次提交请求。
- GET产生的URL地址可以被Bookmark(书签), 而POST不可以。
- GET请求会被浏览器主动cache, 而POST不会, 除非手动设置。
- GET请求只能进行url编码, 而POST支持多种编码方式
- GET请求参数会被完整保留在浏览器历史记录里, 而POST中的参数不会被保留。
- GET请求在URL中传送的参数是有长度限制的2048个字符, 而POST么有。 

<br>

**对参数的数据类型:**  
GET只接受ASCII字符, 而POST没有限制

GET比POST更不安全, 因为参数直接暴露在URL上, 所以不能用来传递敏感信息。

GET参数通过URL传递, POST放在Request body中。

<br>

但是实际上 Get 和 Post 本质上是没有区别的, 它们都是http协议中的两种发送请求的方法

http是基于tcp/ip协议的 所以get post的底层也是 tcp/ip协议 也就是说 get post都是tcp链接

get和post能做的事情是一样的 比如我们想给get请求加上request body 给post请求带上url参数 技术上是完全行的通的

在万维网的世界上 tcp就像汽车 我们用tcp来运输数据 它很可靠 从来不会发生丢件少件的现象

但是如果路上跑的全是看起来一模一样的汽车, 那这个世界看起来是一团混乱, 送急件的汽车可能被前面满载货物的汽车拦堵在路上, 整个交通系统一定会瘫痪。

为了避免这种情况发生, 交通规则HTTP诞生了。HTTP给汽车运输设定了好几个服务类别, 有GET, POST, PUT, DELETE等等

<br>

**HTTP规定:** 
当执行GET请求的时候, 要给汽车贴上GET的标签(设置method为GET), 而且要求把传送的数据放在车顶上(url中)以方便记录。

如果是POST请求, 就要在车上贴上POST的标签, 并把货物放在车厢里。

当然, 你也可以在GET的时候往车厢内偷偷藏点货物, 但是这是很不光彩; 也可以在POST的时候在车顶上也放一些数据, 让人觉得傻乎乎的。HTTP只是个行为准则, 而TCP才是GET和POST怎么实现的基本。

但是, 我们只看到HTTP对GET和POST参数的传送渠道(url还是requrest body)提出了要求。"标准答案"里关于参数大小的限制又是从哪来的呢？

在我大万维网世界中, 还有另一个重要的角色: 运输公司。不同的浏览器(发起http请求)和服务器(接受http请求)就是不同的运输公司。虽然理论上, 你可以在车顶上无限的堆货物(url中无限加参数)。

但是运输公司可不傻, 装货和卸货也是有很大成本的, 他们会限制单次运输量来控制风险, 数据量太大对浏览器和服务器都是很大负担。业界不成文的规定是, (大多数)**浏览器通常都会限制url长度在2K个字节**, **而(大多数)服务器最多处理64K大小的url。**

超过的部分, 恕不处理。如果你用GET服务, 在request body偷偷藏了数据, 不同服务器的处理方式也是不同的, 有些服务器会帮你卸货, 读出数据, 有些服务器直接忽略, 所以, 虽然GET可以带request body, 也不能保证一定能被接收到哦。

<br>

### GET和POST还有一个重大区别, 简单的说: 
对于GET方式的请求, 浏览器会把http header和data一并发送出去, 服务器响应200(返回数据); 

而对于POST, 浏览器先发送header, 服务器响应100 continue, 浏览器再发送data, 服务器响应200 ok(返回数据)。

也就是说, **GET只需要汽车跑一趟就把货送到了**

而POST得跑两趟, 第一趟, 先去和服务器打个招呼"嗨, 我等下要送一批货来, 你们打开门迎接我", 然后再回头把货送过去。

因为POST需要两步, 时间上消耗的要多一点, 看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？

<br>

1. GET与POST都有自己的语义, 不能随便混用。
2. 据研究, 在网络环境好的情况下, 发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下, 两次包的TCP在验证数据包完整性上, 有非常大的优点
3. 并不是所有浏览器都会在POST中发送两次包, Firefox就只发送一次。

<br>

### Get请求怎么携带请求体参数
**http协议是支持get请求可以携带请求体**的 后端也可以接收请求体参数

有些后台服务器不支持 使用 get携带请求体参数 的方式

<br>

**但是浏览器会限制get请求不携带请求体**

也就是说要是想通过 浏览器发送 get请求的时候 携带 body参数 那么需要后台下载相关的依赖

比如java中是使用了 **httpclient** 依赖

<br>

后台使用 axios 发送 get请求的时候 携带body参数是可以接收到的, 后台发送请求是不用通过浏览器的

```js 
// server1
app.get("/test", (req, res) => {
  let data = {
    name: "sam",
    age: 18
  }
  
  axios({
    url: "http://localhost:3001/test",
    method: "get",
    data
  })
})


// server2
app.get("/test", (req, res) => {
  console.log(req.body)
})
```

<br>

## Get 请求时 url 参数长度限制
http中 get请求提交的数据大小长度并没有限制 同时 http规范没有对url长度进行限制

目前说得 get 长度有限制 是特定的浏览器 以及 服务器对它的限制 各种浏览器 和 服务器的最大处理能力如下

<br>

### 浏览器的限制
**IE:**  
IE浏览器(Microsoft Internet Explorer) 对url长度限制是2083(2K+53), 超过这个限制, 则自动截断(若是form提交则提交按钮不起作用)。

<br>

**firefox:**  
firefox(火狐浏览器)的url长度限制为 65 536字符, 但实际上有效的URL最大长度不少于100,000个字符。

<br>

**chrome:**  
chrome(谷歌)的url长度限制超过8182个字符返回本文开头时列出的错误。

<br>

**Safari:**  
Safari的url长度限制至少为 80 000 字符。

<br>

**Opera:**  
Opera 浏览器的url长度限制为190 000 字符。Opera 9 地址栏中输入190 000字符时依然能正常编辑。

<br>

### 服务器
**Apache:**  
Apache能接受url长度限制为8 192 字符

<br>

**IIS:**  
Microsoft Internet Information Server(IIS)能接受url长度限制为16 384个字符。
这个是可以通过修改的(IIS7)configuration/system.webServer/security/requestFiltering/requestLimits@maxQueryStringsetting.

<br>

**Perl HTTP::Daemon:**  
Perl HTTP::Daemon 至少可以接受url长度限制为8000字符。Perl HTTP::Daemon中限制HTTP request headers的总长度不超过16 384字节(不包括post,file uploads等)。但当url超过8000字符时会返回413错误。
这个限制可以被修改, 在Daemon.pm查找16×1024并更改成更大的值。

<br>

**ngnix:**  
可以通过修改配置来改变url请求串的url长度限制。
- client_header_buffer_size 默认值: client_header_buffer_size 1k

- large_client_header_buffers默认值 : large_client_header_buffers 4 4k/8k

<br><br>

# Http协议
协议是指双方或多方相互约定 大家都需要遵守的**规则**叫协议

在我理解就是, 协议是两方及其两方以上共同约定的一种规则, 所以这里协议就是指网络中 **各方都遵守的一种协议, 只有规则相同时, 相互才能理解对方所说的话**

<br>

### http协议:
HyperText Transfer Protocol 的缩写, HyperText: 超文本, Transfer: 传输

Http协议是基于Tcp的应用层协议 它不关心数据传输的细节 主要是用来 **规定客户端和服务器的数据传输格式**

<br>

### HTTP的特点:
HTTP 使用的是可靠的数据传输协议, 因此即使数据来自地球的另一端, 它也能够确保数据在传输的过程中不会被损坏或产生混乱

Web 浏览器、服务器和相关的Web 应用程序都是通过HTTP 相互通信的

支持客户端 服务器模式
- 简单快速
- 灵活(支持各种各样的类型)
- 无连接
- 无状态

<br>

###  HTTP协议用于客户端和服务器端之间的通信
就是指客户端和服务器之间通信时 发送的数据 需要遵守的规则叫做http协议

通过请求和响应的交换进行通信(HTTP是不保存状态的协议)
http协议中发送的数据又叫做报文, 通过http发送的

**数据 == 报文**

<br><br>

# Web客户端和服务器
Web 内容都是存储在Web 服务器上的。Web 服务器所使用的是HTTP 协议, 因此经常会被称为HTTP 服务器。

HTTP客户端发送http请求 HTTP服务端会在http响应中会送所请求的数据

- 客户端(浏览器) 发送http请求
- 服务器 会在http响应中 返送所请求的数据

<br>

### 资源
最简单的Web 资源就是Web 服务器文件系统中的静态文件。这些文件可以包含任意内容
但资源不一定非得是静态文件。资源还可以是根据需要生成内容的软件程序。(比如servlet也是一种资源)

<br>

### 媒体类型
因特网上有数千种不同的数据类型, HTTP 仔细地给每种要通过Web 传输的对象都打上了名为MIME 类型(MIME type) 的数据格式标签。

<br>

### MIME 类型
MIME是HTTP协议中数据类型

**主要的对象类型/特定的子类型**   
**大类型/小类型**

中间由一条斜杠来分隔, 比如:
- 主要类型是文本 / 什么类型的文本
- 主要类型是图片 / 什么格式的图片

并与某一种文件的扩展名相对应

<br>

**示例:**
- text/html: HTML 格式的文本文档
- text/plain: 普通的 ASCII 文本文档
- image/jpeg: JPEG 格式的图片
- image/gif: GIF 格式的图片
- video/quicktime: Apple 的 QuickTime 电影
- application/vnd.ms-powerpoint: 微软的 PowerPoint 演示文件


<br>

### 常见的MIME类型

|文件|MIME类型|后缀|
|:--|:--|:--|
|超文本标记语言文本|text/html|.html|
|普通文本|text/plan|.txt|
|RTF文本|application/rtf|.rtf|
|GIF图形|image/gif|.gif|
|JPEG图形|image/jpeg|.jpeg|
|GZIP文件|application/x-gzip|.gz|
|TAR文件|application/x-tar|.tar|
|au声音文件|audio/basic|.au|
|MIDI音乐文件|audio/mid|.mid|
|realAuto音乐文件|audio/x-pn-realAuto|.ra, .ram|
|MPEG文件|video/mpeg|.mpg, .mpeg|
|AVI文件|video/x-msvidwo|.avi|

<br><br>

# 与HTTP关系密切的协议

### IP协议: Internet Proctor
负责传输的协议

IP协议位于网络层几乎所有的网络系统都会使用到IP协议, IP地址与IP协议是不同的

传输过程中需要两个重要条件
- 一个是IP地址: IP地址指明了节点被分配到的地址
- 一个为MAC地址: MAC地址是指网卡所属的固定地址

<br>

IP地址和MAC地址可以相互匹配, IP地址可以改变, 但MAC地址一般保持不变

IP间的通信依赖于MAC地址。在网络上, 一般传输时, 双方不处于同一局域网内, 所以这时我们需要经过多台计算机转发才可以达到对方, 

而在中转时会利用下一站中转设备的MAC地址来搜索下一个中转目标, 这时, 会采用ARP协议(Address Resolution Protocol), ARP是一个地址解析协议, 根据通信方的IP地址就可以反查出对应的MAC地址

因为网络世界很大, 我们无法全部掌握, 所以在传输中不能准确的选择发送到目标, 所以我们采用路由选择机制, 这种机制和快递很像: 比如从西安发往哈尔滨

1. 首先你将快递送到本区的集散点, 才能确定是否可以发送至哈尔滨

2. 然后快递公司收取, 送至下个目标点西安总公司, 查看目标地点, 发现是哈尔滨的

3. 然后发往下个目标点黑龙江省总公司, 因为哈尔滨是省会, 所以相当于发往哈尔滨的总公司

4. 继续查找下个目标地点, 为哈尔滨某个区, 发往此处, 到达目标点

<br>

### TCP协议
确保可靠性的协议

为了能够无误地将数据送达到目标, TCP协议采用了三次握手策略。用TCP协议把数据包发送出去后, TCP不会对传递后的情况置之不理, 而是等待向对方确认是否成功发送。在此过程中使用了TCP的标志(flag)-SYN(synchronize)和ACK(acknowledgment)

HTTP 是个应用层协议。HTTP 无需操心网络通信的具体细节; 它把联网的细节都交给了通用、可靠的因特网传输协议TCP/IP。

因特网自身就是基于TCP/IP 的, TCP/IP 是全世界的计算机和网络设备常用的层次化分组交换网络协议集。
  
TCP/IP 隐藏了各种网络和硬件的特点及弱点, 使各种类型的计算机和网络都能够进行可靠地通信。


**TCP 提供了:**  
1. 无差错的数据传输; 
2. 按序传输(数据总是会按照发送的顺序到达); 
3. 未分段的数据流(可以在任意时刻以任意尺寸将数据发送出去)

<br>

### TCP协议的特点:
只要建立了TCP 连接, 客户端和服务器之间的报文交换就不会丢失、不会被破坏, 也不会在接收时出现错序了。

``` 
HTTP  应用层
TCP   传输层
IP    网络层

链路    链路层
硬件    物理层
```


### 连接、IP地址及端口号
在HTTP 客户端向服务器发送报文之前, 需要用网络协议地址和端口号在客户端和服务器之间建立一条TCP/IP 连接。

**建立一条 TCP 连接的过程:**
1. 需要知道服务器的IP 地址
2. 与服务器上运行的特定软件相关的TCP 端口号。

<br>

**怎么获得HTTP 服务器的IP 地址和端口号呢？**  
通过URL!

``` 
http://207.200.83.29:80/index.html
http://www.netscape.com:80/index.html
```

第一个URL 使用了机器的IP 地址, 207.200.83.29 以及端口号80。

第二个URL 没有使用数字形式的IP 地址, 它使用的是文本形式的域名, 或者称为主机名

主机名(www.netscape.com)。主机名就是IP 地址比较人性化的别称。默认端口号是80



- 浏览器从URL 中解析出服务器的主机名; 
- 浏览器将服务器的主机名转换成服务器的IP 地址; 
- 浏览器将端口号(如果有的话)从URL 中解析出来; 
- 浏览器建立一条与Web 服务器的TCP 连接; 
- 浏览器向服务器发送一条HTTP 请求报文; 
- 服务器向浏览器回送一条HTTP 响应报文; 
- 关闭连接, 浏览器显示文档。

<br>

### DNS服务
和HTTP服务一样位于应用层, 提供域名到IP地址之间的解析服务

<br><br>

## URI 和 URL

- URI: 统一资源标识符
- URL: 统一资源定位符

<br>

### URI
规定统一的格式可方便的处理多种不同类型的资源, 而不用根据上下文环境来识别资源指定的访问方式。

资源的定义是"可标识的任何东西"。除了文档文件、图像或服务(例如当天的天气预报)等能够区别于其他类型的, 全都可作为资源。另外, 资源不仅可以是单一的, 也可以是多数的集合体

表示可标识的对象。也称作标识符。

每个Web 服务器资源都有一个名字, 这样客户端就可以说明它们感兴趣的资源是什么了。

URI 就像因特网上的邮政地址一样, 在世界范围内唯一标识并定位信息资源。

http://www.joes-hardware.com/specials/saw-blade.gif
  
访问Joe 商店服务器上的图片资源的

<br>

**URI 有两种形式**
1. URL
2. URN

<br>

### 编码机制
为了避开安全字符集表示法带来的限制, 人们设计了一种编码机制, **用来在 URL 中表示各种不安全的字符。**

这种编码机制就是**通过一种"转义"表示法来表示不安全字符的**

这种转义表示法包含一个百分号(%), 后面跟着两个表示字符ASCII 码的十六进制数。

**%16进制数*2**

<br><br>

### URL: 精准定位到资源
**统一资源定位符**

是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示, 是互联网上**标准资源**的地址。

互联网上的每个文件都有一个唯一的URL, 它包含的信息指出文件的位置以及浏览器应该怎么处理它 是资源标识符最常见的形式

URL 描述了一台特定服务器上某资源的特定位置。
是浏览器寻找信息时所需的资源位置。通过URL, 人类和应用程序才能找到、使用并共享因特网上大量的数据资源。

<br>

### 格式:
```s
http://user:pass@www.example.com:80/dir/index.html?uid=1#hash2
```

**http://:**  
协议类型, 除了http以外有ftp,mailto,news,tel,telnet,urn等等, 这里只列出常见的, 也可以使用data:或javascript:这类指定数据或脚本程序的方案名, 必选项

<br>

**user:pass@:**  
位置在 *http://后 + 这里 + 域名前*  
登录信息(认证), 指定用户名和密码作为从服务器端获取资源时必要的登录信息, 现在不常用, 可选项

很多服务器都要求输入用户名和密码才会允许用户访问数据
``` 
ftp://ftp.prep.ai.mit.edu/pub/gnu
ftp://anonymous@ftp.prep.ai.mit.edu/pub/gnu
ftp://anonymous:my_passwd@ftp.prep.ai.mit.edu/pub/gnu
http://joe:joespasswd@www.joes-hardware.com/sales_info.txt
```

<br>

**www.example.com:**   
域名(ip), 也可以使用IP地址, 必选项

<br>

**80:**     
端口号, 不输入时, 默认端口号, 可选项 0-65535

<br>

**dir/index.html:**  
*资源路径*  
带层次的文件路径, 标识网络资源(文件 图片 音视频 变量)

<br>

**?uid=1:**   
查询字符串(查询参数), 可选

key=value, 这些kv是传递给资源路径对应的数据(资源可以是函数 servlet)

<br>

**#hash2:**   
片段标识符, hash值, 可做锚点, 可做前段路由, 可选

<br>

### URN(统一资源名)
URN 是作为特定内容的唯一名称使用的, 与目前的资源所在地无关使用这些与位置无关的URN, 就可以将资源四处搬移。

<br>

### 事务 = 请求 + 响应
一个HTTP 事务由一条(从客户端发往服务器的)请求命令和一个(从服务器发回客户端的)响应结果组成。这种通信是通过名为HTTP 报文

<br>

### 方法
HTTP 支持几种不同的请求命令, 这些命令被称为HTTP 方法

每条HTTP请求报文都包含一个方法 这个方法会告诉服务器要执行什么动作(获取一个Web 页面、运行一个网关程序、删除一个文件等)

- GET: 从服务器向客户端发送命名资源
- PUT: 将来自客户端的数据存储到一个命名的服务器资源中去
- DELETE: 从服务器中删除命名资源
- POST: 将客户端数据发送到一个服务器网关应用程序
- HEAD: 仅发送命名资源响应中的 HTTP 首部

<br>

### 状态码
**每条 HTTP 响应报文返回时都会携带一个状态码。**

状态码是一个三位数字的代码, 告知客户端请求是否成功, 或者是否需要采取其他动作

- 200 OK 文档正确返回
- 302 Redirect(重定向)。到其他地方去获取资源
- 404 Not Found(没找到)。无法找到这个资源

<br>

### 代理
位于 客户端 和 服务器 之间的HTTP 中间实体。

这是Web 安全、应用集成以及性能优化的重要组成模块。
代理位于客户端和服务器之间, 接收所有客户端的HTTP 请求, 并将这些请求转发给服务器(可能会对请求进行修改之后转发)

代理还可以对请求和响应进行过滤

比如, 在企业中对下载的应用程序进行病毒检测, 或者对小学生屏蔽一些成人才能看的内容。

<br>

### 缓存
HTTP的仓库, 使常用页面的副本可以保存在离客户端更近的地方。

Web缓存(Web cache)或代理缓存(proxy cache)是一种特殊的HTTP 代理服务器

也就是说缓存也是服务器？

可以将经过代理传送的常用文档复制保存起来 下一个请求同一文档的客户端就可以享受缓存的私有副本所提供的服务了

<br>

### 网关
连接其他应用程序的特殊Web 服务器。通常用于将HTTP 流量**转换成其他的协议**

网关接受请求时就好像自己是资源的源端服务器一样。客户端可能并不知道自己正在与一个网关进行通信。

<br>

### 隧道
对HTTP 通信报文进行盲转发的特殊代理。
建立起来之后, 就会在两条连接之间对原始数据进行盲转发的HTTP 应用程序

HTTP 隧道通常用来在一条或多条HTTP 连接上转发非HTTP 数据, 转发时不会窥探数据。

<br>

### Agent代理
发起自动HTTP 请求的半智能Web 客户端。
用户Agent 代理 是代表用户发起HTTP 请求的客户端程序

所有发布Web 请求的应用程序都是HTTP Agent 代理。到目前为止, 我们只提到过一种HTTP Agent 代理: Web 浏览器

<br><br>

# HTTP请求协议
客户端(app 浏览器) 发送请求给服务器时 使用的协议 --- http请求协议

规定发送给服务器的数据传输的语法格式

<br>

### 格式:

- 客户端 给 服务器 发送数据叫请求
- 服务器 给 客户端 回传数据叫响应

上述的过程都需要遵守协议

<br>

### 报文:
HTTP报文本身是由多行数据构成的字符串文本, HTTP报文大致可分为

- 报文首部
- 空行
- 报文主体
  
两块, 最初是由空行来划分, 通常, 不一定需要报文主体

<br>

### 请求头 响应头 的格式: k: v

<br>

### 请求报文结构: 
1. 报文首部
  - 请求行: 包含用户请求的方法, 请求URI和HTTP版本
  - 请求首部字段
  - 通用首部字段
  - 实体首部字段
  - 其他

2. 空行(CR + LF) 代表请求头部分结束
3. 报文主体

<br>

### 响应报文结构: 
1. 报文首部
  - 状态行: 包含表明响应结果的状态码, 原因短语和HTTP版本
  - 响应首部字段
  - 通用首部字段
  - 实体首部字段
  - 其他

2. 空行(CR + LF)
3. 报文主体

<br>

## 首部字段
包含请求和响应的各种条件和属性的各类首部 一般有4种首部

- 通用首部
- 请求首部
- 响应首部
- 实体首部

<br>

### 报文和实体差异

**报文(message):**   
是HTTP通信中的基本单位, 由**8位组字节流**(octet sequence, 其中octet为**8个比特**)组成, 通过HTTP通信传输。

<br>

**实体(entity):**   
**作为请求或响应的有效载荷数据(补充项)被传输**, 其内容由实体首部和实体主体组成。

**实体 == 数据容器 = 实体首部 + 实体主体**

<br>

HTTP报文的主体用于传输 请求 或 响应 的实体主体。

**通常, 报文主体等于实体主体**, 只有当传输中进行编码操作时, 实体主体的内容发生变化, 才导致它和报文主体产生差异。

实体(请求体 响应体) 部分是受 Content-Type 的值 影响的


**GET DELETE 是没有请求体的**

<br>

### 请求行信息
GET /index.html HTTP/1.1

<br>

### 请求方法 (大小写无所谓): 
**GET:**  
请求获取服务器资源, 返回报文主体

<br>

**POST:**  
向指定资源提交数据进行处理请求(例如提交表单或者上传件) 数据被包含在请求体中。

POST请求可能会导致新的资源的建立和/或已有资源的修改。
提交资源

<br>

**PUT:**  
从客户端向服务器传送的数据取代指定的文档的内容。

<br>

**DELETE:**  
请求服务器删除指定的页面。删除资源

<br>

**HEAD:**  
获取响应头

用于确认URI的有效性及资源更新的日期时间等, 和GET一样, **只不过不返回主体**

<br>

**CONNECT:**    
HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。要求使用隧道协议连接代理

<br>

**OPTIONS:**  
允许客户端查看服务器的性能, 询问支持的方法

<br>

**TRACE:**  
回显服务器收到的请求, 主要用于测试或诊断。追踪路径
回显服务器收到的请求 用于测试或诊断

一般 DELETE, PUT直接被禁用, 毕竟在HTTP/1.1中没有验证机制, 所以为了服务器的安全, 一般会禁止使用这两种方法

<br>

### 响应状态码
HTTP状态码负责表示客户端HTTP请求的返回结果、标记服务器端的处理是否正常、通知出现的错误等工作。当然可以自定义状态码

HTTP 状态码被分成了五大类。状态码为客户端提供了一种理解事务处理结果的便捷方式。

<br>

### 状态码分类
- 100 ～ 199  100 ～ 101 信息提示
- 200 ～ 299  200 ～ 206 成功
- 300 ～ 399  300 ～ 305 重定向
- 400 ～ 499  400 ～ 415 客户端错误
- 500 ～ 599  500 ～ 505 服务器错误

<br>

### 100 ~ 199 信息性状态码
HTTP/1.1 向协议中引入了信息性状态码。
中间状态 一般不会太多的关注

<br>

### 200 ~ 299 成功的状态码
客户端发起请求时, 这些请求通常都是成功的。

<br>

### 300 ~ 399 重定向状态码
重定向状态码要么告知客户端使用替代位置来访问他们所感兴趣的资源, 要么就提供一个替代的响应而不是资源的内容。

如果资源已被移动, *可发送一个重定向状态码和一个可选的Location 首部来告知客户端资源已被移走*, 以及现在可以在哪里找到它

浏览器就可以在不打扰使用者的情况下, 透明地转入新的位置了。

<br>

### 400 ~ 499 客户端错误状态码
有时客户端会发送一些服务器无法处理的东西
比如格式错误的请求报文, 或者最常见的是, 请求一个不存在的URL。

浏览网页时, 我们都看到过臭名昭著的404 Not Found 错误码——这只是服务器在告诉我们, 它对我们请求的资源一无所知。

<br>

### 500 ~ 599 服务器错误状态码
有时客户端发送了一条有效请求, 服务器自身却出错了。这可能是客户端碰上了服务器的缺陷, 或者服务器上的子元素, 比如某个网关资源, 出了错

代理尝试着代表客户端与服务器进行交流时, 经常会出现问题。

<br>

### 要点:
我们点击登录按钮 进行登录 密码错误的情况下 http 响应仍然是200 200 OK 是说请求成功接受并处理了 并不表示登录成功失败 200并不表示具体的业务 只是针对请求是否处理完了

<br><br>

## 状态码详解:

### 1XX: Informational(信息性状态码)
指示信息 表示请求已接收 需要继续处理 等待客户端重新再次发送请求

<br>

### 2XX: Success(成功状态码)
请求成功被接受 或 处理 常见的200 201

<br>

### 3XX: Redirection(重定向状态码)
要完成请求必须进行更进一步的操作

<br>

### 4XX: Client Error(客户端错误状态码)	
客户端错误, 请求语法错误 或者 请求无法实现 服务器无法处理请求

<br>

### 5XX: Server Error(服务端错误状态码)	
服务器处理请求出错

<br>

### 100 Continue
客户端应当继续发送请求

说明收到了请求的初始部分, 请客户端继续。*发送了这个状态码之后, 服务器在收到请求之后必须进行响应。*

<br>

### 101 Switching Protocols
服务器已经理解了客户端的请求, 并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求

说明服务器正在根据客户端的指定, 将协议切换成Upgrade 首部所列的协议

<br>

### 102 Processing
由WebDAV(RFC 2518)扩展的状态码, 代表处理将被继续执行

<br>

### 200 OK
从客户端发来的请求在服务端正常处理
请求没问题, 实体的主体部分包含了所请求的资源

<br>

### 201 Created
用于创建服务器对象的请求(比如, PUT)。

响应的实体主体部分中应该包含各种引用了已创建的资源的URL, Location 首部包含的则是最具体的引用。

**服务器必须在发送这个状态码之前创建好对象**

<br>

### 202 Accepted
请求已被接受, 但服务器还未对其执行任何动作。

不能保证服务器会完成这个请求; 这只是意味着接受请求时, 它看起来是有效的。

服务器应该在实体的主体部分包含对请求状态的描述, 或许还应该有对请求完成时间的估计(或者包含一个指针, 指向可以获取此信息的位置)

<br>

### 203 Non-Author i tat iveInformation
实体首部

包含的信息不是来自于源端服务器, 而是来自资源的一份副本。如果中间节点上有一份资源副本, 但无法或者没有对它所发送的与资源有关的元信息(首部)进行验证, 就会出现这种情况。

这种响应码并不是非用不可的; 如果实体首部来自源端服务器, 响应200 状态的应用程序就可以将其作为一种可选项使用

<br>

### 204 No Content
服务端接收的请求已成功处理, 但在返回的响应报文中不含实体的主体部分, 另外也不允许返回任何实体的主体

主要用于在浏览器不转为显示新文档的情况下, 对其进行更新(比如刷新一个表单页面)

<br>

### 205 Reset Content
另一个主要用于浏览器的代码。负责告知浏览器清除当前页面中的所有HTML 表单元素

<br>

### 206 Partial Content
客户端进行了范围请求, 而服务器成功执行了这部分请求, 响应报文中包含由Content—Range 指定的范围的实体内容

**206 响应中必须包含:**
- Content-Range
- Date
- ETag 或 Content-Location 首部

<br>

### 300 Multiple Choices
客户端请求一个实际指向多个资源的URL 时会返回这个状态码
比如服务器上有某个HTML 文档的英语和法语版本。返回这个代码时会带有一个选项列表; 这样用户就可以选择他希望使用的那一项了。有多个版本可用时, 客户端需要沟通解决

<br>

### 301 Moved Permanently	
永久性重定向

在请求的URL 已被移除时使用。*响应的Location* 首部中应该包含资源现在所处的URL

<br>

### 302 Found
临时性重定向

与301 状态码类似; 但是, 客户端应该使用Location 首部给出的URL 来临时定位资源。将来的请求仍应使用老的URL

<br>

### 303 See Other
由于对应的资源存在着另一个uri, 应使用GET方法定向获取请求的资源
告知客户端应该用另一个URL 来获取资源。
新的URL 位于响应报文的Location 首部。其主要目的是允许POST 请求的响应将客户端定向到某个资源上去

<br>

### 304 Not Modified
客户端发送附带条件的请求, 也就是资源找到了, 但是没有符合条件请求

如果客户端发起了一个条件GET请求, 而最近资源未被修改的话, 就可以用这个状态码来说明资源未被修改。

带有这个状态码的响应不应该包含实体的主体部分

意味着 请求回来的东西 是没有变化的不用重新去服务器请求 文档已经缓存到本地 走本地缓存

通过请求头的信息 浏览器发现你请求的内容 和 本地的内容是一模一样的 就不需要服务器再发回来给我们了

<br>

这时候我们再查看 响应体 会发现什么也m没有

**304: 比如请求到了服务器 服务器说去找本地缓存去 服务器不会返回任何内容**

<br>

### 305 Use Proxy
用来说明必须通过一个代理来访问资源

代理的位置由Location首部给出。很重要的一点是, 客户端是相对某个特定资源来解析这条响应的, 不能假定所有请求, 甚至所有对持有所请求资源的服务器的请求都通过这个代理进行。如果客户端错误地让代理介入了某条请求, 可能会引发破坏性的行为, 而且会造成安全漏洞

<br>

### 307 Tempoeary Redirect
临时重定向, 和302很相似, 但是会根据游览器不同导致出现不同问题

与301 状态码类似; 但客户端应该使用Location 首部给出的URL来临时定位资源。将来的请求应该使用老的URL

**注意:**  
当301、302、303响应状态码返回时, 几乎所有的游览器都会把POST改为GET, 并删除请求报文内的主体, 之后请求会自动再次发送

301、302标准是禁止将POST改为GET方法, 但实际使用时都会改变

<br>

304的请求附加条件是指采用GET方法的请求报文中包含
- If-Match、
- If-Modified-Since、
- IF-None-Match、IF-Rang
- If-Unmodified-Since中的任一首部

<br>

### 400 Bad Request
**请求报文中存在语法错误** 浏览器会像200 OK 一样对待改状态码用于告知客户端它发送了一个错误的请求

<br>

### 401 Unauthorized 未经许可的
发送的请求需要通过http认证(BASIC认证、DIGEST认证)的认证信息, 如果前面已经请求过一次, 证明认证失败

<br>

### 403 Forbidden
请求资源存在 但是访问被服务器拒绝

如果服务器想说明为什么拒绝请求, 可以包含实体的主体部分来对原因进行描述。

但这个状态码通常是在服务器不想说明拒绝原因的时候使用的

<br>

### 404 Not Found
服务器无法找到请求的资源

<br>

### 405 Method Not Allowed
发起的请求中带有所请求的URL 不支持的方法时, 使用此状态码。

应该在响应中包含Allow 首部, 以告知客户端对所请求的资源可以使用哪些方法

<br>

### 406 Not Acceptable
客户端可以指定参数来说明它们愿意接收什么类型的实体。
服务器没有与客户端可接受的URL 相匹配的资源时, 使用此代码
通常, 服务器会包含一些首部, 以便客户端弄清楚为什么请求无法满足。

<br>

### 408 Request Timeout
如果客户端完成请求所花的时间太长, 服务器可以回送此状态码, 并关闭连接。超时时长随服务器的不同有所不同, 但通常对所有的合法请求来说, 都是够长的

<br>

### 409 Conflict
用于说明请求可能在资源上引发的一些冲突。服务器担心请求会引发冲突时, 可以发送此状态码 响应中应该包含描述冲突的主体

<br>

### 410 Gone
与404 类似, 只是服务器曾经拥有过此资源。主要用于Web 站点的维护, 这样服务器的管理者就可以在资源被移除的情况下通知客户端了

<br>

### 411 Length Required
服务器要求在请求报文中包含Content-Length 首部时使用

<br>

### 412 Precondition Failed
客户端发起了条件请求, 且其中一个条件失败了的时候使用。
客户端包含了Expect 首部时发起的就是条件请求。

<br>

### 413 Request Entity Too Large
客户端发送的实体主体部分比服务器能够或者希望处理的要大时, 使用此状态码

<br>

### 414 Request URI Too Long
客户端所发请求中的请求URL 比服务器能够或者希望处理的要长时, 使用此状态码

<br>

### 415 Unsupported Media Type
服务器无法理解或无法支持客户端所发实体的内容类型时, 使用此状态码

<br>

### 416 Requested Range Not Satisfiable
请求报文所请求的是指定资源的某个范围, 而此范围无效或无法满足时, 使用此状态码

<br>

### 417 Expectation Failed
请求的Expect 请求首部包含了一个期望, 但服务器无法满足此期望时, 使用此状态码。

<br>

### 500 Internal Server Error	
服务器端知悉请求时发生错误
服务器遇到一个妨碍它为请求提供服务的错误时, 使用此状态码

<br>

### 501 Not Implemented
客户端发起的请求超出服务器的能力范围(比如, 使用了服务器不支持的请求方法)时, 使用此状态码

<br>

### 502 Bad Gateway
作为代理或网关使用的服务器从请求响应链的下一条链路上收到了一条伪响应(比如, 它无法连接到其父网关)时, 使用此状态码

<br>

### 503 Service Unavailable
服务器暂时处于超负载或正在进行停机维护, 现在无法处理请求

用来说明服务器现在无法为请求提供服务, 但将来可以。如果服务器知道什么时候资源会变为可用的, 可以在响应中包含一个Retry-After 首部

<br>

### 504 Gateway Timeout
与状态码408 类似, 只是这里的响应来自一个网关或代理, 它们在等待另一服务器对其请求进行响应时超时了

<br>

### 505 HTTP Version Not Supported
服务器收到的请求使用了它无法或不愿支持的协议版本时, 使用此状态码。有些服务器应用程序会选择不支持协议的早期版本

<br><br>

# 首部(头信息)
**首部和方法配合工作**

共同决定了客户端和服务器能做什么事情在请求和响应报文中都可以用首部来提供信息

HTTP首部字段向请求和响应报文中添加了一些附加信息。本质上来说, 它们只是一些 key / value 的列表。

<br><br>

## 分类

### 通用首部:
这些是客户端和服务器都可以使用的通用首部。可以在客户端、服务器和其他应用程序之间提供一些非常有用的通用功能。

<br>

### 请求首部 (*请求首部是给服务器看的*)
从名字中就可以看出, 请求首部是请求报文特有的。
它们为服务器提供了一些额外信息, 比如客户端希望接收什么类型的数据。

<br>

### 响应首部 (*响应首部是给客户端看的*)
响应报文有自己的首部集, 以便为客户端提供信息
比如, 客户端在与哪种类型的服务器进行交互

<br>

### 实体首部
实体首部指的是用于应对实体主体部分的首部。比如, 可以用实体首部来说明实体主体部分的数据类型。

<br>

### 扩展首部
扩展首部是非标准的首部, 由应用程序开发者创建, 但还未添加到已批准的HTTP 规范中去。

<br><br>

# 通用首部
有些首部提供了与报文相关的最基本的信息, 它们被称为通用首部。

下面都是通用首部

<br>

### Connection
在客户端发送请求和服务器响应内, 使用 Connection 首部字段, 可控制不在转发给代理的首部字段(即 Hop-by-hop首部)

**格式:**
```js
Connection: 不在转发的首部字段名
```

<br>

比如 管理持久连接

**1. close 断开连接**  
HTTP/1.1版本的默认连接都是持久连接。为此, 客户端会在持久连接上连续发送请求。当服务器端想明确断开连接时, 则指定 Connection 首部字段的值为 close。
```js
Connection: close
```

<br>

**2. Keep-Alive 保持连接**  
HTTP/1.1 之前的版本的默认连接都是非持久连接。为此, 如果想在旧版本的HTTP协议上维持持续连接, 则需要指定 Connection 首部字段的值为 keep-alive。

在客户单发送请求给服务器时, 携带此参数和值, 服务器也会加上字段和值进行返回响应。

```js
Connection: keep-alive
```

<br><br>

### Date
提供日期和时间标志, 说明报文是什么时间创建的
**创建报文的日期时间**

<br>

**RFC1123格式:**  
**HTTP/1.1** 版本使用在RFC1123中规范的日期时间的格式, 如下示例: 

```js
Date: Tue, 03 Jul 2012 04:40:59 GMT
```

<br>

**RFC850格式:**  
之前的HTTP协议版本中使用在RFC850中定义的格式, 如下示例: 
```js
Date: Tue, 03-Jul-12 04:40:59 GMT
```

<br><br> 

### MIME-Version
给出了发送端使用的 MIME 版本

<br><br>

### Trailer
如果报文采用了**分块传输**编码(chunked transfer encoding)方式

就可以用这个首部列出位于报文拖挂(trailer)部分的首部集合 **报文末端的首部一览**

Trailer 会实现说明在报文主体后记录哪些首部字段 该首部字段可以使用在 HTTP/1.1 版本分块传输编码时

```js
HTTP/1.1 200 OK
Date: Tue, 03 Jul 2012 04:40:56 GMT
Content-Type: text/html
· · ·
Transfer-Encoding: chunked
Trailer: Expiress
· · ·

· · · (报文主体) · · ·

0
Expires: Tue, 28 Sep 2004 23:59:59 GMT
```

以上用例中, 指定首部字段 Trailer 的值为 Expires , 在报文主体之后(分块长度0之后)出现的首部字段 Expires。

<br><br>

### Transfer-Encoding
告知接收端为了保证报文的可靠传输, 对报文采用了什么编码方式

**指定报文主体的传输编码方式**

HTTP/1.1 的传输编码方式**仅对分块传输编码有效**

```js
HTTP/1.1 200 OK
Date: Thu, 05 Jul 2018 11:10:37 GMT
Cache-Control: public, max-age=604800
Content-Type: text/javascript; charset=utf-8
Expiress: Thu, 05 Jul 2018 11:12:13 GMT
X-Frame-Option: DENY
X-XSS-Protection: 1; mode=block
Content-Encoding: gzip

Transfer-Encoding: chunked

Connection: keep-alive


cf0  ←16进制(10进制为3312)

· · · 3312字节分块数据 · · ·

392  ←16进制(10进制为914)

· · · 914字节分块数据 · · ·

0
```

以上用例中, 正如在首部字段 Transfer-Encoding 中指定的那样, 有效使用分块传输编码, 且分别被分成 3312 字节和 914 字节大小的分块数据

<br><br>

### Upgrade
给出了发送端可能想要"升级"使用的新版本或协议

**升级为其他协议**

Upgrade 用于检测HTTP协议及其其他协议是否可使用更高的版本进行通信, 其参数值可以用来指定一个完全不同的通信协议

``` 
客户端	  数据包    服务器

Upgrade: TLS/1.0;
Connection:Upgrade


Upgrade: TLS/1.0, HTTP/1.1; Connection:Upgrade
```

上面用例中, 首部字段 Upgrade 指定的值为 TLS/1.0 。请注意此处两个字段首部字段的对应关系, Connection 的值被指定为 Upgrade 。

Upgrade 首部字段产生作用的 Upgrade 对象仅限于客户端和邻接服务器之间。因此, 使用首部字段 Upgrade 时, 还需要额外指定 Connection: Upgrade 。

对于附有首部字段 Upgrade 的请求, 服务器可用 101 Swiching Protocols 状态码作为响应返回。

<br><br>

### Via
https://www.kancloud.cn/spirit-ling/http-study/851889

显示了报文经过的中间节点(代理、网关)  

**代理服务器的相关信息**

为了追踪客户端与服务器之间的请求和响应报文的传输路径。

报文经过代理或网关时, 会先在首部字段 Via 中附加该服务器的信息, 然后再进行转发。这个做法和 traceroute 及电子邮件的 Received 首部的工作机制很类似。
首部字段 Via 不仅用于追踪报文的转发, 还可以避免请求回环的发生。所有必须在经过代理时附加该首部字段内容。

上图用例中, 在经过代理服务器 A 时, Via 首部附加了 "1.0 gw.example.com(Squid/3.1)"这样的字符串值。行头的1.0是指接受请求的服务器上应用的HTTP版本协议。接下来经过, 若果存在更多的代理服务器亦是如此, 在 Via 首部附加服务器信息, 也可增加 1 个新的 Via 首部写入服务器信息。

Via 首部是为了追踪传输路径, 所以经常会和 TRACE 方法一起使用。比如, 代理服务器接受到由 TRACE 方法发送过来的请求(其中 Max-Forwards: 0)时, 代理服务器就不能再转发该请求了。这种情况下, 代理服务器会将自身的信息附加到 Via 首部后, 返回该请求的响应。

<br><br>

### Warning
**错误通知**

HTTP/1.1 的 warning 首部是从 HTTP/1.0 的响应首部(Retry-After)演变过来。该首部通常会告知用户一些与缓存相关的的问题的警告。
Warning 首部的格式如下。最后的日期时间部分可省略。

```js
Warning: [警告码] [警告的主机 : 端口号] "[警告内容]" ([日期时间])
```

HTTP/1.1 中定义了7种警告。警告码对应的警告内容仅推荐参考。另外, 警告码具有扩展性, 今后有可能追加新的警告码。

<br>

**警告码:**  

- 110: Response is stale (响应已过期)	  
代理返回已过期的资源

- 111: Revalidation failed (再验证失败)	  
代理再验证资源有效性时失败(服务器无法到达等原因)

- 112: Disconnection operation (断开连接操作)  
  代理与互联网连接被故意切断

- 113: Heuristic expiration (试探性过期)  
响应的使用期超过24小时(有效缓存的设定时间大于24小时的情况下)

- 199: Miscellaneous warning (杂项警告)	  
任意警告内容

- 214: Transformation applied(使用了转换)	  
代理对内容编码或媒体类型等执行了某些处理时

- 299: Miscellaneous persistent warning(持久杂项警告)  	
任意的警告内容

<br><br>

### Pragma
另一种随报文传送指示的方式, 但并不专用于缓存
**报文指令**

Pragma 是HTTP/1.1 之前版本保留的历史遗留字段, 仅作为与HTTP/1.0 的向后兼容而定义。

```js
Pragma: no-cache
```

该首部字段属于通用首部字段, 但只用在客户端发送的请求中。客户端会要求所有的中间服务器不反回缓存的资源。

所有的中间服务器如果都能以HTTP/1.1为基准, 那直接采用

<br>

**Cache-Control: no-cache**   
指定缓存的处理方式是最理想的。但要整体掌握全部中间服务器使用的HTTP协议版本却是不现实的。因此, 发送的请求会同时含有下面两个首部字段: 

```js
Cache-Control: no-cache
Pragma: no-cache
```

<br><br>

## 通用缓存首部
HTTP/1.0 引入了第一个允许HTTP 应用程序缓存对象本地副本的首部, 这样就不需要总是直接从源端服务器获取了

<br>

### Cache-Control
**控制缓存的行为**

通过指定首部字段 Cache-Control 的指令, 来进行缓存操作的工作机制, 多个参数之间可以使用","分隔
```js
Cache-Control: private,max-age=0,no-cache
```

<br>

### **缓存请求指令**
### no-cache:
参数: 无  
强制向源服务器再次验证

<br>

### no-store:
参数: 无  
不缓存请求或响应的任何内容

<br>

### max-age=[秒]:
参数: 必需  
响应最大的Age值

<br>

### min-fresh(=[秒]):
参数: 可省略	  
接受已过期的响应

<br>

### min-fresh=[秒]:
参数: 必需  
期望在指定时间内的响应仍有效

<br>

### no-transform:
参数: 无  
代理不可更改类型

<br>

### only-if-cached:
参数: 无  
从缓存获取资源

<br>

### cache-extension:
参数: 无
新指令标记(token)

<br><br>

### **缓存响应指令**
### public:
参数: 无  
可向任意方提供响应的缓存

<br>

### private:
参数: 可省略	  
仅向特定用户返回响应

<br>

### no-cache:
参数: 可省略  
缓存前必须确认其有效性

<br>

### no-store:
参数: 无  
不缓存请求或响应的任何内容

<br>

### no-transform:
参数: 无  
代理不可更改媒体类型

<br>

### must-revalidate:
参数: 无  
需求中间缓存服务器对缓存的响应有效性再进行确认

<br>

### max-age=[秒]:
参数: 必需  
响应的最大Age值

<br>

### s-maxage=[秒]:
参数: 必需  
公众缓存服务器响应的最大Age值

<br>

### cache-extension:
参数: 必需  
新指令标记(token)

<br>

### 表示是否能缓存的指令
**public 指令**    
意思公共的, 表示所有人都可以利用缓存
```js
Cache-Control: public
```

<br>

**private 指令**  
意思私人的, 表示响应只以特定的用户作为对象, 这与 public 指令的行动相反
```js
Cache-Control: private
```

<br>

**no-cache 指令**  
意思是**不要过期的缓存资源**, 表示为了防止从缓存中返回过期的资源
```js
Cache-Control: no-cache
```

<br>

**客户端发送携带:**  
表示客户端将不会接受缓存过的响应。于是, "中间"的缓存服务器必须把客户端请求转发给源服务器。

<br>

**服务器端发送携带:**   
表示缓存服务器不能对资源进行缓存。源服务器以后也将不再对缓存服务器请求中提出的资源有效性进行确认, 且禁止对其响应资源进行缓存操作

```js
Cache-Control: no-cache=Location
```

由服务器返回的响应中, 若报文首部字段 Cache-Control 中对 no-cache 字段名进行具体指定参数值, 那么客户端在接受到这个被指定参数值的首部字段对应的响应报文后, 就不能使用缓存。换言之, 无参数值的首部字段可以使用缓存。只能在响应指令中指定该参数

<br>

**注意:**  
这里 no-cache不是代表着不缓存, 而是代表着, **不要过期的缓存**

意思就是说, 当请求时, 中间缓存服务器会向服务器进行有效期确认, 不使用当前缓存的过期资源, 也许 no-cache 称为 

do-not-serve-from-cache-without-revalidation 更为恰当

<br>

### 控制可执行缓存的对象的指令
**no-store 指令**  
store 意识是仓库, 储存, 代表着请求(和对应的响应)或响应中包含机密信息, 因此, 改指令才是真正的不缓存, 规定不能缓存在本地存储请求或响应的任一部分
```js
Cache-Control: no-store
```

<br>

### 指定缓存期限和认证的指令
**s-maxage 指令**
```js
Cache-Conntrol: x-maxage=604800 (单位: 秒)
```

s-maxage 指令的功能和 max-age 指令相同, 它们的不同点就是 

s-maxage 指令只适用于多位用户使用的公共缓存服务器(一般指代理)。也就是说, 对于同一用户重复返回响应的服务器来说, 这个指令没有任何作用。

另外, 当使用 s-maxage 指令后, 则直接忽略对 Expires 首部字段及 max-age 指令的处理

<br>

**max-age 指令**
```js
Cache-Control: max-age=604800(单位: 秒)
```

当客户端发送的请求中包含 max-age 指令时, 
如果判断缓存资源的缓存时间数值比指定时间的数值更小, 那么客户端就接收到缓存的资源。

另外, 当指定 max-age 值为0, 那么缓存服务器通常需要将请求转发给源服务器。
当服务器返回的响应中包含 max-age 指令时, 缓存服务器将不对资源的有效性进行再度确认, 而 max-age 数字代表资源保存为缓存的最长时间。

应用 HTTP/1.1 版本的缓存服务器遇到同时存在Expiress首部字段的情况时, 会优先处理 max-age 指令, 而忽略掉 Expires 首部字段。
而 HTTP/1.0 版本的缓存服务器的情况刚好相反, max-age 指令会被忽略。

<br>

**min-fresh 指令**
```js
Cache-Control: min-fresh=60 (单位: 秒)
```
min-fresh 指令是要求缓存服务器返回至少还未过指定时间的缓存资源。

比如: 当指定 min-fresh 为60秒时, 在这60秒以内如果有超过有效期限的资源都无法作为响应返回了。

<br>

*max-stale 指令*
```js
Canche-Control: max-stale=3600(单位: 秒)
```

使用 max-stale 可指示缓存资源, 即使过期页照常接收。

如果指令未指定参数值, 那么无论经过多久, 客户端都会接收响应; 如果指令中指定了具体的数值, 那么即使过期, 只要仍然处于 max-stale 指定的时间内, 仍旧会被客户端接收。

<br>

**only-if-cached 指令**
```js
Cache-Control: only-if-cached
```

使用 only-if-cached 指令表示客户端仅在缓存服务器本地缓存目标资源的情况下才会被要求其返回, 

换言之, 该指令要求缓存服务器不重新加载响应, 也不会再次确认资源有效性。若发生请求缓存服务器的本地缓存无响应, 则返回状态码 504 Gateway Timeout (请求网关超时)

<br>

**must-revalidate 指令**
```js
Cacnhe-Control: must-revalidtae
```

使用 must-revalidtae 指令, 代理会向源服务器再次验证即将返回的响应缓存目前是否依然有效。

若代理无法连通源服务器再次获取有效资源的话, 缓存必须给客户端一条 504 Gateway Timeout (请求网关超时)状态码。

另外, 使用 must-revalidtae 指令会忽略请求的 max-stale 指令(即使已经在首部使用了 max-stale , 也不会再有效果)。

<br>

**proxy-revalidate 指令**
```js
Cacnhe-Control: proxy-revalidtae
```

proxy-revalidtae 指令要求所有的缓存服务器在接收到客户端带有该指令的请求返回响应之前, 必须再次验证缓存的有效性。

<br>

**no-transform 指令**
```js
Cacnhe-Control: no-transform
```

使用 no-transform 指令规定无论是在请求还是响应中, 缓存都不能改变实体主体的媒体类型。
这样可以防止缓存或代理压缩图片等类似操作。

<br>

### Canche-Control 扩展

**cache-extension token**  
Cache-Control: private,community="UCI"
通过 cache-extension 标记(token), 可以扩展 Cache-Control 首部字段内的指令。

如上例, Cache-Control 首部字段本身没有 community 这个指令。借助 extension tokens 实现了改指令的添加。如果缓存服务器不能理解 community 这个新指令, 就会直接忽略。因此, extension tokens 仅对能理解它的缓存服务器来说是有意义的。

<br><br>

# 请求首部
请求首部是只在请求报文中有意义的首部。用于说明是谁或什么在发送请求、请求源自何处, 或者客户端的喜好及能力

服务器可以根据请求首部给出的客户端信息, 试着为客户端提供更好的响应。

- Client-IP:  
提供了运行客户端的机器的IP 地址

- From:  
提供了客户端用户的E-mail 地址

- Host:  
给出了接收请求的服务器的主机名和端口号

- Referer:  
提供了包含当前请求URI 的文档的URL
nginx教程中说 该请求头在第二次请求的时候才有

- UA-Color:  
提供了与客户端显示器的显示颜色有关的信息

- UA-CPU:  
给出了客户端CPU 的类型或制造商

- UA-Disp:  
提供了与客户端显示器(屏幕)能力有关的信息

- UA-OS:  
给出了运行在客户端机器上的操作系统名称及版本

- UA-Pixels:  
提供了客户端显示器的像素信息

- User-Agent:  
将发起请求的应用程序名称告知服务器

<br>

## Accept首部用处
Accept 首部为客户端提供了一种将其喜好和能力**告知服务器的方式, 包括它们想要什么, 可以使用什么**, 以及最重要的, 它们不想要什么。

这样, 服务器就可以根据这些额外信息, 对要发送的内容做出更明智的决定。

Accept 首部会使连接的两端都受益。客户端会得到它们想要的内容, 服务器则不会浪费其时间和带宽来发送客户端无法使用的东西。

说白了就是告诉服务器我想要你什么 你别传其它的东西给我

<br>

### Accept
**首部字段可通知服务器, 用户代理能够处理的媒体类型及媒体类型的相对优先级。**

可使用 type/subtype 这种形式, 一次指定多种媒体类型。

```js
Accept: text/html , application/xhtml+xml , application/xml ; q=0.9 , */* ; q=0.8
```

<br>

### 以下是常用的媒体类型
**文本文件类型:**
- text/html
- text/plain
- text/css
- appllication/xhtml+xml
- application/xml

<br>

**图片文件类型:**
- image/jpeg
- image/gif
- image/png

<br>

**视频文件类型:**
- video/mpeg
- video/quicktime

<br>

**应用程序使用的二进制文件:**
- application/octet-strea
- application/zip

<br>

比如:  
游览器不支持PNG图片的显示, 那 Accept 就不指定 image/png , 而指定可处理的 image/gif 和 image/jpeg 等图片类型。

<br>

### 权重:
若想要给显示的媒体类型增加优先级, 则使用 q= 来额外表示权重值, 用分号(; )进行分隔。

权重值 q 的范围是 0-1(可精确到小数点后3位), 且1为最大值。不指定权重 q 值时, 默认权重为 q=1.0。

当服务器提供多种内容时, 将会首先返回权重值最高的媒体类型。

<br><br>

### Accept-Charset
Accept-charset 首部字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。

另外, 可一次性指定多种字符集。与首部字段 Accept 相同的是可用权重 q 值来表示相对优先级。

```js
Accept-Charset: utf-8, iso-8859-1;q=0.5
```

<br><br>

### Accept-Encoding
Accept-Encoding 首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序。可一次性指定多种内容编码。

**告诉服务器 客户端可以接收的数据的编码格式(或者压缩格式)**

```js
Accept-Encoding: gzip, deflate
```

<br>

**常用的内容编码:**  

**gzip:**  
由文件压缩程序 gzip(GUN zip)生成的编码格式(RFC1952), 采用 Lempel-Ziv 算法(LZ77)及32位循环冗余校验(Cyclic Redundancy Check, 通称 CRC)

<br>

**compress:**  
由 UNIX 文件压缩程序 compress 生成的编码格式, 采用 Lempel-Ziv-Welch 算法(LZW)。

<br>

**deflate:**  
组合使用 zlib 格式(RFC1950)及由 deflate 压缩算法(RFC1951)生成的编码格式。

<br>

**identity:**  
不执行压缩或不会变化的默认编码格式。
采用权重 q 来进行表示相对优先级, 与首部字段 Accept 相同, 另外, 也可以使用星号(*)作为通配符, 指定任意的编码格式。

<br><br>

### Accept-Language
Accept-Language用**来告知服务器用户代理能够处理的自然语言集**(指中文或者英文等), 以及自然语言集的相对优先级。

可一次指定多种自然语言集

```js
Accept-Language: zh-cn, zh; q=0.7, en-us,en; q=0.3
```

<br>

**告诉服务器客户端可以接收的语言类型** 
- zh_CH
- en_US
- ja

<br>

采用权重 q 来进行表示相对优先级, 与首部字段 Accept 相同, 在上述例子中, 客户端在服务器有中文版资源的情况下, 会请求其返回中文版对象的响应, 没有中文版时, 则请求返回英文版响应。

<br>

**q权重系数:**  
范围: 0 =< q <= 1
q 值越大, 请求越倾向于获得其";"之前的类型表示的内容
若没有指定 q 值, 则默认为1, 若被赋值为0, 则用于提醒服务器哪些是浏览器不接受的内容类型。

<br><br>

### Authorization
Authorization 是用来告知服务器, 用户代理的认证信息(证书值)。

通常, 想要通过服务器认证的用户代理会在接受到返回的401状态码响应后, 把首部字段 Authorization 加入请求中。公众缓存在接受到含有 Authorization 首部字段的请求时的操作处理会略有差异。

```js
Authorization: Basic dWVub3N1bjpwYXHzd29yZA==
```

<br><br>

### TE
```js
TE: gzip, deflate; q=0.5
```

首部字段 TE 会告知服务器客户端能够处理响应的传输编码方式及相对优先级。它和首部字段 Accept-Encoding 的功能很像, 但是用于传输编码。

首部字段 TE 除指定传输编码之外, 还可以指定伴随 trailer 字段的分块传输编码的方式。应用后者时, 只需把 trailer 赋值给该字段值。

```js
TE: trailers
```

<br><br>

### Expect
Expect 是客户端用来告知服务器, 期望出现的某种特定行为。因服务器无法理解客户端的期望作出回应而发生错误时, 会返回状态码 417 Expectation Failed。
```js
Expect: 100-continue
```

客户端可以利用该首部字段, 写明所期望的扩展。虽然 HTTP/1.1 规范只定义了 100-continue(状态码 100 Continue 之意)。

等待状态码 100 响应的客户端在发生请求时, 需要指定 Expect: 100-continue

<br><br>

### From
From 是用来告知服务器使用用户代理的用户的电子邮件地址。

```js
From: info@example.com
```

通常, 其使用目的就是为了显示搜索引擎等用户代理的负责人的电子邮件联系方式。使用代理时, 应尽可能包含 From 首部字段(但可能会因代理不同, 将电子邮件地址记录在 User-Agent 首部字段中)。

<br><br>

### Host
Host 是用来告知服务器, 请求的资源所处的互联网主机名和端口号。

Host 首部字段是 HTTP/1.1 规范内是唯一一个必须被包含在请求内的首部字段。

```js
Host: www.example.com
```

首部字段 Host 和以单台服务器分配多个域名的虚拟主机的工作及制有密切的关联, 这是首部字段 Host 必须存在的意义。

请求被发送至服务器时, 请求中的主机名会用 IP 地址直接替换解决。但如果这时, 相同的 IP 地址下部署运行着多个域名时, 那么服务器就会无法理解究竟是哪个域名对应的请求。因此, 就需要使用首部字段 Host 来明确指出请求的主机名。若服务器未设定主机名, 那直接发送一个空值即可。

```js
Host: 
```

<br><br>

## 条件请求首部
有时客户端希望为请求加上某些限制。

比如, 如果客户端已经有了一份文档副本, 就希望只在服务器上的文档与客户端拥有的副本有所区别时, 才请求服务器传输文档。

通过条件请求首部, 客户端就可以为请求加上这种限制, 要求服务器在对请求进行响应之前确保某个条件为真

**形如 If-xxx 这样的请求首部字段, 都可以称为条件请求。服务器接收到附带条件的请求后, 只有判断指定条件为真时, 才会执行请求。给出响应**

<br>

### If-Match
只有当 If-Match 的字段值跟 ETge 值匹配一致时, 服务器才会处理这个请求。
```js
If-Match: "123456"
```

首部字段 If-Match , 属附带条件之一, 它会告知服务器匹配资源所用的实体标记(ETge)值。这时的服务器无法使用弱 ETge 值。(请参考后续有关首部字段 ETge 的说明)。

服务器会对比 If-Match 的字段值和资源的 ETge 值, 仅当两者一致时, 才会执行请求。反之, 则返回状态 412 Precondition Failed 的响应。

还可以使用星号(*)指定 If-Match 的字段值。针对这种情况, 服务器将会忽略 ETge 的值, 只有资源存在就处理请求

<br><br>

### If-Modified-Since
如果 If-Modified-Since 字段指定的日期时间后, 资源发生了更新, 服务器会接受请求
```js
If-Modified-Since: Thu, 15 Apr 2018 00:00:00 GMT
```

首部字段 If-Modified-Since , 属附带条件之一, 它会告知服务器若 If-Modified-Since 字段值早于资源的更新时间, 则希望能处理该请求。而在指定 If-Modified-Since 字段值的日期时间之后, 如果请求的资源都没有过更新, 则返回状态码 304 Not Modified

If-Modified-Since 用于确认代理或客户端拥有本地资源的有效性。获取资源的更新日期时间, 可通过确认首部字段 Last-Modified 来确定

<br><br>

### If-None-Match
只有在 If-None-Match 的字段值与 ETge 值不一致时, 可处理该请求。与 If-Match 首部字段的作用相反
```js
If-None-Match: *
```

首部字段 If-None-Match 属于附带条件之一。它和首部字段 If-Match 作用相反。用于指定 If-None-Match 字段值的实体标记(ETge)值与请求资源的 ETge 不一致时, 它就会告知服务器处理该请求。

在 GET 和 HEAD 方法中使用首部字段 If-None-Match 可获取最新的资源。因此, 这与使用首部字段 If-Modified-Since 时有些类似

<br><br>

### If-Range
If-Range 字段值若是更 ETge 值或更新日期时间一致, 那么就作为范围请求处理。若不一致, 则忽略范围请求, 返回全部资源。

首部字段 If-Range 属于附带条件之一。它告知服务器若指定 If-Range 字段值(与 ETge 值或者时间)和请求资源的 ETge 值或时间相一致时, 则作为范围请求处理。反之, 则返回全体资源。

*如果不使用 If-Range 时, 则需要进行两次请求*

服务器端的资源如果更新, 那客户端持有资源中的一部分也会随之无效, 当然, 范围请求作为前提也是无效的。这时, 服务器会暂且以状态码 412 Precondition Failed 作为响应返回, 其目的是催促客户端再次发送请求。这样一来, 与使用首部字段 If-Range 比起来, 就需要花费两倍功夫。

<br><br>

### If-Unmodified-Since
部字段 If-Unmodified-Since 和首部字段 If-Modified-Since 的作用相反。

它的作用就是告知服务器, 指定的请求资源只有在字段值内定的日期时间之后, 未发生更新的情况下, 才能处理请求。如果在指定日期时间后发生了更新, 则以状态码 412 Precondition Failed 作为响应返回。

```js
If-Unmodified-Since: Thu, 03 Jul 2018 00:00:00 GMT
```

<br><br>

### Max-Forwards
每次转发数值减一, 当数值为0时, 则返回响应
```js
Max-Forwards: 2
```

通过 TRACE 方法或 OPTIONS 方法, 发送含有首部字段 Max-Forwards 的请求时, 该字段以十进制整数形式指定可经过的服务器最大数目。服务器在往下一个服务器转发请求之前, 会将 Max-Forwards 的值减一后重新赋值。当服务器接收到 Max-Forwards 值为 0 的请求时, 则不再进行转发。而是直接返回响应。

使用 HTTP协议通信时, 请求可能会经过代理等多台服务器。途中, 如果代理服务器由于某些原因导致请求转发失败, 客户端也就等不到服务器返回的响应了。对此, 我们无从可知。

可以灵活使用首部字段 Max-Forwards 字段值为 0 , 服务器就会立即返回响应, 由此我们至少可以对以那台服务器为终点的传输路径的通信状况有所把握

<br><br>

### Proxy-Authorization
```js
Proxy-Authorization: Basic YWRtaW4lM0FhZG1pbg==
```

接受到从代理服务器发来的认证质询时, 客户端会发送包含首部字段 Proxy-Authorization 的请求, 以告知服务器认证所需要的信息。

这个行为是与客户端和服务器之间的HTTP访问认证相类似的, 不同之处在于, 认证行为发生在客户端与代理之间。客户端与服务器之间的认证, 使用首部字段 Authorization 可起到相同作用。有关HTTP访问认证, 后面有详尽解释。

<br><br>

### Range
对于只需获资源的范围请求, 包含首部字段 Range 即可告知服务器资源的指定范围。上面的示例表示请求获取从第 5001 字节到第 10000 字节的资源。

接收到附带 Range 首部字段请求的服务器, 会在处理请求之后返回状态码为 206 Partial Content 的响应。无法处理该范围请求时, 则会返回状态码 200 OK 的响应及全部资源。

```js
Range: bytes=5001-10000
```

<br><br>

### Referer
**请求发起时 浏览器地址栏的地址(简单的说从哪来)**

只要查看 Referer 就能知道请求的 URI 是从哪个 Web 页面发起的

二次请求的时候就会有 referer 这个请求头 相当于问你从哪来的 我北京的 这个概念

```js
Referer: http://www.example.com/index.html
```

客户端一般都会发送 Referer 首部字段给服务器。但当直接在游览器的地址输入 URI , 或处于安全考虑时, 也可以不发送该首部字段。

因为原始资源的 URI 中的查询字符串可能包含 ID 或密码等保密信息, 要是写进 Referer 转发给其他服务器, 则有可能导致保密信息的泄露。

另外, Referer 的正确拼写应该是 Referrer , 但不知为何, 大家一致沿用这个错误的拼写。

**请求发起时 浏览器地址栏的地址(从哪来)** 

<br>

比如:  

**前端页面:**  
http://localhost:8080/project/

页面有一个 form表单

action="http://localhost:8080/project/hello2"

也就是说我们点击 提交的时候 会跳转到 
http://localhost:8080/project/hello2

这时我们再打开控制台的 network 查看 Referer
会发现它的值为 http://localhost:8080/project/

也就是说我们可以从这个请求头上看出 从哪来到/hello2这个页面的

<br>

### 应用场景:
1. 从这个请求头也能看出 哪个网站给我导的流量比较多
2. 防止盗链 这个没细说

<br><br>

### User-Agent
**浏览器的信息**

首部字段 User-Agent 会将创建请求的游览器和用户代理名称等信息传达给服务器。

由网络爬虫发起请求时, 有可能会在字段内添加爬虫的电子邮件地址。此外, 如果经过代理, 那么中间也很可能被添加上代理服务器的名称。

```js
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36
```

<br><br>

### Connection
**告诉服务器请求连接如何处理**

**常用的值:**
1. keep-alive: 告诉服务器回传数据后不要马上关闭 保持一小段时间的连接

2. closed: 马上关闭

<br><br>

# 响应首部
响应报文有自己的响应首部集。响应首部为客户端提供了一些额外信息, 比如谁在发送响应、响应者的功能, 甚至与响应相关的一些特殊指令。

这些首部有助于客户端处理响应, 并在将来发起更好的请求。

<br><br>

### Accept-Ranges
首部字段 Accept-Ranges 是用来**告知客户端服务器是否能处理范围请求**, 以指定获取服务器某个部分资源。

可指定的字段值有两种
- 可处理范围请求时指定其为 bytes
- 反之则指定为 none

```js
Accept-Ranges: bytes
```

<br>

**当不能进行范围请求处理时**
```js
Accept-Ranges: none
```

<br><br>

### Content-Disposition
**用于告诉客户端 收到数据后怎么处理**

**可选值:**  
- inline: 默认值，表示响应中的消息体会以页面的一部分或者整个页面的形式展示。

- attachment: 表示响应的消息体应被下载到本地；大多数浏览器会出现一个“保存为”的对话框。

Content-Disposition: "attachment; filename="

- attachment: 表示下载使用
- filename="文件名" 指定下载文件的文件名

```js
// 正常解析渲染
Content-Disposition: inline
// 下载文件
Content-Disposition: attachment
// 下载文件，并将文件保存为filename.jpg
Content-Disposition: attachment; filename="filename.jpg"
```

<br>

Content-disposition是MIME协议的扩展  
MIME协议指示MIME用户代理如何显示附加的文件。

当Internet Explorer接收到头时, 他会激活文件下载对话框, 它的文件名框自动填充headers指定的文件名。

服务器向浏览器发送文件时, 如果是浏览器支持的文件类型, 一般会默认使用浏览器打开, 比如txt、jpg等。如果需要提示用户保存, 就要利用Content-Disposition进行处理, (敲黑板, 划重点)关键在于一定要加上attachment [附件] [əˈtætʃmənt]

这样的话, 浏览器在打开的时候回提示保存还是打开, 即使选择打开, 也会使用相关联的程序, 比如记事本打开, 而不是IE直接打开。

<br><br>

### Age
首部字段 Age 能告知客户端, 源服务器在多久前创建了响应。字段值单位为秒。

(从最初创建开始)响应持续时间

若创建该响应的服务器是缓存服务器, Age 值是指缓存后的响应再次发起认证到认证完成的时间值。代理创建响应时必须加上首部字段 Age。

```js
Age: 600
```

<br><br>
    
### ETge
首部字段 ETge 能够告知客户端实体标识。它是一种可将资源以字符串形式做唯一标识的方式。服务器会为每份资源分配对于的 ETge 值时, 

另外, 当资源更新时, ETge 值也需要更新。生成 ETge 值时, 并没有统一的算法规则, 而是仅仅由服务器来分配。

资源被缓存时, 就会被分配唯一性标识。例如, 当使用中文版的浏览器访问 http://www.google.com 时, 就会返回中文版对于的资源, 当时有英文版版时, 返回的就是英文版资源, 两者的 URI 是相同的, 所以仅凭 URI 指定缓存的资源是相当困难的。若在下载过程中出现连续中断/再连接的情况, 都会依照 ETge 值来指定资源。
```js
ETge: "fa082-57b5144e55180"
```

<br>

### 强ETge值 和 弱ETge值

**强 ETge 值:**  
强 ETge 值, 不论实体发生多少细微的变化都会改变其值。
```js
ETge: "usagi-1234"
```

<br>

**弱 ETge 值:**  
弱 ETge 值只用于提示资源是否相同。只有资源发生了根本改变, 产生差异时才会改变 ETge 值。这时, 会在字段值最开始处附加 W/ 。
```js
ETge: W/"usagi-1234"
```

<br><br>

### Localtion
```js
Location: http://www.example.com
```

使用首部字段 Location 可以将响应接受方引导至某个与请求 URI 位置不同的资源。

基本上, 该字段会配合 3xx : Redirection 的响应, 提供重定向的 URI。

几乎所有的游览器在接受到包含首部字段 Location 的响应后, 都会强制性地尝试对已提示的重定向资源的访问。

<br><br>

### Proxy-Authenticate
```js
Proxy-Authenticate: Basic realm="Usagidesign Auth"
```

首部字段 Proxy-Authenticate 会把由代理服务器所要求的认证信息发送给客户端。

它与客户端和服务器之间的 HTTP 访问认证的行为相似, 不同之处在于其认证行为是在客户端与代理之间进行的。而客户端与服务器之间进行认证时, 首部字段 WWW-Authorization 有着相同的作用。有关 HTTP 访问认证, 后面会详尽说明。

来自代理的对客户端的质询列表

<br><br>

### Retry-After
首部字段 Retry-After 告知客户端应该在多久之后再次发送请求。主要配合状态码 503 Service Unavailable 响应, 或 3xx Redirect 响应一起使用。

字段值可以指定为具体时间(Wed, 04 Jul 2012 06: 34: 23 GMT 等格式), 也可以是创建响应后的秒数。

如果资源不可用的话, 在此日期或时间重试

```js
Retry-After : 120
```

<br><br>

### Server
**服务器的信息**

```js
Server : Apache/2.2.17 (Unix)
```

首部字段 Server **告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。**

不单单会标出服务器上的软件应用名称, 还有可能包含版本号和安装时启用的可选项。

服务器应用程序软件的名称和版本

```js
Server: Apache/2.26 (Unix) PHP/5.2.5
```

**注意:**
一旦自己服务器使用的为旧版本, 并且漏洞已经被放出来的, 最好在隐藏此字段或者自己随意改个名称, 以防有人使用已知漏洞攻击服务器

<br><br>

### Vary
服务器查看的其他首部的列表, 可能会使响应发生变化; 也就是说, 这是一个首部列表, 服务器会根据这些首部的内容挑选出最适合的资源版本发送给客户端

首部字段 Vary 可对缓存进行控制。源服务器会向代理服务器传达关于本地缓存使用方法的指令。

从代理服务器接受到源服务器返回包含 Vary 指定项的响应之后, 若再要进行缓存, 仅对请求中含有相同 Vary 指定首部字段的请求返回缓存。即使对相同资源发起请求, 但由于 Vary 指定的首部字段不相同, 因此必须要从源服务器重新获取资源。

```js
Vary: Accept-Language
```

<br><br>

### WWW-Authenticate
```js
WWW-Authenticate: Basic realm="Usagidesign Auth"
```
首部字段 WWW-Authenticate 用于 HTTP 访问认证。它会告知客户端适用于访问请求 URI 所指定资源的认证方案( Basic 或是 Digest )和带参数提示的质询(challenge)。状态码 401 Unauthorized 响应中, 肯定带有首部字段 WWW-Authenticate 。
上述示例中, realm 字段的字符串是为了辨别请求 URI 指定资源所受到的保护策略。有关该首部, 参考本节之后的内容。

来自服务器的对客户端的质询列表

<br><br>

# 实体首部
有很多首部可以用来描述HTTP 报文的负荷。由于请求和响应报文中都可能包含实体部分, 所以在这两种类型的报文中都可能出现这些首部。

实体首部提供了有关实体及其内容的大量信息, 从有关对象类型的信息, 到能够对资源使用的各种有效的请求方法。总之, 实体首部可以告知报文的接收者它在对什么进行处理。

<br>

### Allow
列出了可以对此实体执行的请求方法

首部字段 Allow 用于通知客户端能够支持 Request-URI 指定资源的所有 HTTP 方法。 当服务器接收到不支持的 HTTP 方法时, 会以状态码 405 Method Not Allowed 作为响应返回。与此同时, 还会把所有能支持的 HTTP 方法写入首部字段 Allow 后返回。


```js
Allow : GET, HEAD
```

<br><br>

### 内容首部
内容首部提供了与实体内容有关的特定信息, 说明了其类型、尺寸以及处理它所需的其他有用信息。
比如, Web 浏览器可以通过查看返回的内容类型, 得知如何显示对象

Allow

### Content-Base
解析主体中的相对URL 时使用的基础URL

<br><br>

### Content-Encoding
```js
Content-Encoding: gzip
```

首部字段 Content-Encoding 会告知客户端服务器对实体的主体部分选用的内容编码方式。内容编码是指在不丢失实体信息的前提下所进行的压缩。

**主要采用以下4种方式: **
- gzip
- compress
- deflate
- identity

<br><br>

### Content-Language
首部字段 Content-Language 会告知客户端, 实体主体使用的自然语言(指中文或英文等语言)。
```js
Content-Language: zh-CN
```

<br><br>

### Content-Length
```js
Content-Length: 15000
```
首部字段 Content-Length 表明了实体主体部分的大小(单位是字节)。对实体主体进行内容编码传输时, 不能再使用 Content-Length 首部字段。由于实体主体大小的计算方式略微有些复杂

响应体的大小 可以不写 浏览器会自动求取 一旦写 必须准确

<br><br>

### Content-Location
```js
Content-Location: httpo://www.example.com/index.html
```

**资源实际所处的位置** 

首部字段 Content-Location 给出与报文主题部分相对应的URI。和首部字段 Location 不同, Content-Location 表示的是报文主体返回资源对应的 URI。

比如, 对于使用首部字段 Accept-Language 的服务器驱动型请求, 当返回的页面内容与实际请求的对象不同时, 首部字段 Content-Location 内会写明 URI。(访问 http://www.example.com/ 返回的对象却是 http://www.example.com/index.html 等类似情况)。

<br><br>

### Content-MD5
首部字段 Content-MD5 是一串由MD5算法生成的值, 其目的在于检查报文主体在传输过程中是否保持完整, 以及确认传输到达。

对报文主体执行 MD5 算法获得218位二进制数, 再通过 Base64 编码后将结果写入 Content-MD5 字段值。由于 HTTP 首部无法记录二进制值, 所以要通过 Base64 编码处理。为确保报文有效性, 作为接受方的客户端会对报文主体在执行一次相同的MD5算法。计算出的值与字段值作比较候鸟, 即可判断出报文主体的准确性。

采用这种方法, 对内容上的偶发生性改变是无从查证的, 也无法检测出恶意篡改。其中一个原因在于, 内容如果能够被篡改, 那么同时意味着 Content-MD5 也可重新计算然后被篡改。所以处在接受阶段的客户端是无法意识到报文主体以及首部字段 Content-MD5 是已经被篡改过的。

```js
Content-MD5: ZTEwYWRjMzk0OWJhNTlhYmJlNTZlMDU3ZjIwZjg4M2U=
```

<br><br>

### Content-Range
在整个资源中此实体表示的字节范围
```js
Content-Range: bytes 5001-10000/10000
```
针对范围请求, 返回响应时使用的首部字段 Content-Range , 能告知客户端作为响应返回的实体哪个部分符合范围请求。字段值以字节为单位, 表示当前发送部分及整个实体大小。

<br><br>

### Content-Type
首部字段 Content-Type **说明实体主体内对象的数据类型**, **或者说请求体 和 响应体的编码格式**

```js
Content-Type: text/html; charset=utf-8
```

和首部字段 Accept一样, 字段值用 type/subtype 形式赋值。

<br>

比如: 表示发送数据的类型 常用的值:

**application/x-www-form-urlencoded:**   
表示提交的数据格式是: key=value&key=value, 然后对url进行编码(把非英文的内容转换为%xx%xx)

**表单类型**

<br>

**multipart/form-data:**  
表示以多段的形式提交数据给服务器(以流的形式) 用于上传

<br><br>

### 实体缓存首部
通用的缓存首部说明了如何或什么时候进行缓存。实体的缓存首部提供了与被缓存实体有关的信息

比如, 验证已缓存的资源副本是否仍然有效所需的信息, 以及更好地估计已缓存资源何时失效所需的线索。

<br>

### ETag
与此实体相关的实体标记

<br><br>

### Expires
实体不再有效, 要从原始的源端再次获取此实体的日期和时间

首部字段 Expires 会将资源失效日期告知客户端。

缓存服务器在接收到含有首部字段 Expires 的响应后, 会以缓存来应答请求, 在 Expires 字段值指定的时间之前, 响应的副本会一直被保存。

当超过指定的时间后, 缓存服务器在请求发送过来时, 会转向源服务器请求资源。

源服务器不希望缓存服务器对资源缓存时, 最好在 Expires 字段内写入与首部字段 Date 相同的时间值。

但是, 当首部字段 Cache-Control 有指定 max-age 指令时, 比起首部字段 Expires , 会优先处理 max-age 指令。
```js
Expires: Wed, 04 Jul 2012 08:26:05 GMT
```

<br><br>

###  Last-Modified
```js
Last-Modified: wed, 25 May 2018 09:11:40 GMT
```
这个实体最后一次被修改的日期和时间
首部字段 Last-Modified 指明资源最终修改时间。一般来说, 这个值就是 Request-URI 指定资源被修改的时间。但类似使用 CGI 脚本进行动态数据处理时, 该值有可能会变成数据最终修改时的时间。

<br><br>

# 为 Cookie 服务和其他首部字段

### 为 Cookie 服务的首部字段
管理服务器与客户端之间状态的 Cookie , 虽然没有被编入标准化 HTTP/1.1 的 RFC2616 中, 但在 Web 网站方面得到广泛的应用。

Cookie 的工作机制是用户识别及状态管理。web 网站为了管理用户的状态会通过 web 游览器, 把一些数据临时写入用户的计算机内。接着当用户访问该 web 网站时, 可通过通信方式取回之前存放的 Cookie 。

调用 Cookie 时, 由于可校验 Cookie 的有效期, 以及发送方的域、路径、协议等信息, 所以正规发布的 Cookie 内的数据不会因来自其他 web 站点和攻击者的攻击而泄露。

在目前使用最广泛的 Cookie 标准却不是 RFC 中定义的任何一个。而是在网景公司指定的标准上进行扩展后的产物。

下面是与 Cookie 有关的首部字段:

<br>

### Set-Cookie
开始状态管理所使用的 Cookie 信息	  **响应首部字段**
```js
Set-Cookie: status-enable; expires=Tue, 05 Jul 2018 02:01:22 GMT; path=/; domain=.example.com;
```
当服务器准备开始管理客户端的状态时, 会事先告知各种信息。下面表格列举了 Set-Cookie 的字段值。

<br>

###  NAME=VALUE
赋予 Cookie 的名称和其值(必须项)

<br>

###  expires=DATE	  
Cookie 的有效期(若不明确指定则默认为游览器关闭前为止)


Cookie 的 expires 属性指定游览器可发送 Cookie 的有效期。

当省略 expires 属性时, 其有效期仅限于维持游览器会话(Session)时间段内。这通常限于游览器应用程序被关闭之前。

另外, 一旦 Cookie 从服务器端发送至客户端, 服务器端就不存在可以显示删除 Cookie 的方法。但可以通过覆盖已过期的 Cookie , 实现对客户端 Cookie 的实质性删除操作。

<br>

###  path=PATH	
将服务器上的文件目录作为 Cookie 的适用对象(若不指定则默认文档所在的文件目录)


Cookie 的 path 属性可用于限制指定 Cookie 的发送范围的文件目录。不过另有办法避开这项限制, 看来对其作为安全机制的效果不能报有期待。

<br>

###  domain=域名	
作为 Cookie 适用对象的域名(若不指定则默认为创建 Cookie 的服务器域名)

通过 Cookie 的 domain 属性指定的域名可做到与结尾匹配一致。比如, 当指定 example.com 后, 除 example.com 以外, www.example.com 或 www2.example.com 等都可以发送 Cookie 。

因此, 除了针对具体指定的多个域发送 Cookie 之外, 不指定 domain 属性显得更安全。

<br>

###  Secure	
仅在 HTTPS 安全通信时才会发送 Cookie

Cookie 的 secure 属性用于限制 web 页面仅在 HTTPS 安全连接时, 才可以发送 Cookie 。

发送 Cookie 时, 指定 secure 属性的方法如下所示。


```js
Set-Cokkie: name=VALUE; secure
```

``` 
以上例子仅当在 https://www........(HTTPS)安全连接的情况下才会进行 Cookie 的回收, 也就是说, 即使域名相同, http://www......(HTTP)也不会发生 Cookie 的回收行为。
当省略 secure 属性时, 不论 HTTP 还是 HTTPS , 都会对 Cookie 进行回收。
```

<br>

###  HttpOnly	
加以限制, 使 Cookie 不能被 JavaScript 脚本访问


Cookie 的 HttpOnly 属性是 Cookie 的扩展功能, 它使 JavaScript 脚本无法获得 Cookie 。其主要目的为防止跨站脚本攻击(Cross-sitescripting, XSS)对 Cookie 的信息窃取。

发送指定 HttpOnly 属性的 Cookie 的方法如下所示。


```js
Set-Cookie: name=value; HttpOnly
```

通过上述设置, 通常从 web 页面内还可以对 Cookie 进行读取操作。但使用 JavaScript 的 document.cookie 就无法读取附加 HttpOnly 属性后的 Cookie 的内容了。因此, 也就无法在 XSS 中利用 JavaScript 劫持 Cookie 了。

虽然是独立的扩展功能, 但 Internet Explorer 6 SP1 以上版本等当下的主流游览器都已经支持该扩展了。另外顺带一提, 该扩展并非是为了防止 XSS 而开发的。

<br><br>

### Cookie
服务器接收到的 Cookie 信息    *请求首部字段*
```js
Cookie: status=enable
```

首部字段 Cookie 会告知服务器, 当客户端想获得 HTTP 状态管理支持时, 就会在请求中包含从服务器接受到的 Cookie 。接受到多个 Cookie 时, 同样可以以多个 Cookie 形式发送。

<br><br>

### 其他首部字段
HTTP 首部字段是可以自行扩展的。所以在 Web 服务器和游览器的应用上, 会出现各种非标准的首部字段。

下面是一些比较常用的首部字段

<br>

### X-Frame-Options
```js
X-Frame-Options: DENY
```

首部字段 X-Frame-Options 属于 HTTP 响应首部, 用于控制网站内容在其他 web 网站的 Frame 标签内显示问题。其主要目的是为了防止点击劫持(clickjacking)攻击。

首部字段 X-Frame-Options 有以下两个可指定的字段值。

<br>

**DENY**  
拒绝

<br>

**SAMEORIGIN**  
仅同源域名下的页面(Top-level-browsing-context)匹配时许可。

支持该首部字段的游览器有: 

Internet Explorer 8、Firefox 3.6.9+、Chrome 4.1.249.1042+、Safari 4+ 和 Opera 10.50+ 等。
现在主流的游览器都已经支持。

能在所有的 web 服务端预先设定好 X-Frame-Options 字段值是最理想的状态。 当然版本不支持的以及其不放心时可以参考这篇文章

<br><br>

### X-XSS-Protection
```js
X-XSS-Protection: 1
```

首部字段 X-XSS-Protection 属于 HTTP 响应首部, 它是针对跨站脚本攻击(XSS)的一种对策, 用于控制游览器 XSS 防护机制的开关。
首部字段 X-XSS-Protection 可指定的字段值如下: 

- 0: 将 XSS 过滤设置成无效状态
- 1: 将 XSS 过滤设置成有效状态

<br><br>

### DNT
```js
DNT: 1
```

首部字段 DNT 属于HTTP 请求首部, 其中 DNT 是 Do Not Track 的简称, 意为拒绝个人信息被手机, 是表示拒绝被精准广告追踪的一种方法。
首部字段 DNT 可指定的字段值如下。

- 0: 同意被追踪
- 1: 拒绝被追踪

由于首部字段 DNT 的功能具备有效性, 所以 web 服务器需要对 DNT 做出对应的支持。

<br><br>

### P3P
```js
P3P: CP="CAO DSP LAW CURa ADMa DEVa TAIa PSAa PSDa IVAa IVDa OUR BUS IND UNI COM NAV INT"
```

首部字段 P3P 属于HTTP响应首部, 通过利用P3P

(The Platform for Privacy Preferences, 在线隐私偏好平台)

技术, 可以让Web网站上的个人隐私变成种仅供程序可理解的形式, 以达到保护用户隐私的
目的。

要进行 P3P的设定, 需按以下步骤进行。

- 步骤一: 创建 P3P 隐私
- 步骤二: 创建 P3P 隐私对照文件后, 保存命名在 /w3c/p3p.xml
- 步骤三: 从 P3P 隐私中新建 Compact policies 后, 输出到 HTTP 响应中

https://www.w3.org/TR/P3P/