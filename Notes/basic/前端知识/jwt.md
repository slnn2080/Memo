# JWT: Json Web Token

### 在没有jwt的时候有什么样的问题?
我们在web里面使用的网络通信协议都是http, 它有一个问题 就是没有状态, 我们不能保存用户的信息

比如下面中 浏览器登录成功后 服务器会给我们响应 登录成功 但是为了避免在以后客户端发起请求的时候 服务器又不知道这次请求的是谁了

我们在响应的时候 服务器会响应一个东西交给浏览器进行保存 这个东西能够代表客户端用户的身份

那如果我们将 info(用户信息) 直接响应给浏览器 让浏览器进行保存 会怎么样呢?

浏览器下一次的请求的时候 又将info带给服务器, 服务器端看到有这个信息说明该用户是登录过的 **这样合适么?**

<br>

![jwt01](./imgs/jwt01.png)

<br>

### 解答:
不合适, 服务器那边是无法信息这个 info 的, 因为这个info存放在客户端是极其容易被伪造的 无论是存放在cookie中还是LocalStorage中里面

服务器不知道这个info是以前给客户端发的 还是客户端更改之后的 还是客户端压根就没有登录过自己新建的 服务器没有办法识别

以前cookie+session这个做法是可以解决这个问题但是相对的服务器的存储压力就会变大

<br>

### 解决方式
![jwt02](./imgs/jwt02.png)

服务器在给客户端发送信息的时候, 都会带上一个签名, 这个签名是服务器通过算法生成的

它是将 (info + 密钥) 通过一个算法生成一个签名, 然后将 签名和info 一起发送给客户端

<br>

**JWT的签名算法:**  
它会返回一个字符串
```js
const crypto = require('crypto')
function sgin(info, key) {
  return crypto.createHmac('sha256', key).update(info).digest('hex')
}
```

<br>

有了签名后, 我们将 **info.签名** 发送给浏览器, 浏览器进行了保存, 浏览器在下一次请求的时候我们再将  **info.签名** 发送给服务器

服务器会根据info验证这个info是不是之前发送给客户端的
1. 将 **info.签名** 中的info提取出来
2. 使用 想通的密钥 + info再次的生成签名
3. 将 **info.签名** 中的签名提取出来 和 新生成的密钥进行对比

密钥一直保存在服务器端

<br>

这个的话就可以防止客户端伪造和篡改, 这样服务器就不需要开辟任何的存储空间 我们将jwt丢给客户端 让客户端去存, 服务器拿到jwt后再次验证就可以

<br><br>

## jwt: 分布式的存储方案
上面的这种模式就是jwt的模式 只是jwt将上面的模式 更加的标准化了一些

![jwt03](./imgs/jwt03.png)

<br>

- header: json格式的对象 经过base64形成的字符串, 这里记录两个东西 签名算法和标记了整个字符串的类型是jwt
```s
btoa(字符串): 将一个字符串进行base64编码
atob(base64字符串): 将base64字符串转换回字符串
```
- paylod: json格式的对象, 经过base64形成的字符串

- signature: 签名, 将 header 和 payload 连接起来使用header中的算法 + 密钥 得到一个签名, 将该签名经过base64形成的字符串

<br>

