# 长列表优化:

## 方式1: 不做响应式
比如会员列表、商品列表之类的, 只是纯粹的数据展示, 不会有任何动态改变的场景下, 就不需要对数据做响应化处理, 可以大大提升渲染速度

<br>

使用 Object.freeze() 冻结一个对象, 该方法冻结的对象不能被修改 如添加属性 删除属性等等
```js
// 表示该属性是不能被修改的 而冻结的对象的configurable就是false
configurable:false
```

<br><br>

## 方式2: 虚拟滚动
如果是大数据很长的列表, 全部渲染的话一次性创建太多的DOM就会非常的卡 这个时候就可以用虚拟滚动

<br>

### 虚拟滚动:
只渲染少部分(含可视区域)区域的内容 然后滚动的时候 不断地替换可视区域的内容 模拟出滚动的效果

<br>

**参考:**  
```
vue-virtual-scroller
vue-virtual-scroll-list
```

原理是监听滚动事件, 动态更新需要显示的 DOM, 并计算出在视图中的位移, 这也意味着在滚动过程需要实时计算, 有一定成本, **所以如果数据量不是很大的情况下, 用普通的滚动就行**

<br><br>

## 方式3: v-for 遍历避免同时使用 v-if

### 在 Vue2 中  
v-for 优先级更高, 所以编译过程中会把列表元素全部遍历生成虚拟 DOM, 再来通过 v-if 判断符合条件的才渲染, 就会造成性能的浪费, 因为我们希望的是不符合条件的虚拟 DOM都不要生成

<br>

### 在 Vue3 中
v-if 的优先级更高, 就意味着当判断条件是 v-for 遍历的列表中的属性的话, v-if 是拿不到的

<br><br>

## 方式4: 列表使用唯一 key

<br><br>

## 方式5: 使用 v-show 复用 DOM

<br><br>

# 待整理:
数据量较大且无法使用分页方式来加载的列表。比如淘宝的商品列表页,一次请求10个商品, 一次请求10个商品和50个商品数据返回所需要的时间相差不大。但是却会多出4次的接口请求, 造成资源浪费。

上面说了很多的优化方案 其实还有 这个部分我们整理下 虚拟列表 和 分片渲染 的方案