# JS
一种运行在客户端的脚本语言(script脚本意思) 脚本语言不需要编译, 运行过程中由js解释器来逐行来进行解释并执行

<br><br>

## JS能做的事情: 
- 表单的动态校验(密码强度检测)
- 网页特效
- 服务器开发(Node.js)
- 桌面程序(Electron)
- APP(Cordova)
- 控件硬件-物联网(Ruff)
- 游戏开发(cocosd.js)

<br>

## 浏览器执行JS简介
浏览器分为两个部分, 渲染引擎 和 JS引擎

<br>

### 渲染引擎: 
用来解析 HTML CSS 俗称 **内核**, 比如chrome浏览器的 blink 老版本的 webkit

<br>

### JS引擎: 
也称为JS解释器, 用来读取网页中的js代码, 对其处理后运行, 比如chrome浏览器的v8  
浏览器本身并不会执行js代码, 而是通过内置js引擎(解析器)来执行js代码,

js引擎执行代码时逐行解释每一句源码转换为机器语言, 然后由计算机去执行 所以js语言归为脚本语言, 会逐行解释执行

<br><br>

## 解释型语言 & 编译型语言
计算机是不能直接理解任何 除 机器语言以外的语言, 所以必须要把程序员所写的程序语言翻译成机器语言才能执行程序, 程序语言翻译成机器语言的工具, 被称为 **翻译器**  

```
编程语言 -> 翻译器 -> 机器语言(二进制)
```

<br>

### 翻译器翻译的方式有两种: 
- 一种是编译(java)
- 一种是解释(js)

两种方式之间的区别在于翻译的 **时间点** 不同

编译器 在代码执行之前进行编译, 生成中间代码文件 比如 .class字节码文件  
解释器 是在运行时进行即时解释, 并立即执行 (当编译器以解释方式运行的时候, 也称之为解释器)

- 编译语言: 先把所有的菜做好, 才能上桌吃饭
- 解释语言: 好比吃火锅, 边吃边涮, 同时进行

<br><br>

# 标识符 关键字 保留字

### 标识符 (不能是关键字 或 保留字): 
就是指开发人员为 变量 属性 函数 参数 **取的名字**  

<br>

### 关键字: 
是指js本身已经使用了的单词 不能再用他们充当 变量名 方法名 比如
``` 
break case catch continue default delete do else ...
```

<br>

### 保留字: 
预留的关键字, 意思是现在虽然还不是关键字, 但是未来可能会成为关键字, 所以同样不能使用他们当 变量名 或 方法名

``` 
boolean byte char class const debugger double enum export
fimal float goto ...
```

<br><br>

# 表达式 和 返回值

### 表达式: 
是由数字 运算符 变量等组成的式子 以能求得数值的有意义排列方法所得的组合

<br>

### 返回值: 
表达式 最终都会有一个结果, 返回给我们, 我们称为返回值  
等式的右边表达式计算完毕把返回值给左边

<br><br>

# JS的组成
- ES5
- DOM
- BOM

<br><br>

# 变量
变量就是一个装东西的盒子

变量是用于存放数据的容器, 我们通过变量名来获取数据, 修改数据

变量可以保存字面量而且变量的值是可以任意改变的 变量可以让我们的数据变得更加方便 所以在开发中我们都是通过变量去保存一个字面量

<br>

### 变量本质: 
变量是程序在内存中申请的一块用来存放数据的空间, 每次创建变量都会创建一个空间 比如去酒店住, 空间就相当于房间, 房间号相当于变量名

<br>

### 变量的使用: 
声明变量 和 为变量赋值

<br>

### 声明变量 & 赋值: 
在js中使用 var关键字 来声明一个变量 variable 使用关键字声明变量后, 计算机会自动为变量分配一个内存空间
```js
// 声明一个变量但是没有值
var a;

// 给a赋值
a = 123;
```

<br>

### 变量的初始化: 
声明一个变量的同时赋值 叫做变量的初始化

```js
// 或者在声明变量的同时赋值  
var b = 789;
```
很多情况下对于单纯的数字来讲 没办法知道它所表达的含义是什么 所以可以通过变量对字面量进行描述

<br>

### 变量的修改(更新): 
一个变量被重新赋值后, 它原有的值就会被覆盖, **以最后一次的为准**   
本质是在原有的空间里修改, 不会新创建变量(房间)

<br>

### 声明多个变量: 
我们在声明多个变量的时候 会使用let等关键字 同时 **多个变量之间使用逗号连接**  
```js
let age = 18
   , address = '火影村'
   , gz = 2000;
```

<br>

### 声明变量的特殊情况: 
1. 只声明没有赋值, 结果是: ``undefined``
2. 不声明不赋值, 结果是: ``报错``
3. 不声明直接赋值, 结果是: 会成为全局变量可以使用, **不推荐**  

<br>

### 变量的命名规范: 
在js中所有的可以由我们自主命名的都可以 成为标识符
1. 标识符可以含有 字母 数字 _ $
2. 标识符不能以数字开头
3. 标识符不能是JS中的关键字或者是保留字
4. 标识符一般都采用驼峰命名法
5. 严格区分大小写

<br><br>

# 数据类型: 
在计算机中, 不同的数据所需占用的存储空间是不同的, js里根据该数据类型需要使用的内存大小不同 分为了不同的数据类型 , 充分利用储存空间, 于是定义了不同的数据类型

就比如, 一个瘦的人睡单人床, 一个胖的人睡双人床, 占用的空间大小是不一样的

也就是说 数据都是要占用内存的 我们设置数据类型是为了给对应类型的分配所需内存

<br>

### 变量的数据类型: 
变量是用来存储 值 的所在处, 它们有
- 名字
- 数据类型

变量的数据类型 决定了如何将 代表这些值 的位存储到计算机的内存中

js是一种弱类型或者说动态语言, **这意味着不用提前声明变量的类型**, 在程序运行过程中, 类型会自动确定

也就是说js的变量的数据类型是只有 **程序在运行过程中根据等号右边的值来确定的**  

```js
// 当js看到 = 后是10为 number 类型的时候 才能确定变量num的数据类型是什么
let num = 10;
```

<br>

### js的数据类型分类: 
在js中一共有7种数据类型, 前5个是属于基本数据类型 Object属于引用数据类型

- String      字符串   
- Number      数值
- Boolean     布尔值
- Null        空值
- Undefined   未定义
- Object      对象

<br>

对以往的数据类型总结  USONB  you are so niubility
- u = undefined
- s = string symbol
- o = object
- n = null number
- b = boolean 

<br>

## 数字型: Number
在js中所有的数值都是Number类型包括 整数 和 浮点数(小数)

<br>

### 数字型进制: 
二进制, 八进制, 十六进制

<br>

### 八进制: 
我们程序里面 **数字前面加0**, 表示8进制
每位的取值范围: 0 ~ 7

```js
let num = 010;
console.log(num);
/*
  010 八进制转换为10进制 就是 8
  0 1 2 3 4 5 6 7 当数字为8的时候 该进位了 -> 10

  7 再加1 需要进位 个位变为0 十位为1 所以是10 八进制前面要加0 最后为010
*/

```

<br>

### 十六进制: 
数字的 **前面加0x**, 表示16进制, 
每位的取值范围: 0 ~ 9 - a ~ f

```js
let num = 0x9;
console.log(num);    // 9

num = oxd
console.log(num)    // 13
```

<br>

### js中最小值 和 最大值对应的常量: 
- Number.MAX_VALUE: 1.7976931348623157e+308
- Number.MIN_VALUE: 5e-324

<br>

### 数字型中的三个特殊常量: 
- Infinity: 代表无穷大
- -Infinity: 代表无穷小
- NaN: Not a number 不是一个数字

```js
console.log(Infinity) // Infinity
```

<br>

### Infinity: 
比如Number类型中的最大值 超过了 最大值 则结果就是 Infinity
```js
Number.MAX_VALUE * Number.MAX_VALUE  //最大值x最大值
```

<br>

### 注意: 
Infinity 是一个字面量


<br>

### NaN: 
是一个特殊的数字 表示 Not A Number 表示非数字NaN也是字面量, **也属性数值类型**  

```js
let num = NaN
console.log(typeof num) // "number"
```

<br>

### 浮点数运算运算的问题: 
在js中正数的运算基本可以保证精确 但如果使用js进行浮点数运算可能会得到一个不精确的结果 **千万不要用js进行精确度比较高的运算**, 比如: 钱
```js
var c = 0.1 + 0.2;
console.log(c); // 结果是: 0.30000000000000004
```

<br><br>

## 整型: BigInt
BigInt是一种特殊的 数字类型, **它支持任意长度的整数**  
在对大整数执行数学运算时 以任意精度表示整数的能力尤为重要 使用 BigInt 整数溢出将不再是问题

对于学过其他语言的程序员来说JS中缺少显式整数类型常常令人困惑

许多编程语言支持多种数字类型如浮点型、双精度型、整数型和双精度型 

但JS却不是这样 **在JS中按照 IEEE 754-2008 标准的定义所有数字都以双精度64位浮点格式表示**  

在此标准下无法精确表示的非常大的整数将自动四舍五入. 确切地说 JS 中的 Number类型只能安全地表示 
  
```s
# 16位
-9007199254740991(-(2^53-1)) ~ 9007199254740991(2^53-1)
```

超出此范围的整数值都可能失去精度

该整数大于 JS中的Number类型所能表示的最大整数 因此它被四舍五入的 一旦四舍五入后会损害程序的可靠性和安全性

- Number.MAX_SAFE_INTEGER  常量表示 最大安全整数
- Number.MIN_SAFE_INTEGER  常量表示 最小安全整数

<br>

### 创建BigInt: 字面量类型
在数值的后面追加字母n 来标识该数据为 bigInt 类型 类似 long类型数字后面要追加l是一样的

<br>

```js
let bigNum1 = 12n
let bigNum2 = 33n

console.log(bigNum1 + bigNum2)  // 45n
```


<br>

### ### 创建BigInt: BigInt() 构造函数
参数: 数字 | 数字型字符串, 参数不用手动加n, 直接调用而**不是通过 new 来进行调用**  

```js
let bigNum3 = BigInt("33")
console.log(bigNum3)  // 33n
```

<br>

### 注意下面的情况: 
```js
BigInt("10");  // → 10n	
BigInt(10);    // → 10n	
BigInt(true);  // → 1n


// 无法转换的数据类型和值会引发异常:
BigInt(10.2);   // → RangeError	
BigInt(null);   // → TypeError	
BigInt("abc");  // → SyntaxError


// 可以直接对使用构造函数创建的 BigInt执行算术操作
BigInt(10) * 10n;    // → 100n


// 使用严格相等运算符的操作数时使用构造函数创建的 Bigint与常规 Bigint的处理方式类似
BigInt(true) === 1n;    // → true
```

<br>

### BigInt运算
BigInt类型的数据 只能和 BigInt类型的数据 进行运算
```js
let bigNum = BigInt(1)
let num = 2

console.log(bigNum + num)
// Cannot mix BigInt and other types, use explicit conversions
// 不能混合使用BigInt和其他类型, 使用显式转换
```

<br>

### BigInt进制
BigInt文字也可以用二进制 八进制 十六进制表示
```js
console.log(0b888776666n)
console.log(0x888776666n)
console.log(0o888776666n)
console.log(04888776666n)
```

<br>

### BigInt 与 Number类型之间的比较
**不能使用严格相等运算符将 BigInt与常规数字进行比较因为它们的类型不同:**  
```js
console.log(10n === 10)     // false
console.log(10n == 10)      // true

console.log(typeof 10n)     // bigint
console.log(typeof 10)      // number
```

<br>

### BigInt类型之间的原酸
**除一元加号(+)运算符外** 所有算术运算符都可用于 BigInt
```js
10n + 20n;    // → 30n	
10n - 20n;    // → -10n	
```

```js
+10n;         
// → TypeError: Cannot convert a BigInt value to a number	
```

```js
-10n;         // → -10n	
10n * 20n;    // → 200n	
20n / 10n;    // → 2n	
23n % 10n;    // → 3n	
10n ** 3n;    // → 1000n	

const x = 10n;	
++x;          // → 11n	
--x;          // → 9n
```

不支持一元加号(+)运算符的原因是某些程序可能依赖于 +始终生成 Number的不变量或者抛出异常. 更改+的行为也会破坏 asm.js代码

<br>

### BigInt除法的问题: 
与 BigInt操作数一起使用时算术运算符应该返回 BigInt值 因此除法(/)运算符的结果**会自动向下舍入到最接近的整数**  
**例如:**  
```js
25 / 10;      // → 2.5	
25n / 10n;    // → 2n
```

<br>

### BigInt 和 Number之间的转换
如果希望使用 BigInt和 Number 执行算术计算 首先需要确定应该在哪个类型中执行该操作, **为此只需通过调用 Number()或 BigInt()来转换操作数:**  
```js
BigInt(10) + 10n;    // → 20n	
// or	
10 + Number(10n);    // → 20
```

<br>

### 要点: 
1. 因为隐式类型转换可能丢失信息 **所以不允许在 bigint和 Number 之间进行混合操作**  
```js
let bigNum1 = 12n
console.log(bigNum1 + 1)    
// 报错: Cannot mix BigInt and other types, use explicit conversions
```

2. BigInt不能传递给 Web api 和 内置的 JS 函数 这些函数需要的是一个 Number 类型的数字, 我们传递 BigInt类型的情况下会报错TypeError错误
```js
Math.max(2n, 4n, 6n);    // → TypeError
```

**3. 请注意关系运算符不遵循此规则 如下例所示:**  
```js
10n > 5;    // → true
```

4. 当 Boolean 类型与 BigInt 类型相遇时 BigInt的处理方式与 Number类似  
换句话说只要不是 0n BigInt就被视为 truthy 的值:  (0: false, 1: true)
```js
if (5n) {	
  // 这里代码块将被执行	
}	
if (0n) {	
  // 这里代码块不会执行	
}
```

**5. 排序 BigInts 和 Numbers 数组时不会发生隐式类型转换:**  
```js
const arr = [3n, 4, 2, 1n, 0, -1n];	
arr.sort();    // → [-1n, 0, 1n, 2, 3n, 4]
```

6. 位操作符如 | & << >> 和 ^ 对 Bigint的操作方式与 Number类似
```js
90 | 115;      // → 123	
90n | 115n;    // → 123n	
90n | 115;     // → TypeError
```

<br>

### 扩展: BigDecimal
js中没有这个类 如果需要使用的话 还需要安装对应的js库

**相关的js库有:**  

- Math.js
```
用于 JavaScript 和 Node.js 的扩展数学库。
它具有支持符号计算的灵活表达式解析器, 大量内置函数和常量, 并提供了集成的解决方案来处理不同的数据类型, 例如数字, 大数, 复数, 分数, 单位和矩阵。强大且易于使用。
```

- decimal.js
```
JavaScript 的任意精度的十进制类型。
```

- big.js
```
一个小型, 快速, 易于使用的库, 用于任意精度的十进制算术运算。
```

- bignumber.js
```
一个用于任意精度算术的 JavaScript 库。
```

<br>

# 字符串型 String
在js中的字符串需要使用引号引起来 推荐使用单引号

```js
var str = "hello";
str = "还可以修改已赋值的字面量";
```

<br>

## 字符串转义符 \: 
类似HTML中的特殊符号, 字符串中也有特殊字符, 我们称之为转义符

在字符串中我们可以使用\作为转义字符 当我们想让 一些符号 或者 字母 具有特殊意义的时候 可以用 \ 进行转义

- \":
- \':
- \n:  表示换行
- \t:  表示制表符
- \\:  自己转义自己 是\
- \b:  表示退格符
- \r:  表示回车

```js 
// 字符串转移字符, 都是用 \ 开头 但是这些转义字符写到引号里面
console.log("今天天气\n真不错！！！")
```

<br>

### 获取字符串的长度: 
字符串是由若干字符组成的, 这些字符的数量就是字符串的长度, 通过字符串的属性length可以获取整个字符串的长度
```js
str.length
```

<br>

### 字符串的拼接: 
**数值相加, 字符相连**  

多个字符串之间可以用 + 进行拼接, 拼接前会把与字符串相加的任何类型转为字符换, 再拼接成一个新的字符串

<br>

### 技巧: 
字符串中拼接变量 **引引加加**  
```js
let age = 33
let msg = 'pink老师今年' + age + '岁'
```

<br><br>

# 布尔型: Boolean
布尔值只有两个用来进行逻辑判断

- 真: true
- 假: false

<br>

布尔值在进行加法运算时 
- true  当 1
- false 当 0  

<br>

# Null 空值: 
这个类型的值 只有一个 就是null, null这个值专门用来表示一个为空的对象

<br>

**注意:**  
1. 使用typeof检查null值时会返回object

```js
// 一个声明变量给null值, 里面存的值为空
var x = null;
console.log(x);         //null的值为 null
console.log(typeof x);  //null的对象类型是 Object

let x = null;
console.log(x + 1);     // 1 因为null为空
```

<br>

2. 数字 是可以和 null 进行运算的, null相当于空 or 0
- 1 + null = 1
- 1 - null = 1
- 1 * null = 0
- 1 / null = Infinity

<br>

# Undefined 未定义: 
这个类型的值 只有一个 就是undefined

当我们 **声明一个变量** 但 **不给这个变量**赋值*时它的值就是undefined

```js
let a = undefined;
console.log(a + '123')      //undefined123  拼串
```

<br>

**注意:**  
数字和undefined进行运算的时候 结果会是 NaN

<br>

# 运算符: typeof
可以使用运算符typeof来检查 一个变量 的类型

<br>

## 格式: 
```js
typeof 变量名

console.log(typeof a);
```

<br>

### 返回值: 小写类型字符串

- 检查字符串时: 返回 string
- 检查数字时: 返回 number
- 检查布尔时: 返回 boolean
- 检查null时: 返回 object
- 检查undefined: 返回 undefined

<br><br>

# 字面量
字面量是在源代码中一个固定值的表示法, 通俗来说, 就是字面量表示如何表达这个值

- 数字字面量: 8 9 10
- 字符串字面量: '黑马程序员'
- 布尔值字面量: true false

<br><br>

# 强制的类型转换: 
指将一个数据类型强制转换为其他的数据类型  
类型转换主要指将其他的数据类型转换为 String Number Boolean (5种基本数据类型中的前三种 最后两种是null undefined)

<br>

### 场景: 
使用表单, prompt获取过来的数据默认是字符串类型的, 此时就不能直接简单的进行加法运算, 需要转换变量的数据类型

**经常转换的3种类型:**  
- 转换为 字符串型
- 转换为 数字型
- 转换为 布尔型

<br><br>

## 转换为 String: 

### 方式一: toString(): 
调用 ``目标.toString()`` 方法

<br>

**返回值: 字符串**  
该方法不会改变原变量的类型, **它会将转换的结果返回**  
```js
let num = 1
let res = num.toString()

console.log(typeof num)   // number
console.log(typeof res)   // string

// 可以赋值回去
num = num.toString()
```

<br>

**注意:**  
null和undefined这两个值没有toString()方法如果调用他们的方法会报错

<br>

### 扩展: Number类型数据.toString(进制数)
当我们调用 ``数字.toString(进制数)``, 可以在()中传递一个整数作为参数
它将会把数字转换为指定的进制, 如果不指定则 **默认转换为10进制**  
```js
var a = 255;

// 将数字转换为二进制 11111111
a = a.toString(2);

console.log(a);
console.log(typeof a);
```

<br>

### 扩展: Buffer类型数据.toString("编码规则")
我们也可以调用 ``buf.toString("utf-8")`` 将buf转为utf-8格式的字符串

<br><br>

### 方式二: String(变量)
调用 String() 函数并将被转换的数据作为参数传递给函数  
使用String()函数做强制转换时对于Number和Boolean实际上就是调用的toString()方法 

<br>

**注意:**  
1. 这种方式可以改变 null 和 undefined 这个类型
```js
let data1 = undefined
let data2 = null

data1 = String(data1)
console.log(data1, typeof data1)  // undefined string

data2 = String(data2)
console.log(data2, typeof data2)  // null string
```

2. String() 转换数组时 会去掉[] 数组中原有的元素以逗号的方式进行拼接
```js
// 1维数组 -> 字符串
let arr = [1,2,3]
arr = arr.toString()
console.log(arr)

arr = String(arr)
console.log(arr)    // 1,2,3


// 2维数组 -> 被展开了 成 字符串
let arr2 = [[1,2,3], [4,5,6]]
arr2 = String(arr2)
console.log(arr2)   // 1,2,3,4,5,6


// 利用 split() 再转为 1维数组
let ret = arr2.split(",")
console.log(ret)    // ['1', '2', '3', '4', '5', '6']
```

3. String()不能转换对象 它转换的对象为 [object Object]
```js
let obj = {name: "sam"}
obj = String(obj)
console.log(obj)    // [object Object]
```

<br>

### 方法三: 隐式转换 b = b + ""
利用任何值 和 字符串做加法运算时 都会先把该值转换为字符串然后再进行运算的原理
```js
b = b + "";
```

```js
let arr = [1, 2, 3]
let res = arr + ""
console.log(res)    // 1, 2, 3
```

<br><br>

## 转换为 Number

### 方式1: parseInt方法
该方法会从 **字符串** 中提取 **整数部分**, **并转换为 Number 类型**

<br>

**格式:**  
```js
parseInt("123", [2])
```

<br>

**参数:**  
- 字符串型的字符串
- 数字类型的进制数, 按照指定的进制来解析

```js
let str = "10"
let ret = parseInt(str, 2)
console.log(ret)   // 2

// 因为 10 会看成2进制 解析后展示10进制 2
```


<br>

### 方式2: parseFloat
该方法会从 字符串 中提取 **含有小数部分的数字**, 并转换为 Number 类型

<br>

**格式:**  
```js
parseFloat("12.3")
```

<br>

**参数:**  
- 字符串型的字符串

```js
let str = "123"
let num = parseInt(str)
console.log(num)        // number 123

let str2 = "123.23"
let num2 = parseInt(str2)
console.log(num2)       // number 123 只会提取整数部分
```

<br>

### 注意: 
如果是对 非字符串类型 使用上述方法转换 它会先将 非字符串 先转换为String 然后在使用 parseInt等方法进行处理

```
number类型的123 - > 字符串类型的"123" - > 再通过pareseInt()
```

<br>

如果我们要转换的数字字符串后面的小数位为0时, **则parseFloat方法的转换结果会去掉0**
```js
let str = "12.300"
let numStr = parseFloat(str)
console.log(numStr)  // 12.3
```

<br>

### 技巧: 
可以使用 isNaN() 来对 parseInt() 和 parseFloat() 方法转换的结果做判断 验证得到的值是否合法
```js
let num = parseInt(prompt("请输入一个数字"))

if(isNaN(num)) {
  alert("您输入的数字不合法")
} else {
  console.log(num)
}
```

<br>

### 扩展: Number类型数据.toPrecision
指定 给定的Number类型数据 的精度 (包含整数为 和 小数位), 也可以理解为 **整数和小数一共保留多少位**  

<br>

**格式:**  
```js
num.toPrecision(精度)
```

<br>

**参数:**  
number类型 1 和 21 之间的整数值

<br>

**返回值:**  
字符串类型 需要定义变量来接收结果    
toPrecision 方法会根据指定的精度进行四舍五入, 并返回一个字符串表示

```js
let num = "12.3323232"
let strNum = num.toPrecision(2)

console.log(strNum) // 12
```

<br>

### 扩展: Number类型数据.toFixed
保留 给定数字的 指定小数位

toFixed() 方法可把 Number 四舍五入为指定小数位数的数字

**格式:**  
```js
num.toFixed(指明要保留几位小数)
```

<br>

**参数:**  
表示要保留的小数位数, 0 - 20 之间的整数值, 如果省略 则默认保留 0 位小数 返回整数形式的字符串

<br>

**返回值:**  
字符串类型 需要定义变量来接收结果

```js
let number = 3.14159;

console.log(number.toFixed());    // 输出: 3
console.log(number.toFixed(2));   // 输出: 3.14
console.log(number.toFixed(4));   // 输出: 3.1416

let integer = 10;

console.log(integer.toFixed());     // 输出: 10
console.log(integer.toFixed(2));    // 输出: 10.00
```

<br>

**注意:**  
- 如果 我们指明要保留的小数位为3位, 但实际的小数位只有1位, 当实际的小数位 不足 指定的小数位时, 则补0

- 如果 我们指明要保留的小数位为3位, 但实际的小数位有4位, 当实际的小数位 大于 指定的小数位时, 则进行四舍五入

<br><br>

## 问题: toFixed带来的问题
toFixed() 方法在进行四舍五入时可能会产生一些不准确的结果，这是因为 toFixed() 方法在处理浮点数时，实际上使用的是舍入到最近的偶数（银行家舍入）策略，而不是标准的四舍五入。这种舍入策略是为了在大量运算时减小累积误差

toFixed是天坑中的巨坑, 下面的四舍五入的结果让人迷惑
```js
// 四舍五入 错误: 2.55 四舍五入保留1位小数 变成 2.5
2.55.toFixed(1)  // 2.5

// 四舍五入 正常: 2.45 四舍五入保留1位小数 变成 2.5
2.45.toFixed(1)  // 2.5

// 四舍五入 错误
3.55.toFixed(1)  // 3.5

// 四舍五入 正常
1.55.toFixed(1)  // 1.6
```

<br>

### 为什么?
我们都知道在计算机中小数不精确 这里面的不精确它有3个层面
1. 存储
2. 运算
3. 显示

<br>

### 存储: 不精确
我们10进制的小数在转换为2进制之后, 可能得到无限循环的2进制数
```js
0.2.toString(2)
'0.001100110011001100110011001100110011001100110011001101'
```

<br>

0.2是有限不循环的小数 变成二进制之后就变成无限循环的小数了, **这里就涉及到10进制和2进制之间小数部分是如何转换的**

现在是无限不循环了 但是计算机又存不下无限的东西 **所以它只能给我们截断存储**

这里面的截断还不仅仅是直接给我们舍去 这里面的截断是与规则的

<br>

**截断规则:**  
```s
# 0.2 的2进制表示
           ↓
0.00110011 0011
``` 
如果我们在空格的位置截断, 当空格后面的打头是0的时候, 空格后面的部分就截断了, 保留空格前面的部分0.00110011

保留的这个部分一定比0.2更小 因为它舍去了一部分

<br>

如果是在面的位置截断的话
```s
            ↓
0.001100110 011
```

当空格后面的打头是1的时候, 空格前面的一位进1后 然后再舍去后面的部分, 保留0.001100111部分
```s
            后面舍去
            ↓
0.001100111 11
          ↑
          进1
```

这样我们保留的数字一定比0.2大了一些

回头我们再看看0.2的截断情况, 下面就是上述的第二种情况
```js
0.2.toString(2)

// 前面都是0011
'0.001100110011001100110011001100110011001100110011001101'
                                                     ↑
```

所以0.2在计算机保存中是要偏大一点的, 我们可以验证下, 我们能看到结果是比0.2要更加的大一点
```js
// 使用指定的精度 来精确的显示目前存储的二进制 反应到十进制的情况
0.2.toPrecision(100)
'0.2000000000000000111022302462515654042363166809082031250000000000000000000000000000000000000000000000'
```

也就是说有些数字存储起来可能会偏大, 有些数字存储起来可能会偏小 那就看它舍去的位置到底在哪里了

<br>

```js
1.55.toPrecision(20)
'1.5500000000000000444'

3.55.toPrecision(20)
'3.5499999999999998224'
```

我们能到看1.55存储的就偏大一点, 3.55就偏小一点, 上面两个数字的小数部分都是一样的
```js
1.55.toString(2)
'1.1000110011001100110011001100110011001100110011001101'

3.55.toString(2)
'11.10001100110011001100110011001100110011001100110011'
```

但就是因为舍去的位置不一样, 因为计算机里面存储的精度是有限的

- 由于1.55的整数部分是1 只占用了一个精度
- 由于3.55的整数部分是3 只占用了二个精度

所以导致了1.55的小数部分多了一个精度, 3.55小数部分少了一个精度, 因为整数部分和小数部分的总和是一样的 就导致了他们的截断位置不一样

<br>

**思考:**  
所有的小数在计算机中存储都是不精确的么?

有些小数会 有些小数不会
- 0.25的二进制就是精确的
```js
0.25.toString(2)
'0.01'

0.5.toString(2)
'0.1'
```

<br>

**规律:** 
凡是小数可以通过 1 / 2^n 这种表达式得到的小数 它的存储就是精确的

<br>

### 运算: 可能不精确
存储的不精确导致了运算的不精确

但是运算也要单独拿出来看 因为通过运算会出现一些奇怪的现象 比如
0.2是不精确的 0.3也是不精确的 但是它们一加就精确了
```js
0.2 + 0.3 = 0.5

// 0.2的末尾是进1的
0.2.toString(2)
'0.001100110011001100110011001100110011001100110011001101'

0.3.toString(2)
'0.010011001100110011001100110011001100110011001100110011'


```

0.2的存储会多一点点, 0.3的存储会少一点点 它们一相加就抵消了 所以是结果是精确的
```js
0.3.toPrecision(20)
'0.29999999999999998890'

0.2.toPrecision(20)
'0.20000000000000001110'
```

<br>

```js
0.3 - 0.2 = 0.09999999999999998
```

因为0.3少了一点点, 0.2多了一点点 这一相减就更不精确了

这也是导致了运算不精确的原因, 运算它可能会把之前的不精确变为精确 也有可能讲之前的不精确放大变得更加的不精确

<br>

### 显示: 可能不精确
因为很多语言为了经可能的显示一个有意义的值 它会给我们做一些近似处理
```js
// 我们存的可定是不精确的
var a = 0.2
```

但是我们输出a的时候 我们拿到的是一个精确的十进制数0.2, 这里就是做了近似处理 因为计算要是给我们显示'0.20000000000000001110'是不合适的

也就意味着如果我们变量存储的就是0.20000000000000001110, 那我们输出a 也将会是0.2
```js
var a = 0.20000000000000001110
```

这就是在做近似处理

那为什么 0.3 - 0.2 它不给我们做近似处理变成0.1呢? 因为精度损失被放大了 它做不了近似了 它不敢做近似

也就是说如下的情况中 会是true, 因为计算机中存储的2进制都是一样的
```js
// 小数小18位以上
0.20000000000000001110 === 0.199999999999999999
// true

0.20000000000000001110: 0.2
0.199999999999999999: 0.2
```

所以显示又是一层不精确

<br>

**扩展: 银行家算法**  
toFixed的问题网上说是**银行家算法**, 银行家算法就是

1234舍去6789进1 中间的5 分情况来处理

- 情况1: 1234
- 情况3: 5
- 情况2: 6789

如果5放在情况2中 下面进位的情况就变多了 舍去的情况就变少了

资本家为了避免在算利息的时候出现小的误差 然后再多次交易的时候被放大 于是出现了这样的一个算法

<br>

### 解决toFixed的问题
toFixed的问题不是银行家算法 它就是精度问题

```js
// 1.55 进1 的原因: 
1.55.toFixed(1)  // 1.6

// 使用toPrecision将精度放大, 箭头的位置是5于是进1
1.55.toPrecision(20)
    ↓
'1.5500000000000000444'
```

<br>

```js
// 1.45 不进1 的原因: 
1.45.toFixed(1)  // 1.4

// 使用toPrecision将精度放大, 箭头的位置是4于是不进1
1.45.toPrecision(20)
    ↓
'1.4499999999999999556'
```

<br>

### 解决方案
我们可以使用 decimal.js 库

这些库的解决方式就是不再使用数字格式来存储了 使用字符串来存储 然后运算的时候遍历字符串 按照运算规则去运算

<br>

### toFixed & toPrecision 区别: 
**toPrecision(精度):**  
使用指定的精度 来精确的显示目前存储的二进制 反应到十进制的情况

是处理精度, 精度是从左至右 第一个不为0的数开始数起

<br>

**toFixed:**   
是小数点后指定位数取整, 从小数点开始数起。

<br>

当你拿到 1.4000000000000001 这样的数据要展示时, 建议使用 toPrecision 指明12位精度后 在使用 parseFloat 转成数字后再显示, 如下: 
```js
parseFloat(1.4000000000000001.toPrecision(12)) === 1.4 // True 


let num = 1.4000000000000001
let temp = num.toPrecision(12)    // '1.40000000000'

// 后面的0没有了
parseFloat(temp)  // 1.4

```

<br>

**指明精度12的原因:**  
这是一个经验的选择, 一般选12就能解决掉大部分0001和0009问题, 而且大部分情况下也够用了, 如果你需要更精确可以调高。

JavaScript 中的数字表示使用 IEEE 754 浮点数标准, 它具有一定的精度限制, 在这种情况下, 通过指定精度为 12 位, 可以确保字符串中包含足够的有效数字位数, 以准确表示原始数字的精度


<br>

当我们遇到 浮点数的精度的问题的时候 1.4000000000000001 我们可以先通过 num.toPrecision(12) 指定 12

<br>

### 方式二: +(正)
利用一元运算符 + -正号负号的运算方式可以把非Number类型的数据强制转换为Number
```js
var a = "123";
a = +a;
```

<br>

**注意:**  
我们对 '' 空字符串使用 + 转换的时候, **会将空字符串转换为 0**

<br>

### 方式三:  ``- * /``
任何值 - * / 运算时都会自动转换为Number, 所以我们可以用 -0 *1 /1的方式把它们转换为Number
```js
var a = "123";
a = true;
a = false;
a = " ";

a = a - 0;
```

<br>

### **<font color="#C2185">方式四: Number()</font>**
它可以转换任意类型的数据

- []: 转为 数字 是 0
- '': 转为 数字 是 0
- null: 转为 数字 是 0
- 长度为1的数字数组 会被转化为该数字 
- 十六进制也能转化为数字

<br>

**注意: 如果情况无法通过Number()转换为数字**  
- undefined 
- {} 
- 空函数

<br>

### Number()函数的转换规则: 

**使用Number()将: 字符串 -> 数字**  
1. 如果 是纯数字字符串 则 转换为数字
2. 如果 字符串有 非数字内容 则 转换为NaN
3. 如果 字符串中是 空串 或者 全是空格的字符串值 则 转换为0

<br>

**使用Number()将: 布尔类型 -> 数字**  
- true 转成 1
- false 转成 0

<br>

**使用Number()将: Null -> 数字**  
结果是0

<br>

**使用Number()将: undefined -> 数字**  
结果是NaN

<br>

### 注意: 
1. null、空字符串""、空数组[]: 都可被Number() 合法的转为0
2. undefined、空对象{}、空函数等: Number() 的转换结果是NaN

<br><br>

## 转换为 Boolean

### 方法一: !运算
先利用逻辑运算中的 ``!运算`` 来对 非布尔值 进行运算会将会将其 **转化为布尔值**  
再对上述结果 再次进行 ``!运算`` 利用该特点来将 一个其他的数据类型 转换为 布尔值

**格式:**  
```js
!!b
```

```js
let flag = 1
console.log(!flag)    // false
console.log(!!flag)   // true
```

<br>

### 方法二: Boolean()函数
当一个值表示 
- 空 or 否定的值会 转换为false
- 其它的都是true

```s
# 代表 空 否定的值
0 null NaN undefined
```

```js
var a = 123;
a = Boolean(a);         //调用Boolean()函数来将a转换为布尔值

console.log(type a);    // "boolean"
console.log(a);         // true
```

<br>

### 转换规则: 

**数字 -> 布尔:**  
- 除了 0 和 Nan 是false
- 其余的都是true


<br>

**字符串 -> 布尔:**  
- 除了空串是false
- 其余的都是true


<br>

**Null / undefined -> 布尔:**  
- 都是false

<br>

### 注意: 
对象也会转换为true
```js
let obj = {name: "sam"}
if(obj) {
  console.log(obj)
}
```

<br>

# 运算符
运算符也叫作操作符  
通过运算符可以对 一个值 或者 多个值 进行运算并获取运算结果

前面说的 typeof 就是一个运算符, 可以来获得一个值的类型 它会将该值的类型以字符串的形式返回

<br><br>

## 算数运算符: 
- +: 
- -: 可以对两个值进行减法运算并 返回一个值
- *: 可以对两个值进行乘法并 返回一个值
- /: 可以对两个值进行除法并 返回一个值
- %: 取模运算(取余数) 9 % 3 = (9除以3取余数余数为0 结果: 0)

<br>

### 取模运算中的技巧: 
a % b 的时候 如果 a < b 余数就是本身
```js
console.log(3 % 5)  // 3
```

<br>

### 注意: 
1. 对 浮点数 进行算数运算时 会有精度问题
```js
console.log(0.1 + 0.2)  // 0.30000000000000004
console.log(0.1 * 0.2)  // 0.020000000000000004
```

<br>

**原因:**  
我们不管是做什么最终都会转为2进制的语言 小数已经很小了, 还要转换为2进制 让2进制再进行运算 这时候就会有误差 不仅仅是js java也一样

<br>

2. 不能拿着浮点数来进行比较
```js
let num = 0.1 + 0.2
console.log(num == 0.3)     //false
```

<br>

### 要点: 
1. 算数运算符也有优先级 先乘除 后加减, 有小括号先算小括号
2. 当对非Number类型的值进行运算时会将这些值转换为Number然后再运算 (除了字符串的加法)
3. 任何值和NaN做运算都得NaN

4. 注意拼串
```js
// 如果对两个字符串进行加法运算 则会进行拼串
"123"+"456"      //  "123456"
```

<br><br>

# 递增 递减 运算符
如果需要反复给数字变量 添加1 或 减去1, 可以使用 ``++`` ``--`` 运算符来完成  
js中 递增 和 递减 既可以放在变量的前面, 也可以放在变量的后面

- 放在前面时, 称为 **前置** 递增(递减)运算符
- 放在后面时, 称为 **后置** 递增(递减)运算符

<br>

**注意:** 
递增和递减运算符必须和变量配合使用 num++

<br>

### 前置递增运算符
先自加 然后使用新值与其他操作进行运算

相当于原变量自增后的值也就是 **新值**  
```js
++num 
```

**口诀:**  
先自加, 后返回值

<br>

### 后置递增运算符
先使用原值和其他操作进行运算

相当于原变量的值自增前的值 就是**原值**, 先表达式返回原值, 后面变量再自加1, 也就是说变量永远比表达式大1
```js
num++
```

**口诀:**  
先返回原值, 后自加

<br>

### 总结: 
不管是 num++ 还是 ++num 单独使用的时候都是自加1  
但是连在一起使用时, ``num++ + 2`` 该情况下 num++ 代表的就是原值

```js 
let num = 10;
num++;                      // 11
let result = num++ + 2;     // num++所以计算时使用原值 11 + 2 = 13
console.log(result);        // 13

// num++ 单独使用都是自加1, 但是连在一起使用时, num++ + 2  -- >  num++代表的就是原值, 
```

<br>

```js
let a = 10;
let b = a++ + ++a;  // 原值 + 新值 == 10 + 12
console.log(b);     // 22
```

<br>

### 注意: 
当 n 的值为 0 的时候 进行++ 是没有意义的 结果还是0
```js
let num = 0
console.log(num++)  // 0
```

<br><br>

# 比较运算符
两个数据进行比较时所使用的运算符  
比较运算的返回值为布尔类型, 该boolean类型的值会作为比较结果

|运算符|说明|
|:--|:--|
|<|小于|
|>|大于|
|>=|大于等于|
|<=|小于等于|
|==|判等号(会隐式转换)|
|!=|小于|
|<|不等号|
|===|全等(类型必须相同)|
|!==|不全等(类型必须相同)|

<br>

### 总结: 
1. 非数值比较时 会将其**转换为Number类型** 然后再比较
2. 任何值和NaN比较都是false
3. 如果符号两侧的值都是字符串时 **将比较 unicode 编码**  
```js
/*
字符串进行比较的时候 不会将其转换为Number进行比较
而会分别比较字符串中字符的Unicode编码可以用这种方式排序英文名
*/

console.log("a" < "b");
//比较的是字符编码16进制 小a是0061 小b是0062

console.log("abc" < "b"); 
//比较字符编码时是一位一位进行比较abc 先同时比较左侧位 然后比较中间位(右侧没有中间位所以是false) 最后比较最后位 (如果第一位小 那么后面的也不用看了吧)
```

4. 比较中文时没有意义  
**比较两个字符串的数字**可能会得到不可预期的结果 **一定要把一个数字字符串转为Number类型** 就可以正常比较了
```js
console.log("1123457654" < "5");    //正常结果是false

console.log("1123457654" < +"5");   //进行Number转换之后才是true
```

5. 注意 ==
```
比较两个值是否相等如果相等会返回true 否则会返回false
当使用==来比较两个值时 如果值的类型不同则会自动进行类型转换将其转换为相同的类型然后再比较

转换成什么不一定但大部分情况都会转换为数字
```

6. undefined 衍生自 null 所以这两个值做相等判断时会返回true

7. 任何对象转换为boolean值都为true
8. undefined null 对应的boolean值为false
9. == 操作符不会尝试将左右操作数转换为boolean值后再进行比较

10. 如果 一个值为对象 另一个为数字 或 字符串 那么会
  1. 将对象转换为原始值先使用 **valueOf()** 转化为原始值
  2. 不能转换为原始值的再尝试使用 **toString()** 方法转换为原始字符串

<br>

### 场景: 
比如: 网购时的购物车可以填写购买的数量但这时候填写的都是字符串而非数字  
这时候可能限制用户的购物量不能超过20, 不能超过最大库存这时候比较可能就会出现问题

<br><br>

## 扩展: toString 和 valueOf
toString 和 valueOf 解决的是一个引用类型的 显示 和 运算 问题

<br>

### **<font color="#C2185">目标.toString()</font>**  
将一个引用类型的值转换为字符串的形式表示, 默认返回的格式为 ``[object Object]``

我们可以自定义toString()方法还修改字符串的表示形式

<br>

``[1,2,3].toString()`` 返回的是 ``1,2,3`` 这是因为数组的原型重写了toString方法

<br>

```js
let a = {}

// [object Object] 为对象的默认返回值
a.toString() // [object Object]
```

<br>

### **<font color="#C2185">目标.valueOf()</font>**  
返回引用类型的原始值(基本数据类型)

该方法会将目标转换为基本类型, 如果无法转换为基本类型则返回原引用类型

我的理解就是如果不重写valueOf方法 那么引用类型调用的话 就会返回引用类型的本身

```js
let num = 123
console.log(num.valueOf())  // 123 因为可以转换为基本数据类型

let val1 = {name: "sam"}
console.log(val1.valueOf()) 
// 没有办法转换为基本数据类型 所以返回的是 { name: 'sam' }
```

<br>

### 场景:
当我们的引用类型定义了toString和valueOf方法后

<br>

**引用类型 转换为 String:**  
1. toString
2. valueOf

优先调用toString() 如果toString方法中返回了原始值 则将原始值转换成字符串表示, 如果我们toString()方法中返回的不是原始值(是引用类型的值), 那么会再调用valueOf(), 如果valueOf中返回的是原始值则将该原始值转成字符串进行表示

<br>

如果toString和valueOf返回的都不是原始值 就会抛出异常(类型转换的异常)

```js
let a = []
a.toString = function() {
  console.log('toString')
  return []
}

a.valueOf = function() {
  console.log('valueOf')
  return []
}

console.log(String(a))
// 1. toString
// 2. valueOf
// 3. 异常
```

<br>

**引用类型 转换为 Number:**  
1. valueOf
2. toString

优先调用valueOf(), 如果valueOf返回的是原始值, 而且该原始值可以正常转换为Number 就会取valueOf的返回值转换为数值类型

如果不是原始类型值的会调用toString方法 如果toString方法返回的是原始类型的值 则将该原始类型的值转换为Number 

如果都不是则抛出异常

<br>

**引用类型 进行运算的话:**  
会优先调用valueOf方法, 会尝试查看valueOf的返回值, 如果它的返回值是原始值 则拿原始值进行运算, 参考 上面的引用类型转换为Number

<br>

```js
// 对象 和 数字 进行比较
let val1 = {name: "sam"}
let val2 = 123
console.log(val1 > val2)    // false
```

<br>

**执行顺序:**  
1. 先将 val1 进行 valueOf() 转换 得到的是 {name: "sam"} 本身
2. valueOf()转换不了的会进行 toString() 得到的是 [object Object]
3. [object Object]转换为数字 会是 NaN 所以结果就是 NaN

<br>

**注意:**  
当对一个对象执行操作时, JavaScript 引擎会尝试将对象转换为适当的原始值, 以便进行进一步的处理。 

在这种情况下, **JavaScript 会查找对象是否有 valueOf() 方法**  

- 如果有, 则调用该方法以获取原始值。
- 如果没有 valueOf() 方法, JavaScript **会尝试调用 toString() 方法来获取原始值**  

<br>

**解释:**  
解释下什么叫做会先查找对象中是否有valueOf方法
```js
let obj = {
  name: "sam",
  age: 18,
  // 在对象中 自定义valueOf方法
  valueOf: function() {
    console.log("valueOf")
    return this.age
  }
}

let res = obj.valueOf()
console.log(res);
```

大多数情况下, JavaScript 会自动处理对象到原始值的转换, 而不需要显式调用 valueOf() 方法。**valueOf()方法主要用于自定义对象中定义该方法, 以提供对象到原始值的转换逻辑**  

<br><br>

# 逻辑运算符
用来 进行布尔值运算的运算符

|运算符|说明|示例|
|:--|:--|:--|
|``&&``|and, 与操作|``true && false``|
|``\|\|``|or, 或操作|``true \|\| false``|
|``!``|not, 非操作|``!true``|

<br>

**要点:**  
!非运算可以将其他数据类型转换为布尔 !!b

<br>

### 返回值: 
布尔值

<br>

### 场景: 
用于多个条件的判断

<br>

### **<font color="#C2185">与运算: &&</font>**
运算符两侧的结果都为true 结果才是true 只要有一侧是false 结果就是false
```js
3 > 5 && 3 > 2      //false
3 < 5 && 3 > 2      //true
```

<br>

### **<font color="#C2185">或运算: ||</font>**
两侧都为false 结果才是false 只要有一侧为true 结果就是true

```js 
3 > 5 || 3 > 2      // true
3 > 5 || 3 < 2      // false
```

<br>

### **<font color="#C2185">元运算: !</font>**
也叫作取反符, 用来取一个布尔值相反的值, 如: true的相反值就是false

如果对非布尔值进行运算则会将其转化为布尔值让后进行取反 我们可以利用该特点来将一个其他的数据类型转换为布尔值!!b
```js
var b = 10;
b = !b;

console.log(typeof b);      //b = false
console.log(b);             //Boolean
```

<br><br>

## 短路运算(逻辑中断)
短路运算的原理: 当有多个表达式(值)时 多个表达式之间的执行情况

```
表达式1 逻辑运算符 表达式2
```

<br>

### **<font color="#C2185">逻辑与 的短路运算: 表达式1 && 表达式2</font>**
逻辑与运算符用于判断两个条件 **是否同时为真**  

- 如果第一个条件为假(或者可转换为假), 则返回该条件的值, 因为我们已经能判断整个表达式的返回值了 false

- 如果第一个条件为真, 则继续判断第二个条件, 并返回第二个条件的值

```js
123 && 456  // 456
0 && 456  // 0
0 && 1 + 2 && 456*789 // 0 因为0是false后面的就不看了

// 如果有空 或者 否定的为假, 其余的都是真 0 null undefined NaN ''
```

<br>

**技巧:**  
有了你再用

```js
fn && fn()
```

<br>

### **<font color="#C2185">逻辑或 的短路运算: 表达式1 || 表达式2</font>**
逻辑或运算符用于判断两个条件 **是否至少有一个为真**  

- 如果第一个条件为真(或者可转换为真), 则返回该条件的值
- 如果第一个条件为假, 则继续判断第二个条件, 并返回第二个条件的值。

<br>

**技巧:**  
有哪个用哪个

```js
let num = condition || 0
```

<br>

### 练习: 输出num的值就多少
``||``运算是检查操作符两边的表达式 至少有一个为真  
因为左边的表达式满足了 所以 num++ 的运算并不会执行

```js
let num = 0;
console.log(123 || num++);
console.log(num); // 0
```

<br><br>

# 赋值运算符
用来把 数据 赋值给 变量 的运算符

<br>

### 直接赋值: =
可以将符号右侧的值 赋值给 符号左侧的变量

<br>

### 加 减n后 再赋值: += -=
- a += 5 等价于 a = a + 5, a变量增加5
- a -= 5 等价于 a = a - 5, a变量减5


<br>

### 乘, 除, 取模后 再赋值: *= /= %=
- a *= 5 等价于 a = a *, 5a变量乘以5
- a /= 5 等价于 a = a /, 5a变量除以5
- a %= 5 等价于 a = a %, 5a变量除以5取余数  

<br><br>

# 一元运算符
一元运算符是一种**只操作一个数的运算符**  

<br>

## 一元运算符

**递增和递减运算符:**  
- ++: 递增运算符, 将操作数的值增加1。例如: x++ 或 ++x。
- --: 递减运算符, 将操作数的值减少1。例如: x-- 或 --x。

<br>

**正负号运算符:**  
- +: 正号运算符, 保持操作数的正号不变。例如: +x。
- -: 负号运算符, 将操作数的符号取反。例如: -x。

<b>

**逻辑非运算符:**  
- !: 逻辑非运算符, 将操作数的逻辑值取反。例如: !x。

<br>

**位运算符:**  
- ~: 按位取反运算符, 将操作数的二进制表示按位取反。例如: ~x。

<br>

**typeof 运算符:**    
typeof: 返回操作数的数据类型的字符串表示。例如: typeof x。

<br>


**void 运算符:**  
void: 执行给定的表达式, 返回 undefined。例如: void expression。

<br>

### +操作符
可以对一个其他的数据类型(任意值 string boolean 都可以)使用 +, 来将其转换为Number它的原理和Number()函数一样

<br>

### +操作符 规则: 
对于 非Number类型的值先转成Number 然后再运算
```js
//我想通过一元运算符对String类型进行强制Number类型转换
let a = "18";       
a = +a;
console.log(typeof a, a + 1);   // number 19
```

```js
var a = 1 + "2" + 3;
console.log("a=" + a);        //结果是123

var a = 1 + +"2" + 3;
console.log("a=" + a);        //结果是6, 在字符串前添加了 " + "
```
    
负号可以对数字进行负号的取反
```js
let a = -18
console.log(a + 1)      // -17
console.log(-a + 1)     // 19
```

<br><br>

# 运算符的优先级
在js中有一个运算符优先级的表, 在表中越高上则优先级越高就会越优先计算, 如果优先级一样则从左往右计算

|优先级|运算符说明|运算符|
|:--:|:--|:--|
|1|小括号|()||
|2|一元运算符|++ -- !|
|3|算数运算符|先*/%后+-|
|4|关系运算符|> >= < <=|
|5|相等运算符|== != === !==|
|6|逻辑运算符|先&&后\|\||
|7|赋值运算符|=|
|8|逗号运算符|,|


<br>

一元运算符里面 逻辑非 优先级很高　根据逻辑运算符来区分

```js
let c = 2 === '2'       
// ===的优先级比较高, 先看 2 === '2'    c的值是false

let d = !c || b && a
// !的优先级高
```

<br><br>

# 逗号运算符
1. 声明多个变量的时候 可以使用 ``,`` 进行分割
```js
let name = "sam", age = 18
```

2. 函数体使用()来代替的时候 ()中多条语句可以使用 ``,`` 进行分割, 最后一组子句会作为函数的返回值

```js
const test = () => (console.log("test"), 3)
// 3为返回值
const ret = test()
console.log(ret)
```

<br><br>

# 位运算符
位运算符是在数字底层(即表示数字的 32 个数位)进行操作的

ES当中整数有两种类型, 所有的整数字面量默认都是有符号的整数

1. 有符号的整数(正数, 负数)
2. 无符号的正数(只允许正数)

<br>

### 有符号的整数
符号位为最高位

```s
# 符号位
    31                                    0
    ↓                                     ↓
    xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx
```

<br>

- 符号位为 0 表示该二进制数为 正数
- 符号位为 1 表示该二进制数为 负数

<br>

ES中有两种不同的方式存储二进制形式的有符号整数
1. 用于存储负数
2. 用于存储正数

正数是以真二进制形式存储的前 31 位中的每一位都表示 2 的幂

```s
# 二进制数字的位数
4位     3位     2位     1位     0位

2^4     2^3     2^2    2^1     2^0
```

<br>

**比如:**  
```
3 2 1 0
1 1 1 1

2^3 + 2^2 + 2^1 + 2^0

8 + 4 + 2 + 1 = 15
```

<br>

### 技巧: 
先看二进制对应的位数是0还是1 相当于开关 1就是打开开关 0就是关闭开关  
如果是1 那对应的数就是2的几次幂(看在几位) 如果是0 那该位对应的就是0

```js
let num = 0b1010
console.log(num)    // 10

// 10进制的4 对应 2进制的多少
let num = 4;
console.log(num.toString(2));   // 100
```

<br>

### 负数: 
10进制的负数也会存储为二进制代码, 不过采用的形式是二进制补码 在计算机底层我们采用 负数的补码的方式 存储负数
``` 
-18 会使用-18的补码 在底层存储-18
```

<br>

### 二进制补码的步骤有三步
1. 负数-18 去掉负号 找到18对应的二进制表示 - 原码  
例如要计算 -18的二进制补码, 首先要确定 18 的二进制表示 要展示全的32位

2. 将1中拿到的原码 每位依次取反, 即要把 0 替换为 1 , 把 1 替换为 0, 最终拿到反码
3. 在2中取得反码二进制数上加1

```s
# 要确定 -18 的二进制表示首先必须得到 18 的二进制表示如下所示:
0000 0000 0000 0000 0000 0000 0001 0010

# 计算二进制反码
1111 1111 1111 1111 1111 1111 1110 1101

# 在二进制反码上加 1
1111 1111 1111 1111 1111 1111 1110 1101
                                     +1 (各位+1)
1111 1111 1111 1111 1111 1111 1110 1110
```

<br>

### 公式: 
在计算补码时使用了补码的公式 ``(Math.pow(2, 32) + negative18)``。 
这是因为 JavaScript 使用补码表示负数。
```js
var negative18 = -18;
var binaryOriginal = Math.abs(negative18).toString(2); // 原码

/*
  Math.pow(2, 32) - 4294967296 这样是指定幂的最大值
*/
var binaryComplement = (Math.pow(2, 32) + negative18).toString(2); // 补码
var binaryOnesComplement = (Math.pow(2, 32) + negative18 - 1).toString(2); // 反码

console.log(binaryOriginal); // 输出: "10010"
console.log(binaryComplement); // 输出: "11111111111111111111111111101110"
console.log(binaryOnesComplement); // 输出: "11111111111111111111111111101101"
```

<br>

**注意:**  
1. 记住在处理有符号整数时开发者不能访问 31 位
**2. 负数的二进制显示 只是在该数字正数的2进制前加上-号 因为ES在显示负数的二进制的时候 并不以二进制补码的形式显示而是用数字绝对值的标准二进制代码前面加负号的形式输出.例如:**  

```js
num = 4   // 100    二进制的显示
num = -4  // -100   二进制的显示
```

这是为避免访问位 31, 为了简便ECMAScript 用一种简单的方式处理整数使得开发者不必关心它们的用法

<br><br>

## 位运算: NOT ~
位运算 NOT 由否定号(~)表示

位运算 NOT 实质上是: **对数字求负(求反码)然后减1**  

<br>

### 位运算NOT本质就是在求该数的补码: 
1. 把运算数转换成 32 位二进制数字
2. 把二进制数转换成它的二进制反码
3. 把二进制数转换成浮点数

<br>

```js
let num = 25    
console.log(~num)   // -26

1. 00000000000000000000000000011001
2. 11111111111111111111111111100110
3. 结果是-26
```

**用下面的方法也可以得到同样的方法:**  

```js
let num = 18
let num2 = ~18
console.log(num2);  // -19

console.log(~20)    // -21

let num = -18
console.log(~num)   // 17 |  -18 + - = 18, 18 - 1 = 17
```

### 总结: 
按照上面的规律则 
- 一个正数取反的话 则结果为 该正数变成负数 然后-1
- 一个负数取反的话 则结果为 该正数变成正数 然后-1
```
~27 == -27-1
```

<br><br>

## 位运算: AND &
位运算 AND 由(&)表示 

该运算是直接**对数字的二进制形式进行运算**  

<br>

### 规则: 
两个两进制数 进行 & 运算 将两个2进制数每位对齐 依次按位来比较
**找1** 11为1 其它的是0

```s
1 1 0 0   # 数字1中的数位
1 0 1 0   # 数字2中的数位
1 0 0 0   # 结果
```

**比如: 要对数字 25 和 3 进行 AND 运算代码如下所示:**  

```js
let num = 25
console.log(num.toString(2));   // 11001

let num2 = 3
console.log(num2.toString(2));  // 11

let result = 25 & 3
console.log(result);    // 1
console.log(25 & 3)     // 1

11001
00011
00001
```

<br><br>

## 位运算: OR |
位运算 OR 由符号(|)表示

该运算是直接**对数字的二进制形式进行运算**  

**在计算每位时 OR 运算符采用下列规则:**  
**找0** 00为0 其它的是1

```s
1 1 0 0   # 数字1中的数位
1 0 1 0   # 数字2中的数位
1 1 1 0   # 结果
```

**比如: 要对数字 25 和 3 进行 OR (|) 运算代码如下所示:**  

```js
let num = 25
console.log(num.toString(2));   // 11001

let num2 = 3
console.log(num2.toString(2));  // 11

let result = 25 | 3
console.log(result);    // 27

11001
00011
11011 = 16 + 8 + 0 + 2 + 1 = 27
```

<br><br>

## 位运算: XOR ^
位运算 XOR 由符号(^)表示

该运算是直接**对数字的二进制形式进行运算**  

<br>

### 规则: 
**找异**, 每位相比较不一样的为1 一样的为0

比如: 对 25 和 3 进行 XOR 运算代码如下
```js
let num = 25
console.log(num.toString(2));   // 11001

let num2 = 3
console.log(num2.toString(2));  // 11

let result = 25 ^ 3
console.log(result);    // 26

11001
00011
11010 = 16 + 8 + 0 + 2 + 0 = 26
```

<br>

### 思考: 
为什么当布尔类型的值进行 ^ 运算的时候 得到的是数字呢?
```js
let a = true
let b = false

let flag = a ^ b;
console.log(flag)       // 1

a = true = 1
b = false = 0

console.log(1 ^ 0)

0001
0000
0001    // 1
```

<br><br>

## 左移运算: << (左移运算保留数字的符号位)
它把数字中的所有数位向左移动指定的数量 相当于 **扩大n倍**  
```js
25 << 2 == 25 * 2^2
25 << 3 == 25 * 2^3
```

<br>

### 左移使用0补位
在左移数位时数字右边多出 5 个空位.左移运算用 0 填充这些空位使结果成为完整的 32 位数字

<br>

### 注意: 
左移运算保留数字的符号位
例如 如果把 -2 左移 5 位得到的是 -64 而不是 64. **"符号仍然存储在第 32 位中吗?"**  

是的! 不过这在 ECMAScript 后台进行开发者不能直接访问第 32 个数位 即使输出二进制字符串形式的负数显示的也是负号形式 (例如-2 将显示 -10) 

<br><br>

### 有符号右移运算: >>
有符号右移运算符由两个大于号表示(>>) 相当于 **缩小n倍 做除法**  

它把 32 位数字中的所有数位整体右移同时保留该数的符号(正号或负号) 有符号右移运算符恰好与左移运算相反例如把 64 右移 5 位将变为 2

**同样移动数位后会造成空位 这次空位位于数字的左侧但位于符号位之后 ECMAScript 用符号位的值填充这些空位创建完整的数字如下图所示:**  

```js 
num = 64            // 1000000
result = num >> 5   // 0000010

result = 2
```

<br>

### 扩展: 位运算的使用技巧

**位运算符的快速交换值:**  
```js
let a = 5;
let b = 10;

a ^= b;
b ^= a;
a ^= b;

console.log(a); // 输出: 10
console.log(b); // 输出: 5
```

<br>

**位运算的位掩码操作:**  
```js
const READ_PERMISSION = 1; // 0001
const WRITE_PERMISSION = 2; // 0010
const EXECUTE_PERMISSION = 4; // 0100

let userPermission = READ_PERMISSION | WRITE_PERMISSION; // 读取和写入权限

let hasReadPermission = (userPermission & READ_PERMISSION) !== 0; // 检查是否有读取权限
```

<br>

**1. 我们将代表权限的数字设置为 二进制中数位为1(开关打开)的数 如:**  
```js
1:  0000 0001 
2:  0000 0010 
4:  0000 0100 
8:  0000 1000 
16: 0001 0000 
32: 0010 0000
```

2. 如果我们将两个数做 位运算| 则相当于将两个二进制数组装起来 这步对于上面的案例来说 **相当于**将所有的权限存在了数组中 ``[1, 2, 4]``
```js
0000 0001  
0000 0010  |

// 结果:
0000 0011
```

3. 当我们想验证用户是否具有指定的权限时 我们可以拿 步骤2中的结果 和想检验的权限做 位运算&, **相当于**在上述的权限数组中 找某个元素
```js
// 这是步骤2中的结果
0000 0011
0000 0001 &

0000 0001
```

4. 只要是结果不为0 则说明该用户具有该权限

<br>

**位运算的快速判断奇偶数:**  
- 奇数的二进制表示的最后一位为 1
- 偶数的二进制表示的最后一位为 0
```js
let num = 5;
let isEven = (num & 1) === 0; // 判断是否为偶数
```

<br><br>

# 编码
- 在js中想用Unicode编码格式 ``\uxxxx`` (xxxx为4位16进制的编码)
- 在网页中想用Unicode编码就是 ``&#编码;`` (编码为10进制)

<br>

### &编码;
正常是&开头, ;结尾
比如 ``&nbsp;`` 但要输入Unicode编码则要如下, 使用转义字符 ``&#编码;`` 但这里的编码是需要10进制的, 可以打开计算机选择程序员转换 

<br><br>

# 语句
我们的程序是由一条一条语句构成的, 语句是按照自上向下的顺序一条一条执行的, 在JS中我们可以使用{ }来为语句进行分组

同一个{ }中的语句我们称为一组语句, 它们**要么都执行要么都不执行**, 一个{ }中的语句我们也称为一个代码块

<br>

### 代码块: 
```js
{
  alert("");
  console.log("");
  document.write("");
}
```

<br><br>

# 流程控制
在一个程序执行的过程中, 各条代码的执行顺序对程序的结果是有直接影响的, 很多时候我们要通过控制代码的执行顺序来实现我们要完成的功能

<br>

### 简单理解: 
流程控制就是来控制我们的代码按照什么结构顺序来执行

<br>

### 流程控制的三种结构: 
- 顺序结构
- 分支结构
- 循环结构

```
顺序结构        分支结构            循环结构     

顺序执行        条件执行            循环执行
  ↓               ↓ 
  A             判 断                 A   ←
  ↓               ↓                  ↓       ↑
  B           A       B            判 断  →  yes
  ↓           ↓       ↓              ↓
```


<br><br>

## 分支结构
由上到下执行代码的过程中, 根据不同的条件, 执行不同的路径代码

执行代码**多选一**的过程, 从而得到不同的结果

- if语句
- switch语句

<br><br>

## 分支流程控制: if else 相关

### if语句: 
使用条件判断语句可以在执行某个语句之前进行判断, 如果条件成立才会执行语句不成立不执行

```js
if (条件表达式) {
  语句 .....   
}
```

<br>

### 执行思路: 
if语句在执行时会先对条件表达式进行求值判断
- 如果条件表达式的值为true  则执行if后的语句, 
- 如果条件表达式的值为false 则不会执行if后的语句 

<br>

**要点:**  
if语句只能控制紧随其后的语句 如果希望if语句可以控制多条语句 可以将这些语句统一放入代码块中, if语句后的代码块不是必须的 但在开发过程中尽量写上代码块 

```js
if (true)
  alert("你猜我出来么?");

var a = 10;
if (a > 10) {
  alert("a比10大");
  alert("谁也管不了我");
}

var a = 5;

//当想加入多个条件时可以用与运算只有两端同时都是true都满足时才会执行下面的语句
if(a > 10 && a <= 20){
  alert("a大于10并且小于等于20");
}
```

<br>

### if...else语句: 
```js
if (条件表达式) {
  语句...
} else {
  语句...
} 
```

<br>

### 执行思路: 
当该语句执行时会先对我们if后的表达式求值判断
- 如果该值为true  则执行if后的语句
- 如果该值为false 则执行else后的语句

不管是 if 还是 else 执行哪个整个结构后 都会执行完毕
```js
var age = 50;
if (age >= 60) {
  alert("你已经60退休了");
} else {
  alert("你还得继续工作")
}
```

<br>

### if...else if...else语句: 
多分支语句 就是利用多个条件来选择不同的语句执行, 得到不同的结果 **多选1的过程**  
```js
if (条件表达式){
  语句...
} else if (条件表达式) {
  语句...
} else if (条件表达式) {
  语句...
} else {
  语句...
}
```

<br>

### 执行思路: 
当该语句执行时会从上到下依次对条件表达式进行求值判断
- 如果求值结果为true  则执行当前的语句
- 如果求值结果为false 则继续向下判断
- 如果所有的条件都不满足 则执行最后的else语句

该语句中只会有一个代码块被执行 一旦代码块被执行则直接结束语句
```js
var age = 50;
if (age > 100) {
  alert("活着挺没意思的");
} else if (age > 80){
  alert("你也老大不小的了");
} else if (age > 60){
  alert("你退休了");
} else if (age > 30){
  alert("你已经中年了");
} else if (age > 17){
  alert("你已经成年了");
} else {
  alert("你还是个孩子")
}
```

<br><br>

# 三元表达式
二选一的过程

**由三元运算符组成的式子我们称为三元表达式 ? :**  

<br>

### 语法: 
```js
条件表达式 ? 表达式1 : 表达式2
```

<br>

### 执行流程: 
条件运算符在执行时 首先对条件表达式进行求值

- 如果该值为真 则执行 表达式1 并返回执行结果
- 如果该值为假 则执行 表达式2 并返回执行结果

```js
let num = 10;
let result = num > 5 ? '是的' : '不是的';
console.log(result);    // 是的
```

<br>

### 场景: 
动态给变量赋值
```
变量 = 表达式 ? 值1 : 值2
```

<br><br>

## 分支流程控制: switch 相关
switch语句也是多分支语句, 它用于基于不同的条件来执行不同的代码, 当要针对 **变量** 设置一系列的特定值的选项时, 就可以使用switch语句

<br>

### 语法: 
```js
switch(条件表达式){
  case 常量:
       语句...
       //使用break可以来退出switch语句不会向下执行所有的case代码
       break;

  case 常量:
       语句...
       break;

  //如果没有case和switch全等的条件则会执行default后的语句
  default:                
       语句...
       break;
}
```

<br>

### 执行思路: 
在执行时会依次将 case后的表达式的值 和 switch后的条件表达式的值 进行**全等比较**  
- 如果比较结果为true(全等) 则从当前case处开始执行代码
- 如果比较结果为false 则继续向下比较
- 如果所有的比较结果都为false则 只执行default后的语句

<br>

### break关键字: 
如果case结构的最后没有加 break 则会执行下一个case结构体
```js
// 当前case后的代码都会执行, 为了只执行一个case 可以在case后面跟上break 这样可以确保只会执行当前case的语句而不会执行其他的case后的语句
var num = 1;
switch(num){

  //先会看此处case值和switch条件表达式进行全等比较如果全等则输出下面代码
  case 1:                     
    console.log("一");

    //使用break可以来退出switch语句
    break;       

  case 2:
    console.log("二");
}
```

<br>

### return关键字: 
return关键字也可以阻止进入下一个case 

使用return语句是可以阻止程序执行跳转到下一个case的。当return语句被执行时, 它会立即退出当前函数或语句块, 并返回一个值（如果有）。这样做可以终止switch语句的执行并将控制权返回给调用者。

<br>

### 技巧: 
开发时会把 switch(变量) 这么写
```js
// 将 switch 后面的表达式定义为 变量
let num = 3;

switch(num){
  // case后面的值为常量进行匹配
  case 1: 
}
```

<br>

### 练习: 对于成绩大于60分的输出合格, 低于60分的输出不合格
假如写具体的分数的话情况得从60-100都写上太长所以用除以10 变成 10种情况但是这么写的话只对整数才有意义, 所以应该对条件表达式里的结果取整
```js
var score = 60;

// switch(score/10){ ... }  

//利用parseInt来对结果取整
switch(parseInt(score/10)){        

  case 10:                       
  case 9:  
  case 8:  
  case 7:  
  case 6:  
      console.log("合格");
      break;
}
```

<br>

### 练习2: 水果价格查询
创建变量保存用户输入的水果名 将这个变量作为条件表达式 case后面的值写几个不同的水果名称 

弹出不同价格即可, 同样注意每个case之后加上break 以使退出switch语句
都没有就设置default

<br>

**注意:**  
一定要加上引号, 因为是全等匹配

```js
let fruit = prompt("请输入要查询的水果名")

switch(fruit) {
  case "苹果": 
    alert("10元一斤")
    break

  case "香蕉": 
    alert("5元一斤")
    break

  default: 
    alert("没有您查询的结果")
}
```

<br>

### switch语句 和 if else if 区别: 
一般情况下, 他们两个语句可以相互替换的

- switch语句通常在处理case为比较确定值的情况
- if else语句更加的灵活, 常用语范围判断(大于等于某个范围)

switch语句进行条件判断后会直接执行到程序的条件语句, 效率更高, if else语句有几种条件, 就得判断多少次

分支比较少的时候 if else语句的执行效率比switch语句高
分支比较多的时候 switch语句的执行效率比较高 而且结构清晰

<br><br>

# 循环
在程序中, 一组被重复执行的语句称之为循环体, 能否继续重复执行, 取决于循环的终止条件 由循环体 和 循环终止条件 组成的语句 称之为循环语句

<br><br>

## for循环: 
**重复执行某些代码, 通常跟计数有关系 在for循环中为我们提供了专门的位置用来放三个表达式:**  

1. 初始化表达式: 通常用于作为计数器使用
2. 条件表达式: 当不满足条件表达式的时候会**终止循环**  
3. 更新表达式: 每次循环最后执行的代码, 用于**对初始化表达式进行更新**  

<br>

### 语法: 
```js
for (①初始化表达式; ②条件表达式; ④更新表达式){
  ③语句...
}
```

<br>

### 执行顺序: 
① -- ②③④ -- ②③④ -- ②③④ ...

<br>

### 执行流程: 
1. 执行初始化表达式初始化变量 此处只会执行一次
2. 执行条件表达式判断是否执行循环
  - 如果是true 则执行循环体
  - 如果是false 则终止循环
3. 执行更新表达式 更新表达式执行完毕后 继续重复

<br>

### while 和 for 的语法结构对比: 
```js 
// 创建一个10次的while循环
var a = 0;              // 1 初始化表达式初始化一个变量
while (a < 10){         // 2 条件表达式
  document.write(a++);  // 3 更新表达式
}


// 把上面的while循环转换成for循环:
for (var a = 0; i < 10; i++){
  alert(i);
}
```

<br>

### 利用for循环重复执行不同的代码: 
for循环可以重复执行不同的代码, 这主要是因为使用了计数器i的存在, 计数器i在每次循环过程中都会有变化

```js
for(let i=1; i<100; i++){
  console.log('这个人今年'+ i +'岁')
}

for(let i=1; i<=100; i++){
  if (i == 1){
      console.log('1岁了')
  } else if (i == 100){
      console.log('这个人shi掉了')
  }
}
```

<br><br>

## while循环

### 语法: 
```js
while (条件表达式) {
  语句...  // 这里面要做 初始值的更新操作
}
```

<br>

### 执行流程: 
while语句在执行时 **先对条件表达式进行判断, 满足条件后则进入循环**, 执行循环体 循环体执行完毕以后 继续对表达式进行判断

- 如果值为true  则继续执行循环体以此类推
- 如果值为false 则终止循环

```js 
var n = 1;

//像这种将条件表达式写死的true的循环叫做死循环
while (true) {            
  alert("n++");       

  //n等于10的时候再执行break                            
  if (n == 10) {
    break;          
  }
} 
```

<br>

### 创建步骤: 
创建一个循环往往需要三个步骤

1. 创建一个初始化的变量

2. 再在循环中设置一个条件表达式, 满足条件则进入循环

3. 循环体内定义一个更新表达每次更新初始化变量

4. 终止条件 使用break退出循环

```js
// 1. 创建一个初始化的变量
var i = 0;

// 2. 设置条件表达式: i 小于 10 的时候 会进入到循环
while(i < 10){

  // 3. 执行更新初始值
  document.write(i++ + "<br />")
}


let message = prompt('你爱我么?');
while(message !== '我爱你'){
  message = prompt('你爱我么?');
}
```

<br><br>

## do...while循环: 
它是while语句的一个变体, **该循环会先执行一次代码块**   
然后对条件表达式进行判断, 如果条件为真, 就会重复执行循环体, 否则退出循环

<br>

### 语法: 
```js
do {
  循环体语句...
} while (条件表达式)
```

<br>

### 示例: 
```js 
var i = 0;
do{
  document.write(i++ + "<br />")
} while (i < 10) 
```

<br>

### 执行流程: 
1. do...while语句在执行时会先执行循环体
2. 循环体在执行完毕后 再对while后的表达式进行判断
  - 如果结果为true 则继续执行循环体执行完毕继续判断
  - 如果结果为false   则终止

实际上这两个语句类似功能类似
- while是先判断再执行
- do是先执行后判断

do...while可以保证循环体至少执行一次而while不行 

<br><br>

# break 和 continue 和 return

<br>

## 关键字: continue
continnue关键字用于 **立即跳过本次循环**, 继续下一次循环(本次循环中continue之后的代码就会少执行一次), **并不会结束整个循环**  

<br>

### 注意: 
continue只能在循环中使用不能出现在其他的结构中

<br>

### 理解: 
吃5个包子 第3个有虫子, 就扔掉第3个 继续吃第4个第5个包子

```js
for(let i = 1; i <= 5; i++) {

  // 有虫子 第3个包子不要了
  if(i==3){
    continue;
  }

  console.log(`我正在吃第${i}个包子`)
}

// 当i为3时, 会跳出本次循环的所有内容 不会输出console语句, 会直接跳到i为4
```

<br>

### 练习: 求1 - 100之间, 除了能被7整除之外的整数和
```js
let sum = 0;

for(let i = 0; i <= 100; i++){

  // 跳出这个部分
  if (i % 7 == 0){
    continue;
  }
  sum += i;
}
console.log(sum);
```

<br><br>

## 关键字: break
break关键字可以立刻退出最近的循环语句 强制执行循环后面的语句, 退出整个循环

<br>

**注意:**   
- 不能用于if
- break和continue语句只在循环和switch语句中使用

<br>

### 理解: 
吃5个包子 吃到第3个发现里面有 半个虫子, 剩下的都不吃了

```js
for(let i = 0; i <= 5; i++){

  if(i == 3){
    break;
  }
  console.log(`我正在吃第${i}个包子`)
}
```

<br><br>

## 关键字: label
不是必须使用 label 可以定义为其它的名字, 作用是给for循环起了一个名字

方便我们使用 break 和 continue 退出label指定的for循环

<br>

### 语法: 
```js
// label为for循环的名字
label: for( ) {

}
```

<br>

### 使用方式: 
```js
if(...) { break label }
if(...) { continue label }
```

<br>

### 示例: 
```js 
// 为这下面的for循环起了一个hello的名字
hello: for(i = 0; i < 5; i++){
  console.log("@外层循环" + i)

  for(j = 0; j < 5; j++){
    //看这里在break后输入了 我们为这个循环创建的名字 hello
    break hello;
    console.log("内层循环" + j)
  }
} 
```

<br><br>

## 关键字: return
不仅可以退出循环, 还能够返回return语句后的值, 同时还可以结束当前的函数体内部的代码

```js
function test() {
  for(let i = 0; i < 5; i++) {
    if(i == 2) return i

    console.log(i)
  }
}

const res = test()
console.log("返回值:", res);  // 2
```

<br><br>

# 数组
数组是指一组数据的集合, 其中的每个数据被称为元素, 在数组中可以存放任意类型的元素, 数组是一种将一组数据存储在单个变量名下的优雅方式

js中目前我们应用最多的都是内建对象和宿主对象

- 内建对象
- 宿主对象
- 自定义对象

而数组就是js中的内建对象给我们提供的

<br>

## 数组(Array)
数组也是一个对象 它和普通的对象功能类似也是用来存储数据的

不同的是普通对象是使用 **字符串作为属性名**, 而数组是使用 **数字来作为索引操作元素的**  

在对象中称之为属性, 在数组中叫元素

<br>

### 索引: 
用来访问数组元素的序号 **(数组下标从0开始)**   
数组的存储性能比普通对象要好 在开发中我们经常使用数组来存储一些数据 

<br><br>

### 数组的创建
js中创建数组有两种方式

1. 利用 new 创建数组
2. 利用数组字面量创建数组

<br><br>

## 创建数组: new Array()
```js
var arr = new Array(number);
```

<br>

**注意:**  
使用 typeof 检查下数组的类型, 会返回object
```js
console.log(typeof arr);    // object
```

<br>

- 创建指定长度的 **空数组**  
如果()中只有一个整数值时, 创建一个长度为该整数值的数组
```js
var arr = new Array(number);
```

- 创建指定元素的数组 **有元素**  
使用构造函数的方式也可以在创建的时候就指定数组中的元素, 可以将要添加的元素作为构造函数的参数来传递用逗号隔开 
```js
// 创建数组时直接向里面添加了3个元素
var arr = new Array(el1, el2, el3);
```

<br>

### 示例: 
```js
let arr = new Array(5)
console.log(arr)    // [ <5 empty items> ]

let arr2 = new Array(1, 2, 3)
console.log(arr2)   // [ 1, 2, 3 ]
```

<br><br>

## 数组的操作

### 添加元素: 
```
数组[索引] = 值
```

```js 
arr[0] = 10;
```

<br>

### 读取元素: 
```
数组[索引];
```

**注意:**  
如果读取不存在的索引他不会报错 而是 **返回undefined** 

<br>

### length属性: 
length属性来获取数组的长度也就是 **元素的总个数**  

**语法:**  
```
数组.length
```

<br>

### 要点: 
对于 **连续的数组** 可以获取数组的长度也就是元素的个数
```js
arr[0] = 10;
arr[1] = 20;
arr[2] = 30;
arr[3] = 40;
console.log(arr.length);    // 4
```

但是对于非连续的数组会获取到最大的索引+1
```js
arr[0] = 10;
arr[1] = 20;
arr[2] = 30;
arr[3] = 40;
arr[10] = 90;
arr[30] = 100;

// [10, 20, 30, 40, empty × 6, 90, empty × 19, 100]
console.log(arr.length);   
``` 

<br>

### 注意: 
非连续的数组 会把中间的地方给你空出来会留地方所以尽量不要写非连续的数组 

<br>

### 修改 length 属性
也可以理解为修改数组的长度

- 如果修改的length 大于 原长度 则多出的部分会空出来
- 如果修改的length 小于 原长度 则多出的元素会被删除

```js
arr.length = 10;
arr.length = 3;
```

所以我们可以通过修改length来删除一些元素

<br>

### 技巧: 向数组的最后一个位置添加元素
```js
数组[数组.length] = 值;

arr[arr.length] = 70;
arr[arr.length] = 80;
arr[arr.length] = 90;
```

因为打印数组的length的值时 比最后元素所处的索引大1 比如最后一个索引是[3] 那么arr.length的值是就是4, 把这个length的值作为索引数的话 就是数组的最后

<br><br>

## 创建数组: 数组的字面量

### 语法: 
```js
var arr = [];
```

<br>

### 数组的初始化: 
使用字面量创建数组时可以在创建时就指定数组中的元素
```js
var arr = [1, 2, 3, 4, 5, 10]
```

<br>

### 数组内元素的类型: 
可以是任意类型

```js
arr = ["hello", 1, true, null, undefined]
```

<br><br>

### 向数组中新增元素: 
可以通过修改length长度 以及 索引号增加数组元素

<br>

## 数组的遍历
所谓的遍历数组就是将数组中所有的元素都取出来
```js
var arr = ["孙悟空", "猪八戒", "沙和尚"];
```

<br>

### 方式1: 利用for循环来遍历数组中的元素
arr.length 可以 **动态监测数组元素的个数**  

<br>

**遍历的思路:**  
数组里面的元素怎么取出来呢?
```js
console.log(arr[0]);
console.log(arr[1]);
console.log(arr[2]);
```

我们看下0123都是索引吧, 都是从0开始的整数吧, 都是有规律的吧 arr是定的 最关键的是获取到索引

```js
for (i = 0; i < 10; i++) {
  //这是10次的for循环0-9的整数是不是跟我们的索引的数字是一样的
  console.log(arr[i]);
}
```

写死了也不好, 假如我在数组中添加或者增减元素时还得同时改变i的值要不 有的输出不出来, 所以写死了不好

我们可以发现 当数组里面有4个元素的时候i < 4, 5个元素的时候i < 5, 所以我们能看出 这小于的是数组的长度, 所以我们要这么写

```js
for(i = 0; i < arr.length; i++){
  console.log(arr[i]);
}
```

<br>

### 方式2: forEach Api
数组的方法一般我们都是使用for循环去遍历数组, js中还为我们提供了一个方法来遍历数组 **这个方法只支持ie8以上的浏览器, 8以及以下的浏览器不兼容** 

<br>

**forEach Api使用方式:**  
```js
forEach(function(value, index, arr) { ... }, this);
```

<br>

- value: 当前正在遍历的元素
- index: 当前正在遍历的元素的索引
- arr: 当前遍历的数组
- this: 回调函数中this指向
  - function - 当中的this为winodw
  - 箭头函数 - 当中的this为window

像这种函数由我们创建但是不由我们调用的我们称为回调函数 浏览器调的回调函数是异步执行

<br>

**返回值:**  
undefined

<br>

```js
let arr = [1,2,3]
let obj = { name: "sam" }

arr.forEach(value => {
  console.log(this)       // window
})

arr.forEach(value => {
  console.log(this)       // {name: "sam"}
}, obj)
```

<br>

### 执行原理: 
我们数组中有几个元素函数就会执行几次每次执行时, 浏览器会将遍历到的元素以实参的形式传递进来我们可以来定义形参来读取这些内容

<br>

### 要点: 
1. forEach() 不可以链式调用
2. forEach() 会改变原数组
3. 数组中的有效值会触发回调 已删除或未初始化的元素会被跳过
4. 回调中的index顺序不会变
```js
// 不会遍历 空元素
let arr = [1, 3, ,7]

arr.forEach(function(value) {
  console.log(value)
})


// 每次循环 index 的顺序不会变 比如循环到第2次 那对应的index2的元素 会触发回调 即使元素被删除导致数组元素的位置发生了变化 那也是删除后的数组的index为2的元素 触发回调, 比如
let arr = ["one", "two", "three", "four"]


// 当元素为two的时候 删除数组中的第一个元素
arr.forEach((value,index,arr) => {
  console.log(value)

  if(value == "two") {

    // 当value=two的是时候 本轮的index为1 下一轮的index为2
    console.log("当前index为", index)   // 1
    arr.shift()
  }
})


["one", "two", "three", "four"]
↓
["two", "three", "four"]

// 也就是说 index 为 2 的时候 元素会是four three则会被跳过
```

4. **forEach() 的退出 只能使用 抛出异常**  

5. 一般情况下 我们都是通过 数组.forEach() 来使用的 如果前面的不是数组的话 就可以使用  
下面的使用方式是因为 this.containers 是node节点 **它身上并没有forEach() 方法 所以用的下面的方式**  

```js
// 让没有forEach方法的node节点 也可以拥有forEach方法
Array.prototype.forEach.call(this.containers, ($container) => {
  this.setSwiper($container)
})
```

6. forEach中使用return无效 forEach中使用return不会报错, 但rerutn并不会生效

<br>

### 技巧: 方法名.call()
它可以传递一个对象 让该对象临时拥有前面指定的方法

<br><br>

## 数组API: 

### **<font color="#C2185">arr.at(index)</font>**  
返回数组中的指定元素

<br>

**参数:**  
索引, 正数从左往右(从0开始) | **负数从右往左(从-1开始)**  

<br>

**返回值:**  
对应元素 如果匹配不到则为 undefined

```js
let arr = [1,2,3]
let item = arr.at(0)
console.log(item)       // 1


let arr = [1,2,3]
let item = arr.at(-1)
console.log(item)       // 3
```

<br>

**兼容性 & 注意点:**  
- ie 和 opera 不行
- node环境下 at方法会报错

<br>

### **<font color="#C2185">arr.concat()</font>** 
用于合并 两个 或 多个数组, 将给定的数组 添加到 arr 数组中

<br>

**参数:**  
数组 或者 值 可以传递多个, 将多个数组或者值合并到一个新数组中, 多个元素之间使用 , 分割

<br>

**返回值:**  
新数组 []

<br>

**注意:**  
该方法属于**浅拷贝** 如果是引用类型的对象 那么引用对象被修改 对于原始数组和新数组之间都是可见的

<br>

连接两个数组: 两个数组中的元素会结合在一起
```js
let arr = [1,2,3]
let arr2 = [4,5,6]
let res = arr.concat(arr2)
console.log(res)    
// [1, 2, 3, 4, 5, 6]
```

<br>

连接的是二维数组
```js
let arr = [1,2,3]
let arr2 = [[4,5,6], ["a", "b", "c"]]
let res = arr.concat(arr2)
console.log(JSON.stringify(res, null, 2))

// [1,2,3, [4,5,6], ["a", "b", "c"]]
```

<br>

### **<font color="#C2185">arr.copyWithin(target[,start[,end]])</font>**
复制数组中的一部分到同数组中的另一个位置 **不会改变原数组的长度**  

- 复制哪部分元素 是通过 start ~ end 来指定的
- 复制到哪里 是通过 target 索引指定的

<br>

**参数:**  
- target: 索引 将数组的一部分复制到哪里
  - 如果是负数 target将从末尾开始计算
  - 如果指定的 target > arr.length 那么不会发生拷贝
  - 如果指定的 target 在 start 之后 那么复制的序列将被修改以符合 arr.length

- start: 开始复制元素的**起始位置** 包含
  - 如果为负数则从末尾开始计算
  - 如果start被忽略则从0开始进行复制

- end: 开始复制元素的**结束位置(不包括这个位置)**  
  - 如果为负数则从末尾开始计算
  - 如果end被忽略该方法将会一直复制到数组结尾

<br>

**返回值:**  
无, 对原数组进行操作

<br>

**示例:**  
```js
let arr = [1, 2, 3, "a", "b", "c"]
arr.copyWithin(0, 3, arr.length)
console.log(arr)
// ['a', 'b', 'c', 'a', 'b', 'c']
```

<br>

**注意:**  
因为数组的长度不会发生变化 那么abc将会覆盖掉原数组当中的元素

<br>

```js
let arr = [1, 2, 3, "a", "b", "c"]
arr.copyWithin(-2)
console.log(arr)
// [1, 2, 3, 'a', 1, 2]
```

<br>

target为-2 则目标为 "b" 所在的位置, 也就是说元素会被复制到 b 所在的位置

start为空 则从0开始复制全部 数组的长度不会发生变化 则只有 "b" "c" 会被替换成 1 2

<br>

```js
[1, 2, 3, 4, 5].copyWithin(0, 3)
// [4, 5, 3, 4, 5]
```

<br>

target为0, 目标位置为1所在的位置, start为3, 则从4开始进行复制将4 5放到1 2的位置 1 2 会被覆盖掉

<br>

**兼容性:**  
ie不支持

<br>

### **<font color="#C2185">arr.entries()</font>**  
返回一个迭代器对象, 该迭代器对象可以使用 for...of 来进行遍历

该迭代器包含数组中每个索引处的键值对, 每个键值对都表示为一个数组, 包含两个元素: 索引和对应的值

```js
[[index, value], [index, value]]
```

<br>

**遍历示例:**  
```js
let arr = [1, 2, 3, "a", "b", "c"]
const iterator = arr.entries()


for (let entry of iterator) {
  console.log(entry)
}


for (let [index, value] of iterator) {
  console.log(index, value)
}
```

<br>

**<font color="#C2185B">iterator.next()</font>**  
可以获取可迭代对象中的一个 [index, value] 也就是entry

```js
console.log(iterator.next())
// {value: Array(2), done: false

console.log(iterator.next().value)
// [0, "a"]
```


<br>

**返回值:**  
返回的是一个对象
```js
{
  value: [index, value]   // 类型数组
  done: boolean
}
```

- value: 就是封装在迭代器对象中的 [index,value]
- done: 用于指示迭代器是否完成 只有获取不到数据了才是 true
true代表已经完成迭代

<br>

**注意:**  
```js
let arr = ["a", "b", "c"]
let iterator = arr.entries()

console.table(iterator.next())
// {value: [0, "a"], done: false}

console.table(iterator.next())
// {value: [1, "b"], done: false}

console.table(iterator.next())
// {value: [2, "c"], done: false}

console.table(iterator.next())
// {done: true}
```

我们上面能看到 数组中只有3个元素 当执行3遍 都是false  
当执行第四遍 也就是 arr.length + 1 的时候 done为true

**当我们使用for i循环迭代器的时候为了保证取出所有的数据 循环次数要定义为arr.length+1**  

<br>

**普通for循环示例:**  
```js
let arr = ["a", "b", "c"]
let iterator = arr.entries()

let newArr = []

for(let i = 0; i < arr.length + 1; i++) {
  // 获取 next 对象
  let _iterator = iterator.next()

  // 可以用来表示 遍历是否完成
  console.log(_iterator.done)

  // _iterator.done == false 的时候才是有值的
  if(_iterator.done != true) {
    newArr[i] = _iterator.value
  }
}

console.log(newArr)
[
  [0, 'a'],
  [1, 'b'],
  [2, 'c']
]
```

<br>

**示例: 二维数组中的数组按小到大的顺序进行排序**  
```js
function sortArr(arr) {
  var goNext = true;
  var entries = arr.entries();
  while (goNext) {
    var result = entries.next();
    if (result.done !== true) {
        result.value[1].sort((a, b) => a - b);

        // 这里修改为 true 是为了能够再次的进入到循环
        goNext = true;
    } else {
        // 当获取不到值了 改为false 就进不去循环了
        goNext = false;
    }
  }
  return arr;
}

var arr = [[1,34],[456,2,3,44,234],[4567,1,4,5,6],[34,78,23,1]];

sortArr(arr);


0:(2) [1, 34]
1:(5) [2, 3, 44, 234, 456]
2:(5) [1, 4, 5, 6, 4567]
3:(4) [1, 23, 34, 78]
```

<br>

### **<font color="#C2185">arr.values()</font>**
返回数组中包含 val 部分的可迭代对象

```js
let arr = [1, 2, 3, "a", "b", "c"]

for (let val of arr.values()) {
  console.log(val)
}
```


<br>

### **<font color="#C2185">arr.keys()</font>**
返回数组中包含 index 部分的可迭代对象

```js
let arr = [1, 2, 3, "a", "b", "c"]

for (let index of arr.keys()) {
  console.log(index)
}
```

<br>

### **<font color="#C2185">arr.every(callback)</font>**
数组中所有的元素都符合条件才会返回 true, 数组中任一一个元素不满足条件则返回 false

<br>

**参数:**  
callback必须返回一个 boolean
```js
(item, index, arr) => { return boolean }
```

<br>

**返回值:**  
Boolean

<br>

**注意:**  
若传入一个空数组, 无论如何都会返回 true

<br>

**示例:**  
检测数组中的所有元素是否都大于 10。
```js
let arr = [12, 54, 9, 130, 44]
let flag = arr.every(item => item > 10)
console.log(flag)   // false
```

<br>

### **<font color="#C2185">arr.some(callback)</font>**
数组中的元素只要有一个元素符合条件 就会返回 true

<br>

**参数:**  
callback必须返回一个 boolean
```js
(item, index, arr) => { return boolean }
```

<br>

**返回值:**  
Boolean

<br>

**注意:**  
若传入一个空数组, 无论如何都会返回 true

```js
let arr = [12, 54, 9, 130, 44]
let flag = arr.some(item => item > 10)
console.log(flag)   // true
```

<br>

**示例:**  
```js
let arr = [];
data.some(function(value) {
  // some方法返回的是布尔值 所以在内部可以这么写
  // 如果用户输入的商品 和 当前产品的名称一样
  if(value.pname === product.value) {

    console.log(value);     // 找到的数据

    // 但是返回的是一个对象, 我们上面定义的函数必须传递进去一个数组
    arr.push(value);

    // 如果找到就会返回true 必须这么写 现在就属于拿到这个数据了
    return true;
  } 
});

// 把拿到的数据渲染到页面中
setData(arr);
```

<br>

### **<font color="#C2185">arr.fill(value[, start[, end]])</font>**
用于将数组的 **指定范围内的元素** 都替换为 *给定的值*

<br>

**参数:**  
- value: 要填充到数组中指定范围的值
- start: 可选, 指定填充开始的索引位置, 默认为 0, 数组的起始位置(包含)
```js
如果start是个负数, 则start = length + start
```

- end: 可选, 指定填充结束的索引位置, 默认为数组的长度 (不包含)
```js
终止索引, 默认值为 this.length
如果end是个负数, 则end = length + end
```

<br>

**返回值:**  
不会修改原数组, 会返回一个修改后的数组

<br>

**注意:**  
arr不能是空数组
```js
// 可以这样
let arr = new Array(7)
const ret = arr.fill("a")
console.log(ret)
```

<br>

**使用单个值填充整个数组:**  
```js
let arr = [1, 2, 3, 4, 5];
arr.fill(0);
console.log(arr);
```

<br>

**使用指定范围和值填充数组:**  

```js
let arr = [1, 2, 3, 4, 5];
arr.fill("a", 1, 4);
console.log(arr);
// [1, "a", "a", "a", 5]
```

<br>

### **<font color="#C2185">arr.filter(callback)</font>**
根据回调函数中返回的boolean 决定是否保留当前进行遍历的元素 将保留的元素 **作为新数组返回**  

<br>

**场景:**  
常用于过滤(删除符合条件元素, 查找符合条件的元素)

<br>

**参数:**  
```js
(item, index, arr) => { return boolean }
```

- true: 条件为true的元素会被保留
- false: 条件为false的元素会被过滤掉

<br>

**返回值:**  
新数组, 如果没有符合条件的元素 则返回空数组

<br>

**示例: 返回大于10的元素**  
```js
let arr = [12, 5, 8, 130, 33]

let res = arr.filter(item => item > 10)
console.log(res)    // [ 12, 130, 33 ]
```

<br>

**示例: 根据输入的信息 返回数组中对应的元素**  
```js
let fruits = ['apple', 'banana', 'grapes', 'mango', 'orange']

const filterItems = query => {
  // 字符串.indexOf() 方法 看看元素中的字符是否包含传入项
  return fruits.filter(item => item.indexOf(query) > -1)
}

let res = filterItems("ap")
console.log(res)    // [ 'apple', 'grapes' ]
```

<br>

### **<font color="#C2185">arr.find(callback)</font>**
根据回调中返回的boolean 返回数组中满足条件的 **第一个元素**  

<br>

**参数:**  
```js
(item, index, arr) => { return boolean }
```

<br>

**返回值:**  
符合条件则 返回 符合条件的**第一个元素**, 否则为 undefined

<br>

**示例:**  
```js
const inventory = [
  {name: 'apples', quantity: 2},
  {name: 'bananas', quantity: 0},
  {name: 'cherries', quantity: 5}
];

let res = inventory.find(item => item.quantity == 2)
console.log(res)    // { name: 'apples', quantity: 2 }
```

<br>

### **<font color="#C2185">arr.findIndex()</font>**
根据回调中返回的boolean 返回数组中满足条件的 **第一个元素所在的index**  

<br>

**返回值:**  
符合条件则 返回 符合条件的**第一个元素的index**, 否则为 -1

<br>

### **<font color="#C2185">arr.includes()</font>**
用来判断一个数组是否包含一个指定的值 

<br>

**参数:**  
1. 指定值
2. fromIndex, 如果为负值则按升序从 arr.length + fromIndex 开始搜索

<br>

**返回值: boolean**  
- true: 表示包含
- false: 表示不包含

<br>

**注意:**  
1. 0的值将全部视为相等
2. 使用 includes() 比较字符串和字符时是区分大小写的。
3. 如果 fromIndex >= arr.length 则直接返回false 且不搜索该数组

```js
let arr = [1, 2, 3, 4, 5];
const flag = arr.includes(1)
console.log(flag);
```

<br>

### **<font color="#C2185">arr.map(callback)</font>**
通过回调加工数组中的元素, 将元素加工成需要的样子 然后返回 加工后的元素会组成一个新数组

<br>

**参数:**  
```js
(item, index, arr) => { return item }
```

<br>

**返回值:**  
新数组, (一个由原数组每个元素执行回调函数的结果组成的新数组)

<br>

**示例: 使用 map 重新格式化数组中的对象**  
```js
let arr = [
  {key: 1, value: 10},
  {key: 2, value: 20},
  {key: 3, value: 30}
]

let res = arr.map(item => {
  return {
    [item.key]: item.value
  }
})

console.log(res)
// [ { '1': 10 }, { '2': 20 }, { '3': 30 } ]
```

<br>

**示例: 获取html结构中 被选中的表单项**  
```js
let nodes = document.querySelectorAll([type=checkbox]);

let res = [...nodes].map(item => item.value)
```

<br>

### **<font color="#C2185">arr.reduce(callback, 初始值)</font>**
对数组中的每个元素按序执行一个由您提供的 reducer 函数
每一次运行 reducer 会将先前元素的计算结果作为参数传入, 最后将其结果汇总为单个返回值。

<br>

**参数:**  
```js
((pre, curr, index, arr) => { ... }, initVal)
```

<br>

**异常:**  
数组为空且初始值 initialValue 未提供

<br>

**返回值:**  
reduce() 方法会归纳一个结果 这个结果就是返回值, 所以 reduce() 中的回调要 return 一个结果

<br>

**场景:**  
汇总, 多个出来一个

<br>

**注意:**  
第一次执行回调函数时, 不存在 "上一次的计算结果" 如果需要回调函数从数组索引为 0 的元素开始执行, 则需要传递初始值()

否则, 数组索引为 0 的元素将被作为初始值, 这时候迭代器将从第二个元素开始执行(索引为 1 而不是 0)。

<br>

**示例: 求数组所有值的和**  
```js
let arr = [1,2,3,4,5]
let res = arr.reduce((pre, item) => pre + item, 0)
console.log(res)
```

<br>

**示例: 累加对象数组里的值**  
```js
let arr = [
  {name: "sam", price: 400000},
  {name: "erin", price: 250000},
]

let res = arr.reduce((pre, item) => pre + item.price, 0)
console.log(res)
```

<br>

**示例: 将二维数组转化为一维**  
```js
let arr = [[0, 1], [2, 3], [4, 5]]

let res = arr.reduce((pre, item) => {
  // 方式1
  return [...pre, ...item]

  // 方式2
  return pre.concat(item)

}, [])

console.log(res)
// [ 0, 1, 2, 3, 4, 5 ]
```

<br>

**示例: 计算数组中每个元素出现的次数**  
```js
let names = ['Alice', 'Bob', 'Tiff', 'Bruce', 'Alice']

let res = names.reduce((pre, item) => {
  if(pre[item]) {
    pre[item]++
  } else {
    pre[item] = 1
  }

  return pre
}, {})

console.log(res)
```

<br>

**示例: 按属性对 object 分类, 我们按照年龄来分类 将20岁的对象 放在一个数组中**  

```js
let people = [
  { name: 'Alice', age: 21 },
  { name: 'Max', age: 20 },
  { name: 'Jane', age: 20 }
];

{
  20: [xx, xx],
  21: [xx, xx]
}

// 期望的结果
{
  '20': [ 
    { name: 'Max', age: 20 }, 
    { name: 'Jane', age: 20 } 
  ],
  '21': [ 
    { name: 'Alice', age: 21 } 
  ]
}
```

<br>

```js
let people = [
  { name: 'Alice', age: 21 },
  { name: 'Max', age: 20 },
  { name: 'Jane', age: 20 }
];

function groupBy(arr, propName) {
  return arr.reduce(((pre, curr, index) => {

    // 1. 将目标对应的值取出来
    const propVal = curr[propName]
    
    // 2. 我们利用空对象来做 没有的话初始化为数组
    if(!pre[propVal]) {
      pre[propVal] = []
    }

    pre[propVal].push(curr)
    return pre

  }), {})
}

const ret = groupBy(people, "age")
console.log(ret)
```

<br>

**高级应用: 按顺序运行 promise**  
利用了 then() 方法中 return 的传递 形成了 promise链

```js
// 调用p方法会拿到 promise 并拿到resolve出来的结果
function p1(a) {
  return new Promise((resolve, reject) => {
    resolve(a * 5)
  })
}

function p2(a) {
  return new Promise((resolve, reject) => {
    resolve(a * 2)
  })
}

function f3(a) {
  return a * 3
}

function p4(a) {
  return new Promise((resolve, reject) => {
    resolve(a * 4)
  })
}



// 定义 汇总 promise链 的方法
// 参数1: promise的数组
// 参数2: 初始值 作为Promise.resolve 出来的结果
function runPromiseSequence(promiseArr, initVal) {

  // 
  return promiseArr.reduce((promiseResolveInitVal, pFn) => {

    // 参数 promise 是初始值 Promise.resolve的结果 也就是说在它的then中可以拿到 resolve出来的结果

    // 方式1: 直接利用 pFn 来处理参数
    return promiseResolveInitVal.then(pFn)

    // 方式2:
    /*
    return promiseResolveInitVal.then(res => {
      return fn(res)
    })
    */

  // 该值作为 promise初始值 会被下一个promise then中接收
  }, Promise.resolve(initVal))
}

// 将上面的 promise 整理成一个数组
let promiseArr = [p1, p2, f3, p4]

runPromiseSequence(promiseArr, 10).then(res => {
  console.log(res)  // 1200
})
```

<br>

**要点:**  
1. p1 p2 p3 p4 相当于 在定义 then() 中的回调 也就是怎么处理 then() 中的 resolve出来的结果
```js
function test(x) {
  console.log(x)
}

// 下面就是在定义 then() 的回调
runPromise(10).then(test)
runPromise(10).then(x => console.log(x))
```

2. p1 p2 f3 p4 作为then()的回调 相当于在then中renturn, 那么return的结果会被包装为一个promise在下一个then()中接收到 相当于形成了一个 promise链

3. ``Promise.resolve(5).then(res => console.log(res))`` 在它的then中可以拿到 resolve出来的结果

<br>

### **<font color="#C2185">arr.flat(num)</font>**
当数组中有 **嵌套数组** 的时候 用于扁平化数组的操作 (拉平数组)

<br>

**参数:**    
number类型 默认将二维数组拉平
- 默认值, 可以不传, 数组中还有一层数组(2维数组)
- 传入2, 拉平3维数组 如果数组中有两层数组(3维数组)

```js
let arr = [1,2,3,[4,5,6]]
let res = arr.flat()
console.log(res)    // [ 1, 2, 3, 4, 5, 6 ]


// 当有2层嵌套的时候 不传递参数 则[7,8,9]打不开
let arr = [1,2,3,[4,5,6, [7,8,9]]]
let res = arr.flat(2)
console.log(res)
```

<br>

**注意:**  
如果数组中有空项 则会移除掉该空项(不包括空字符串)
```js
let arr = [1,2,,5]
let res = arr.flat()
console.log(res)  // [1,2,5]
```

<br>

### **<font color="#C2185">arr.flatMap(callback)</font>**
该方法只能拉平2维数组 但是具备map的功能

可以在利用map功能的时候 拉平2维数组, 也就是说 在map()的同时直接拉平

<br>

**参数:**  
callback

<br>

**返回值:**  
新数组

<br>

**示例: 将每一个元素加工成一个数组**
```js
let arr = [1,2,3]

let res = arr.map(item => {
  return [item * 2]
})
console.log(res)
// [ [ 2 ], [ 4 ], [ 6 ] ]
```

使用 flatMap() 的效果 结果自动被拉平了
```js
let arr = [1,2,3]

let res = arr.flatMap(item => {
  return [item * 2]
})
console.log(res)
// [ 2, 4, 6 ]
```

<br>

**场景1:**  
我们在使用 str.split() 的时候 会将字符串按照规则切割成数组 那么就会产生下面的效果 结果是一个二维的

需求: 将每一个单词收集到数组中

使用 map() 的效果 结果是一个二维数组
```js
let arr = ["This is a new technology stack", "", "vue"]

// 将每一个单词收集到数组中
let res = arr.map(item => {
  return item.split(" ")
})

console.log(res)

// 结果
[
  [ 'This', 'is', 'a', 'new', 'technology', 'stack' ],
  [ '' ],
  [ 'vue' ]
]
```

使用 flatMap() 的效果 跟上面的map()一样 但是结果会拉平二维数组
```js
let arr = ["This is a new technology stack", "", "vue"]

let res = arr.flatMap(item => {
  return item.split(" ")
})

console.log(res)
// [ 'This', 'is', 'a', 'new', 'technology', 'stack', '', 'vue' ]
```

<br>

### **<font color="#C2185">arr.push()</font>**
将一个或多个元素添加到数组的末尾

<br>

**参数:**  
直接写数组元素

<br>

**返回值:**  
修改原数组, 返回值为该数组的新长度

<br>

**示例: 合并两个数组**
```js
var vegetables = ['parsnip', 'potato'];
var moreVegs = ['celery', 'beetroot'];

// 将第二个数组融合进第一个数组, 因为apply方法参数是一个数组
Array.prototype.push.apply(vegetables, moreVegs);

console.log(vegetables);
// ['parsnip', 'potato', 'celery', 'beetroot']
```

<br>

### **<font color="#C2185">arr.pop()</font>**
从数组中删除最后一个元素, 并返回该元素的值 一次删除一个, **对数组的末尾进行操作**

<br>

**参数:**  
没有参数

<br>

**返回值:**  
删掉的元素, 当数组为空时返回undefined

<br>

**示例:**  
删除掉数组的最后一个元素
```js
const arr = ['Fire', 'Air', 'Water'];

let res = arr.pop()
console.log(res)  // Water
console.log(arr)  // [ 'Fire', 'Air' ]
```

<br>

### **<font color="#C2185">arr.unshift()</font>**
在数组前面 **添加** 多个元素  

<br>

**参数:**  
直接写数组元素

<br>

**返回值:**  
新的长度(可以创建变量 接收这个方法的返回值)

<br>

**是否影响原数组:**  
yes

<br>

### **<font color="#C2185">arr.shift()</font>**
删除数组中的第一个元素, 一次删除一个, **对数组的前面进行操作**

<br>

**参数:**  
没有参数

<br>

**返回值:**  
删掉的元素, 如果数组为空则返回undefined

<br>

**是否影响原数组:**  
yes

<br>

**示例:**  
shift() 方法经常用于 while loop 的环境中 下例中每个循环将要从一个数组中移除下一项元素, 直至它成为空数组
```js
const names = ["Andrew", "Edward", "Paul", "Chris" ,"John"]

let item
while((item = names.shift()) !== undefined) {
  console.log(item)
}
// Andrew, Edward, Paul, Chris, John
```

<br>

### **<font color="#C2185">arr.slice()</font>**
提取指定元素 返回新数组

<br>

**参数:**
- start: 开始索引(包括): 默认值为0
- end: 结束索引(不包括)


可以为负值, 则表示从原数组中的倒数第几个元素开始提取, slice(-2) 表示提取原数组中的倒数第二个元素到最后一个元素(包含最后一个元素)

<br>

**是否影响元素组:**
no

<br>

**返回值:**  
新数组

<br>

**示例:**
```js 
let arr = [1, 3, 5]
let res = arr.slice(0, 2)
console.log(res)    // [ 1, 3 ]
```

利用 slice() 方法 提取数组中的 3 4
```js
let arr = [1,2,3,4,5]

// slice() 方法要求传递的是 开始索引 和 结束索引 元素3 4所处的索引是 -3 和 -2
let res = arr.slice(-3, -1)

console.log(res)    // [3, 4]
```

<br>

**技巧: 提取一个元素**  
两个参数为相邻:  0 1 和 1 2 和 2 3

<br>

### **<font color="#C2185">arr.splice()</font>**
可以删除(插入 替换)数组中的指定元素并将被删除元素作返为回值返回

<br>

**参数:**
1. 开始位置(包含)
2. 删除几个
3. 传递新的元素会插在开始索引的前面

<br>

**返回值:**  
删掉的元素(删除的元素也是在一个数组当中)

<br>

**是否影响原数组:**  
yes


<br>

**技巧:**  
我们经常会从数组中删除一个指定的元素 那就需要知道该元素在数组中的索引值 **所以我们会使用 indexOf() 方法 它会返回该元素的索引值**
```js 
let arr = [1, 3, 5]
let index = arr.indexOf(3)

arr.splice(index, 1)
```

<br>

- 删除指定元素: 第一个参数决定位置 第二个参数为1就是删一个

- 插入元素: 第二个元素为0(代表不删), 第一个元素决定插入位置(前面)
```js
arr.splice(0, 0, "新的元素") 
```    

- 替换元素: 可以删除的同时添加新元素就起到了替换的效果 原位置替换
```js
var result = arr.splice(0,1,"新插入的元素");
console.log(result);
console.log(arr);
```

<br>

### **<font color="#C2185">arr.join()</font>**
将一个数组(或一个类数组对象)的所有元素连接成一个字符串 如果数组只有一个项目, 那么将返回该项目而不使用分隔符

<br>

**参数:**  
指定连接数组元素的符号

- 默认情况下使用 , 进行分割
```js
const arr = ['Fire', 'Air', 'Water'];

let str = arr.join()
console.log(str)    // Fire,Air,Water
```

- 如果传递空字符串则 元素会连接在一起
```js
const arr = ['Fire', 'Air', 'Water'];

let str = arr.join("")
console.log(str)    // FireAirWater
```

<br>

**返回值:**  
字符串, 如果 arr.length == 0, 则返回空字符串。

<br>

**注意:**  
如果一个元素为 **undefined 或 null**, 它会被转换为 **空字符串**

<br>

**技巧:**  
这个方法可以将2维数组 直接转换成字符串
```js
let arr = [[1,2], [3,4]]
let res = arr.join()        // 1,2,3,4
```

<br>

### **<font color="#C2185">arr.toString()</font>**
把数组转换为字符串, 逗号分隔每一项

<br>

**参数:**  
貌似没有

<br>

**返回值:**  
转换后的字符串

<br>

**是否影响原数组:**  
no

```js
let arr = [1, 3, 5]
console.log(arr.toString())
// 1,3,5
```

<br>

### **<font color="#C2185">arr.reverse()</font>**
翻转数组

<br>

**参数:**  
没有

<br>

**返回值:**  
没有

<br>

**是否影响原数组:**  
yes

<br>

**示例:**  
```js
let arr = ["a", "b", "c"]
arr.reverse()
console.log(arr)    // [ 'c', 'b', 'a' ]
```

<br>

**颠倒类数组中的元素, 类数组的要点:**
1. 属性名为 index
2. 对象中要有 length 属性

```js
const a = {
  0: 1, 
  1: 2, 
  2: 3, 
  length: 3
};

Array.prototype.reverse.call(a)
console.log(a)
// { '0': 3, '1': 2, '2': 1, length: 3 }
```

<br>

### **<font color="#C2185">arr.sort()</font>**
排序, 可以用来对数组中的元素进行排序

<br>

**默认顺序:**  
将元素转换为字符串, 然后比较它们的 unicode

<br>

**参数:**  
回调

<br>

**返回值:**  
没有

<br>

**是否影响原数组:**  
yes

<br>
  
**注意:**  
如果是单位还可以, 双位会出现问题 默认按照unicode编码进行排序
```js
let arr = [3,4,2,11,5]      
console.log(arr.sort())
// [ 11, 2, 3, 4, 5 ]

// 11在最前面了 即使对于纯数字的数组排序使用sort排序也会按照unicode排所以对数字, 进行排序时可能会得到错误的结果 
```

<br>

**回调: 定排序规则**  
```js
// 回调函数需要定义两个形参
(a, b) => { return a - b or b - a }
```

浏览器会根据回调函数的返回值来决定元素的顺序
- 如果返回一个大于0的值 则会交换位置
- 如果返回一个小于0的值 则元素位置不变
- 如果返回一个等于0的值 则认为两个元素相等位置也不变

```js
return a-b;     // 升序排列          
return b-a;     // 降序排列
```

<br>

**定义排序规则:**  
```js
var arr = [5,4,2,1,3,6,8,7];
arr.sort(function(a,b) {
  if (a > b) {
    return 1;

  } else if (a < b){
    return -1;
    
  } else {
    return 0;
  })
});

console.log(arr);
```

<br>

**注意: 元素数组为字符串的时候**    
1. 我们可以直接使用 sort()

2. 我们可以按照 字符串的length进行排序 但是 字符一样的时候 没办法 ``(a, b) => a.length - b.length``

<br>

### 扩展: **<font color="#C2185">str1.localeCompare(str2)</font>**
用于比较两个字符串并返回一个表示比较结果的数字

- 如果 str1 < str2 则返回 -1
- 如果 str1 > str2 则返回 1
- 如果相等 则返回0 

```js
arr.sort((a, b) => {
  return b.localeCompare(a)
})
```

<br>

vue
```html
<li>
  <button @click="changeSort(true)">升序</button>
</li>
<li>
  <button @click="changeSort(false)">降序</button>
</li>

<script>
data() {
  return {
    list: ["abc", "zan", "bde", "cdf"],
  }
},

changeSort(flag) {
  flag
    ? this.list.sort((a, b) => a.localeCompare(b))
    : this.list.sort((a, b) => b.localeCompare(a))
} 
<script>
```

<br>

### **<font color="#C2185">arr.indexOf()</font>**
通过给定元素数组中查找给定元素的第一个索引

<br>

**参数:**  
1. 元素(数组中元素的整体)

2. fromIndex: 开始查找的位置
  - 如果 fromIndex >= arr.length 则直接返回 -1
  - 如果 fromIndex 为负数 则从最后一个元素开始也就是 -1的位置

<br>

**注意:**  
如果 fromIndex 为负值 并不改变其查找顺序, 查找顺序仍然是从前向后查询数组

<br>

**返回值:**  
给定元素所在的索引, 如果不存在则返回 -1

<br>

**示例:**  
```js
var arr = [2, 5, 9];

let index = arr.indexOf(2)
console.log(index)  // 0

index = arr.indexOf(7)
console.log(index)  // -1

// 因为从-1的位置开始查找的话 找不到2
index = arr.indexOf(2, -1)
console.log(index)  // -1
```

<br>

**示例: 查找指定元素出现的所有位置**
```js
let arr = ['a', 'b', 'a', 'c', 'a', 'd'];
let subscripts = []

// 先确定 指定元素的起始位置
let index = arr.indexOf("a")

while(index != -1) {
  // 每次先推到下标数组中
  subscripts.push(index)

  // 更新index的位置
  index = arr.indexOf("a", index + 1)
}

console.log(subscripts)
```

<br>

判断一个元素是否在数组里 不在则更新
```js
let veggies = ['potato', 'tomato', 'chillies', 'green-pepper'];

function updateView(arr, item) {

  // 证明元素不在数组中
  if(arr.indexOf(item) == -1) {
    // 元素不在数组中则推进去
    arr.push(item)

  // 证明元素在数组中
  } else if(arr.indexOf(item) > -1) {
    // 元素在数组中则做对应的操作
    console.log("一些操作")
  }
}
```

<br>

### **<font color="#C2185">arr.lastIndexOf()</font>**
通过给定元素数组中查找给定元素的第一个索引, **从后往前查找** (从 fromIndex 开始) 

<br>

**返回值:**  
如果存在返回索引号, 如果不存在则返回-1, 找到的结果索引 还是从左往右数的结果

<br>

**参数:**  
1. 被查找的元素
2. fromIndex 从此为止开始逆向查找 默认值: arr.length - 1

<br>

**示例:**  
```js
var arr = [2, 5, 9, 2]

let index = arr.lastIndexOf(2)
// 因为是从后往前查找 所以首先返回的是最后的2
console.log(index)  // 3
```

<br>

### **<font color="#C2185">Array.from()</font>**
将一个类数组或可迭代对象创建新的数组

<br>

**比如:**  
我们可以传递 节点 或者 字符串 或 可迭代对象(Map Set)

<br>

**参数:**  
1. arrLike
2. mapFn
3. this

<br>

**示例: 将 String 生成数组**  
```js
Array.from('foo');
// [ "f", "o", "o" ]
```

<br>

**示例: 将 Set 转成数组**  
```js
let set = new Set(["a", "b", "c"])
console.log(set)
//  Set(3) { 'a', 'b', 'c' }

set = Array.from(set)
console.log(set)
// [ 'a', 'b', 'c' ]
```

<br>

**示例: 将 Map 转成数组**  
```js
const map = new Map([[1, 2], [2, 4], [4, 8]]);
Array.from(map);
// [[1, 2], [2, 4], [4, 8]]

const mapper = new Map([['1', 'a'], ['2', 'b']]);
Array.from(mapper.values());
// ['a', 'b'];

Array.from(mapper.keys());
// ['1', '2'];
```

<br>

**示例: 数组去重合并**  
```js
function combine() {
  // [ [ 1, 2, 3 ], [ 2, 3, 5 ] ] 整合到一起
  // 方式1:
  let arr = [...arguments].flat()

  // 方式2:
  let arr2 = [...arguments].reduce((pre, item) => {
    return [...pre, ...item]
  }, [])

  // 方式3:
  let arr3 = [].concat.apply([], arguments)

  // 进行去重
  return Array.from(new Set(arr))
}

let arr = [1,2,3]
let arr2 = [2,3,5]

combine(arr, arr2)
```

<br>

### **<font color="#C2185">Array.of()</font>**
根据传入的参数 创建数组

```js
Array.of(7);       // [7]
Array.of(1, 2, 3); // [1, 2, 3]


// 这里和 构造函数 创建数组的方式不同
new Array(7);          // [ , , , , , , ]
```

<br>

### **<font color="#C2185">Array.isArray()</font>**
判断传递的值是否是一个数组

<br>

**返回值:**  
boolean

```js
// 下面的函数调用都返回 true
Array.isArray([]);
Array.isArray([1]);
Array.isArray(new Array());
Array.isArray(new Array('a', 'b', 'c', 'd'))

// 鲜为人知的事实: 其实 Array.prototype 也是一个数组。
Array.isArray(Array.prototype);

// 下面的函数调用都返回 false
Array.isArray();
Array.isArray({});
Array.isArray(null);
Array.isArray(undefined);
Array.isArray(17);
Array.isArray('Array');
Array.isArray(true);
Array.isArray(false);
Array.isArray(new Uint8Array(32))
Array.isArray({ __proto__: Array.prototype });
```

<br>

**注意:**  
当检测 Array 实例时, Array.isArray 优于 instanceof, 因为 Array.isArray 能检测 iframes。

```js
const iframe = document.createElement('iframe');
document.body.appendChild(iframe);
xArray = window.frames[window.frames.length-1].Array;
const arr = new xArray(1,2,3); // [1,2,3]

// Correctly checking for Array
Array.isArray(arr);  // true

// 被认为是有害的, 因为不能通过iframes来工作
arr instanceof Array; // false
```

<br>

### forEach() 和 some() 的区别:
**要点:**  
1. 在 forEach 中 return 不会终止迭代
2. 在 some 中 return true 会终止迭代, some()一定要写return true 意思是找到元素就不要继续遍历了, 如果写false说明没有找到这个元素 会一直往下去找
```js
let arr = ['red', 'green', 'blue', 'pink'];
arr.forEach(function(value) {
  if(value == 'green') {
      console.log('找到了该元素');

      // 想到找元素后就退出 在forEach中return不会终止迭代
      return true;        
  }

  console.log(11);        // 依然输出了3次
})


arr.some(function(value) {
  if(value == 'green') {
      console.log('找到了该元素');

      // 想到找元素后就退出
      // 在some里面遇到return true就会终止遍历 迭代效率更高
      return true;        
  }

  console.log(11);        // 没有输出
})
```

<br>

### 那filter能不能 return true来终止循环呢?
filter和forEach一样的 遇到return true不会终止循环

<br><br>

# 对象
现实生活中, 万物皆对象, **对象是一个具体的事物**, 看得见摸得着的实物

例如 一本书, 一辆汽车, 一个人, 都可以是对象, 一个数据库, 一张网页, 一个与远程服务器的链接也可以是对象

``` 
    非对象           对象
    明星            周星驰

    女朋友          迪丽热巴
    班主任          咱班班主任

    苹果            这个苹果
    手机            小米手机
    游戏            刺激战场

左列都是泛指的    右列才是具体的事物
```

js中的对象, 是一组无序的相关属性 和 方法的集合, 所有的事物都是对象, 例如 字符串, 数值, 数组, 函数等

<br>

### 对象的组成:
对象是由 属性 和 方法 组成的

- 属性: 事物的特征, 在对象中用属性来表示(常用名词)
- 方法: 事物的行为, 在对象中用方法来表示(常用动词)

``` 
大小, 颜色, 重量            打电话, 发短信, 玩游戏

                  手机
属性                       方法
```

<br>

### 为什么需要对象?
保存一个值的时候, 可以使用变量, 保存多个值(一组值)时, 可以使用数组

如果要保存一个人的完整信息(体重 身高 年龄)
```
数组也可以但是结构不清晰, 比如let arr = [128, 134] 这是什么? 
``` 

js中的对象表达结构更清晰, 更强大
```js
let sam = {
  age: 128,
  height: 154,
  sex: "男",
  address: "地址"
}
```

<br>

### 基本数据类型的不足
基本数据的类型都是单一的值, 值和值之间没有任何的联系但如果在js中表示人的信息

比如:姓名 性别 年龄(如果用基本数据类型怎么表示)
```js
var name = "孙悟空"
var gender = "男"
var age = 18
```

基本数据类型也能表示人的信息但是他们之间没有关系互相都是独立的并不是一个整体, 但将这三个数据放到一个塑料袋里就成为一个整体了塑料袋就是对象

装在一起好处: 关系明确方便操作

<br>

**对象属于一种复合的数据类型在对象中可以保存多个不同数据类型的属性**  

<br>

### 对象的分类
**1. 内建对象**  
由ES标准中定义的对象在任何的ES的实现中都可以使用

**比如:**  
Math String Number Boolean Function Object

<br>

**2. 宿主对象**  
由JS的运行环境提供的对象目前来讲主要指由浏览器提供的对象
比如: BOM(浏览器对象模型) DOM(文档对象模型)

<br>

**3. 自定义对象**  
由开发人员自己创建的对象这个最难从这个开始学习

<br><br>

# 变量, 属性, 函数, 方法的区别

<br>

### 变量和属性的相同点:
都是存储数据的

<br>

### 变量和属性的不同点:
**变量:**  
单独声明并赋值 使用的时候直接写变量名 (单独存在)

<br>

**属性:**  
在对象里面 不需要声明, 使用的时候必须是 **对象.属性**

<br>

### 函数和方法的相同点:
都是实现某种功能, 某件事

<br>

### 函数和方法的不同点:
**函数:**  
单独声明, 并且调用的时候 函数名() (单独存在)

<br>

**方法:**  
在对象里面 调用的时候 对象.方法()

<br><br>

## 创建对象: 对象字面量
多个属性或者方法中间用逗号隔开的 方法冒号后面跟的是一个匿名函数

```js
let obj = {
  uname: '张三疯',
  age: 18,
  sex: '男',

  sayHi: function() {
      console.log('hi~');
  }
};
```

**注意:**  
使用对象字面量可以在创建对象时直接指定我们对象中的属性 属性名可以加引号也可以不加 但属性名太怪的话要加上 引号
```js
let obj = {
  'default-name': "sam"
}
```

<br>

### 使用对象:
调用对象的属性, 采取 . 我们理解为 xx的xx属性

- 对象名.属性名
- 对象名[属性名]

调用对象的方法, 别忘记添加小括号

```js
对象名.方法名();
```

<br><br>

## 创建对象: new Object()
构造函数是专门用来创建对象的函数, 使用typeof检查一个对象时会返回object

```js
// 使用new关键字调用的函数是构造函数constructor
var obj = new Object();     // 创建了一个空对象
```

<br>

### 添加属性:

**语法:**  
```js
对象.属性名 = 属性值
```

```js
var obj = new Object();

obj.name = "孙悟空"; 
obj.gender = "男";
obj.age = 18;
```

我们是利用 等号 = 赋值的方法 添加对象的属性和方法 每个属性和方法之间用分号结束

<br>

### 读取对象属性:

**语法:**  
```js
对象.属性名
```

```js
obj.name;
obj.gender;
obj.age;

obj.sayHi();

// 如果读取对象中没有的属性不会报错而是返回undefined
console.log(obj.name);
```

<br>

### 修改属性:

**语法:**  
```js
对象.属性名 = 新值
```

```js
obj.name = "tom";
```

<br>

### 删除对象属性:

**语法:**  
```js
delete obj.name
```

```js
// 如果输出: 
console.log(say)    //会是一个对象
console.log(say())  //会是内部语句产生的结果
  
// 如果函数内部没有return输出时, 会是内部语句产生的结果+undefined 
console.log(say())
```

<br>

## 创建对象: 工厂方法
工厂方法可以大批量创建对象

```js
function creatPerson(name, age, gender){

  // 在函数内部创建一个新的对象
  var obj = new Object();

  // 创建完新的对象后向我们的新对象添加属性 
  obj.name = name;
  obj.age = age;
  obj.gender = gender;

  obj.sayName = function(){
      alert(this.name);
  }

  // 将新的对象返回
  return obj;
}

var obj2 = creatPerson("孙悟空",18,"男");      
var obj3 = creatPerson("白骨精",16,"女");      
var obj4 = creatPerson("蜘蛛精",18,"女"); 
```


<br>

### 利用工厂函数创建的对象的区别
使用工厂方法创建的对象使用的构造函数都是Object, 所以创建的对象都是Object这个类型就导致我们无法区分出不同类型的对象

<br><br>

# 构造函数 与 原型
class的概念是es6的时候提出的, 在以前的时候我们是通过构造函数 和 原型来做的

在典型的OOP的语言中(java), 都存在类的概念, 类就是对象的模板, 对象就是类的实例, 但是在es6之前 js中并没有引入类的概念

es6是2015年的时候发布, 但是目前浏览器的js是es5版本, 大多数高版本的浏览器也支持es6, 但是只不过实现了es6的部分功能

在es6之前, 对象不是基于类创建的, 而是用一种称为构造函数的特殊函数来定义对象和他们的特征

<br>

### 面向对象的主要思路
就是把公共的部分抽取出来 抽成一个类 通过这个类来创建对象

<br>

### 创建对象可以通过以下的3种方式
1. 对象字面量
2. new Object()
3. 自定义构造函数

<br><br>

## 创建对象: 构造函数
通过类的实例化创建对象

前面的两种方式创建对象时, 一次只能创建一个对象, 里面很多的属性和方法是大量相同的, 我们只能复制

因此可以利用函数的方法, 重复这些相同的代码, 我们就把这个函数称为 构造函数

<br>

**为什么是构造函数?**

里面封装的不是普通的代码, 而是对象  
构造函数封装的是一个对象 所以才叫构造函数??????? 卧槽

<br>

### 构造函数:
是一种特殊的函数, **主要用来初始化对象**, 即为对象成员变量赋初始值 

它总与**new运算符一起使用**, 把我们对象里面一些相同的属性 和 方法抽象出来封装到函数里面


<br>

### 要点:
我们只要new Star() 调用函数就创建一个对象
```js
new 类名()
```

<br>

### 书写格式:
- 构造函数的首字母要大写
- 构造函数不需要 return 就可以返回结果

```js
function 构造函数名() {
  // this可以理解当前的意思 表示是哪个对象
  this.属性 = 值;
  this.方法 = function() {};
}

// 使用的使用要用new
let intance = new 构造函数名();
```

<br>

**示例:**   
这里就相当于把公共部分抽取了出来, 然后通过实例来创建对象
```js 
function Star(name, age, sex) {
  this.name = name;
  this.age = age;
  this.sex = sex;

  this.sing = function(sang) {
    console.log(sang)
  }
};

let ldh = new Star('刘德华', 18, '男');
ldh.sing('冰雨');
```


对象的属性值可也是任何的数据类型, 能是对象也能是函数

函数也可以成为对象的属性如果一个函数作为对象的属性来保存 那我们称这个函数是这个**对象的方法**

调用函数就是说调用对象的方法(method), 但是它只是名称上的区别没有其它的区别 

<br>

### new 关键字执行过程:
1. 当我们构造函数遇见new时候 会在内存中创建一个空的对象
2. this都会指向这个空的对象
3. 执行构造函数里面的代码, 给这个空对象添加属性 和 方法
4. 返回这个对象, new的最后会返回这个对象, 所以就不需要return了

<br><br>

## 类中的: 静态成员 实例成员
js的构造函数中可以添加一些成员

**成员:**   
构造函数中的属性和方法我们叫成员, 成员可以添加, 因为构造函数的本质就是一个对象 所以叫做添加成员

可以在构造函数本身上添加, 也可以在构造函数内部的this上添加, 通过这两种方式添加的成员, 就分别称为**静态成员和实例成员**


<br>

### 静态成员:
在构造函数本身添加的成员称为静态成员, 只能由构造函数本身来访问 也就是通过 
```js
类名.属性 = xx
类名.方法 = xx
```

```js
function Person(name, age) {
  this.name = name;
  this.age = age;
  
  // 内部添加静态成员
  Person.address = '中国';
}

let per1 = new Person('sam', 18)
console.log(Person.sex)

// 外部添加静态成员
Person.sex = '男';
```

<br>

### 要点:
**1. 在构造函数外 和 构造函数内部 添加静态成员的区别**  
在构造函数内部 或 外部 都可以给类添加静态成员
- 内部添加: 静态属性和方法时 这种添加方式必须要 new Person() 之后才能调用 不然就是undefined

- 外部添加: 不用 new Person() 就可以直接调用

<br>

**2. 静态成员只能通过构造函数来访问**
```js
console.log(Person.sex)
```

<br>

**3. 不能通过实例对象来访问**
```js
console.log(ldh.sex)   // undefined
```

<br>

### 实例成员:
在构造函数内部创建的对象成员称为实例成员, 只能由实例化的对象来访问

就是构造函数内部通过this添加的成员
```js
this.属性 = xx
this.方法 = xx
``` 

构造函数中的name age sing就是实例成员 他们都是通过this来添加的  添加到new时创建的实例对象身上

<br>

### 要点
1. 实例成员只能通过实例化对象后 通过实例化的对象来访问
```js
let ldh = new Star("刘德华", 18, "冰雨")
console.log(ldh.name)
```

2. 实例成员不能通过构造函数来访问
```js
console.log(Star.name)     // undefined
```

<br>

### 在构造函数(类)中 给实例对象添加 固定死的数据
es5
```js
function Father() {
  this.name = "张三"
}
```

es6
```js
class Father {
  name = "张三"
}
```

<br>

### 在构造函数(类)中 给实例对象添加 动态数据
如果需要通过 实例对象的实参传递数据的话
```js 
function Father(name, age) {
  this.name = name
  this.age = age
}
```

es6
```js 
class Father {
  constructor(name) {
    this.name = name
    this.age = age
  }
}
```

<br>

### 构造函数的问题
构造函数方法很好用, 但是存在浪费内存的问题
```js
function Star(name, age, sex) {
  this.name = name;
  this.age = age;
  this.sex = sex;
  this.sing = function(sang) {
    console.log(sang)
  }
};

let ldh = new Star('刘德华', 18);
let zxy = new Star('张学友', 19);
```

<br>

当创建第一个实例对象的时候 new就开辟了一个空间name age sex还好 简单的数据类型 

但是 sing是个函数 函数也是对象 也就是说 它还要单独开辟一个空间用来存放这个函数对象

zxy的实例对象也是一样需要单独开辟一个存放函数对象的空间, 而且, 这两个空间还是同一个功能的函数对象, 这就是浪费内存的问题

```js
ldh.sing === zxy.sing   // false  
```

因为比较的是内存地址, 说明每一个空间都是独立的 这样不好吧 因为功能是一样的, 你还单独开辟空间

<br><br>

### 构造函数原型: prototype
构造函数通过原型, **原型上的属性和方法都是所有实例对象所共享的**

js规定, 每一个构造函数都有一个prototype属性, 指向另一个对象, 注意这个prototype就是一个对象 这个对象的所有属性和方法 都会被构造函数所拥有

我们可以把那些不变的方法, 直接定义在prototype对象上, 这样所有的对象的实例都可以共享这些方法

```js
function Star(name, age, sex) {
  this.name = name;
  this.age = age;
  this.sex = sex;
};

// 向构造函数的原型对象上添加方法
Star.prototype.sing = function(sang) {
  console.log(sang);
}

ldh.sing('冰雨');
```

**原型对象的主要作用就是共享方法 不需要开辟新的内存空间 节约资源**  

<br>

### prototype的使用方式
通过 类名.prototype 来添加

<br>

**一般情况下:** 
- 公共属性定义到构造函数里面
- 公共的方法我们放到原型对象上

<br>

### 示例
即使是原型对象上的公共方法我们也可以向其传递参数 **原型对象中的方法中的this 仍然指向实例对象**
```js
function Person(name, age) {
  this.name = name
  this.age = age
}

Person.prototype.say = function(content) {
  // 原型对象中的方法中的this 仍然指向实例对象
  console.log(this.name + ": " + content)
}

let p = new Person("sam", 18)
p.say("加油！")
```

<br>

### 实例对象身上的 __proto__
实例对象都会有一个属性 __proto__ 指向构造函数的prototype原型对象

之所以我们对象可以使用构造函数prototype原型对象的属性和方法, 就是因为实例对象有__proto__原型的存在

```js
p.__proto__ == Person.prototyp  // true
```

当我们实例化对象的时候 系统会自动在实例对象身上添加 __proto__ 属性 指向 构造函数(类).prototype 原型对象


**__proto__对象原型和原型对象prototype是等价的**  

- 类 -> prototype
- 实例对象 -> __proto__

<br>

### 方法的查找规则
首先先看实例对象身上有没有sing方法, 如果有就执行这个对象上的sing方法

如果没有sing这个方法, 因为有__proto__的存在, 就去构造函数原型对象身上去查找sing这个方法

**__proto__ 不能赋值, 它只是指明了一条可以查找的线路**  

<br><br>

## constructor属性
对象原型(__proto__)和构造函数(prototype)原型对象里面都有一个属性 constructor属性

constructor我们称为构造函数, 因为它指回构造函数本身

``` 
实例对象__proto__
构造函数prototype 们都指向了 构造函数本身
```

<br>

### 原型对象中constructor属性(es5)的作用:
constructor主要用于记录该对象引用于哪个构造函数, 它可以让原型对象重新指向原来的构造函数

```js 
// 这样能看的更明确一切
console.log(Person.prototype.constructor)
// [Function: Person]

console.log(p.__proto__.constructor)
// [Function: Person]
```

<br>

**注意:**  
如果我们是以对象的形式修改了prototype的话(进行了对象的赋值操作), 我们必须手动的把constructor修改回去

<br>

**示例:**  
我们可以把一些公共的方法放到原型对象里面, 所以里面的方法可能不只有一个

```js
Star.prototype.sing = function() {
  console.log('我会唱歌')
}

Star.prototype.movie = function() {
  console.log('我会演电影')
}

// 这时候 constructor指向的还是原来的构造函数 Star
console.log(Star.prototype.constructor);
console.log(ldh.__proto__.constructor);
```

这么添加的方法的话 还是有些麻烦, 为什么不用对象的方式创建它们呢? 对象的结构比较清晰
```js
Star.prototype = {
  sing: function() {
      console.log('我会唱歌')
  }, 
  movie: function() {
      console.log('我会演电影')
  }
}

// 此时指向的就不是原来的构造函数了, Object
console.log(Star.prototype.constructor);    
console.log(ldh.__proto__.constructor);
```

<br>

**原因:**  
Star.prototype是一个对象, 如果是通过 . 的形式 就是在这个对象里面添加新的方法 

但是如果是 ``Star.prototype = { }``

相当于把原先的给覆盖掉了, 覆盖后里面就没有constructor这个属性了 要是没有constructor的话就没办法指回Star了 这时候我们就要手动的指回去, 

我们要再在原型对象中 添加 constructor 属性 值为 构造函数
```js
Star.prototype = {

  constructor: Star //手动添加

  sing: function() {
    console.log('我会唱歌')
  }, 

  movie: function() {
    console.log('我会演电影')
  }
}
```

<br>

### 构造函数(类) 实例对象 原型对象 三者之间的关系:
```
         Star.prototype
               -->
Star构造函数           Star原型对象
               <--
    Star.prototype.constructor    ↖

                                  ldh.__proto__
                                ↗
通过new创建了ldh实例对象      
```

<br><br>

## 检查某属性是否在对象中

### 方式1: in
```js
'属性名' in 对象
```

<br>

**返回值:**  
布尔值

<br>

**注意:**  
如果对象中没有但是原型中有 也会返回ture 
```js
console.log('name' in obj)
```

<br>

### 方式2:
### **<font color="#C2185">对象.hasOwnProperty("属性名")</font>**
检查该对象自身是否有这个属性 **不会检查原型对象上的属性**

<br><br>

# 原型链
Star.prototype 是 Star构造函数的原型对象, 原型对象既然是对象那么就会有__proto__

```js
Star.prototype.__proto__  -> 它指向了另一个原型对象
```

<br>

**ldh实例对象:**  
```js
ldh.__proto__ 指向了 Star.prototype
```

<br>

**Star.prototype原型对象**
```js
Star.prototype.__proto__ 指向了 Object.prototype
```

<br>

**Object.prototype原型对象**  
```js
Object.prototype.__proto__ 指向了 null
```

<br>

**这就是原型链**
```js
Star.prototype.__proto__ == Object.prototype
Object.prototype.__proto__ == null
```

<br>

### js中的成员查找机制(规则):
当访问一个对象的属性(包括方法)时, 首先查找这个对象自身有没有该属性
如果没有就查找它的原型(也就是__proto__指向的prototype原型对象)

如果还没有就查找原型对象的原型(Object的原型对象)
依次类推一直找到Object为止(null)

``` 
object对象的原型没有原型如果在object原型中依然没有找到则返回undefined, 一般2层就完事了  
```

<br><br>

# 垃圾回收(GC):
一个程序运行时间长了也会产生垃圾这些垃圾积攒过多程序的运行速度就会过慢
所以我们需要一个垃圾回收的机制来处理程序运行过程中产生的垃圾

<br>

**比如:**  
```js
var obj = new Object();
obj = null
```

这样就不会指向堆内存的对象断开连接了 这样堆内存中就没有任何变量可以进行引用了 这个对象就不能进行任何操作了  
                  
**当一个对象没有任何的变量或属性对它进行引用** 此时我们将永远无法操作该对象, 此时这种对象就是一个垃圾

这种对象过多会占用大量的内存空间导致程序运行变慢, 所以这种垃圾必须进行清理

在js中拥有自动的垃圾回收机制会自动将垃圾对象从内存中销毁, 我们不需要也不能进行垃圾回收操作

**需要回收就要写上obj = null这样浏览器才会识别出 该对象需要被回收**  

<br><br>

# ES6中的类和对象
面向对象更贴近我们的实际生活 可以使用面向对象描述现实世界事物, 但事物分为具有的事物和抽象的事物

比如 
- 抽象的(泛指的): 手机 它是一个类别
- 具体的(特指的): 我的手机 就是有具体的

<br>

### 面向对象的思维特点
抽取(抽象)对象共用的属性和行为组织(封装)成一个类(模板) 对类进行实例化, 获取类的对象

面向对象编程 我们考虑是有哪些对象, 按照面向对象的思维特点 不断的创建对象, 使用对象, 指挥对象做事情

**比如:**    
首先我们把手机的公共的行为和属性抽取出来, 封装为一个模板 这个模板里面有我们共用的属性和方法 手机都可以打电话发短信 手机有屏幕尺寸和重量之类的

根据这个类(模板) 生产出很多对象  

<br><br>

## 类 class
在es6中新增加了类的概念, 可以使用class关键字声明一个类, 之后以这个类实例化对象

类抽象了对象的公共部分, 它泛指某一大类(class) 对象特质某一个 通过类实例化一个具体的对象

<br>

### 创建 类
```js
class name {
  // classbody
}
```

**示例: 创建一个明星类**  
```js
class Star {

}
```

<br>

### 实例化对象:
```js
new Star()
```

<br>

### es6 实例化对象传参: constructor 构造函数
有了constructor就可以传递参数了

constructor()方法是类的构造函数(默认方法), 用于传递参数 返回实例对象, 有了它就不用return了 

通过 new 命令生成对象实例时, 自动调用该方法, **如果没有显示定义, 类内部会自动给我们创建一个constructor()**

<br>

### 使用方法
```js
class Star {
  constructor(uname) {
    this.uname = uname;
  }
}

let ldh = new Star('刘德华');
```

只要用new创建的实例 就**会自动调用constructor函数**

实参(刘德华) 传递给 形参uname, 形参uname会把刘德华传递给this.uname
this指向的是ldh这个创建的实例

<br>

**注意:**  
1. 通过class关键字 创建类 类名我们还是习惯定义首字母大写

2. 类里面有个constructor函数, 可以接受传递过来的参数, 同时返回实例对象

3. constructor函数只要new生成实例时, 就会自动调用这个函数, 如果我们不写这个函数, 类也会自动生成这个函数

4. 生成实例 new 不能省略

5. 最后注意语法规范, 创建类 类名后面不要加小括号, 生成实例, 类名后面加小括号, 构造函数不需要加function

<br>

### 总结
```js
class Star {

  // 我们使用constructor构造函数来传递参数, 它会返回实例对象
  constructor(name, age) {
    // 这里注意 因为constructor中的属性会返回给实例对象, 所以必须要用this动态的指回实例对象
    this.name = name;
    this.age = age;
  }
};

// 通过new来生成实例对象时, 会自动调用constructor方法
let ldh = new Star('刘德华', 18);
console.log(ldh);
```

<br>

### 成员方法:
直接将函数写在Star类中就可以了 不需要写function关键字
在类里 多个函数 **方法之间不需要添加逗号分隔 不需要写 ,**
```js
class Star {
  // 传递参数用的
  constructor(name) {
    this.name = name;
  }

  // 方法直接写在class部分里,写在这里, 在这里所有的函数不需要加 function 关键字
  say() {
    console.log(this.name+'你好')
  }
}

ldh.sing();     // 也可以传递参数
```

<br><br>

# 继承: class - extends
在程序里 子类可以继承父类的一些属性 和 方法 **使用 extends 关键字**

```js
// 创建 父类
class Father {
  constructor() {

  }

  // 创建一个方法 等着别的类过来继承
  money() {
    console.log(100)
  }
}


// 创建一个子类
class Son extends Father { 

}

let son = new Son();

// 使用extends后就可以继承到父类中的方法
son.money();
```

<br>

### 问题: 用父类型中的方法, 使用子类型中的参数怎么办?
```js
class Father {
  constructor(x,y) {
      this.x = x;
      this.y = y;
  }

  sum() {
    console.log(this.x + this.y);
  }
}

class Son extends Father { 
  // 孩子需要传递参数 所以
  constructor(x,y) {
      this.x = x;
      this.y = y;
  }

}

let son = new Son(1,2);
son.sum();      // 报错了

/*
  原因很简单, 我们本意是想把1 2传递给父类中调用父类的方法输出3

  但是 我们传递进去的参数只能传递到自己类的constructor里
  那么怎么才能做到呢?
*/
```

<br>

### Super 关键字
super关键字用于访问和调用对象父类上的函数 可以调用父类的构造函数, 也可以调用父类的普通函数
```js
class Father {
  constructor(x,y) {
      this.x = x;
      this.y = y;
  }

  sum() {
    console.log(this.x + this.y);
  }
}

class Son extends Father { 
  
  constructor(x,y) {
    // 这里就不要写this.x = x了, 直接调用super关键字
    super(x, y);  // 调用了父类中的构造函数
    
    /*
    相当于把父类中的构造函数内容粘贴到了这里 this指向还是父类的
    使用super()方法 调用了父类型中的constructor中的属性, 数据以 
      实参 --- 
        子类型constructor中的形参x,y --- 
          传递给super(x,y) --- 
            传递给父类型中干的constructor中的 x,y
    */

  }

}

let son = new Son(1,2);
son.sum(); 
```

<br>

**执行流程:**  
```js
let son = new Son(1,2); 
```

我们传递了实参 实参会传递到子类中的constructor(x,y) 形参里 

然后子类的构造函数里调用了super(x,y) 

然后又把得到的实参传递给了super里的形参 super里的形参又链接着父类的构造函数

所以就能变相的访问到了 父类构造函数中的数据

<br>

### 继承中的属性或者方法查找原则: 就近原则
继承中 如果实例化子类输出一个方法, 先看之类有没有这个方法 如果有就先执行子类的

继承中 如果子类里面有, 就去找父类有没有这个方法 如果有 就执行父类的这个方法

<br>

### super关键字: 调用父类中的方法
```js
class Father {
  say() {
    return '我是爸爸'
  }
}

// 这样子类就继承了父类的属性和方法
class Son extends Father {  

  say() {
    return '我是儿子';
  }
}

let son1 = new Son();
son1.say();     //我是儿子


// 调用父类中的方法
class Son extends Father {
  say() {
    // 通过super关键字调用了父类中的say
    console.log(super.say())
  }
}
let son1 = new Son();
son1.say();     // 我是爸爸
```

<br>

### 子类扩展新方法:
需求: 子类继承父类加法的方法, 同时 扩展减法的方法
```js
// 父类
class Father {
  constructor(x,y) {
    this.x = x;
    this.y = y;
  }

  sum() {
    console.log(this.x + this.y);
  }
}

// 子类
class Son {
  constructor(x,y) {
    this.x = x;
    this.y = y;
  }

  // 定义个减法的方法 这个减法是儿子独有的
  subtract() {
    console.log(this.x - this.y);
  }
}
let son = new Son(5, 3);

// 不继承的时候 正常使用到了子类中的减法
son.subtract();     // 2


// 子类继承父类加法的方法
class Son extends Father {
  constructor(x,y) {
    // 因为this的指向是不同的, 各自指向各自的类 这里利用super关键字调用父类的构造函数

    // 一定要在this的上方 
    super(x,y)

    this.x = x;
    this.y = y;
  }
}
let son = new Son(5, 3);
son.subtract();     // 2
son.sum();          // 8 
```

<br>

### 总结
当使用extends后 既可以使用父类中的方法, 又可以使用子类中的方法

但是 super(x, y), 一定要在子类constructor中的参数的最前面

<br>

**注意:** 
super必须在子类的构造函数中的this之前, 也就是说必须要先调用父类的构造方法 再使用子类的构造方法

<br>

### 类和对象 在使用时的三个注意点

1. 在es6中类没有变量提升, 所以必须先定义类, 才能通过类实例化对象

2. 类里面的共有的属性和方法一定要加this使用, 说白了就是构造函数里都要加this

3. 类里面this指向的问题
``` 
constructor里面会有this
  -- 主要的作用是创建实例, this指向的就是这个创建出来的实例

类的方法里会有this
  -- 方法里面的this 是看谁调用了这个方法, this就是谁 这里ldh调用了这个方法
```

<br>

### 总结:
constructor里面的this指向实例对象, 方法里面的this指向这个方法的调用者
``` 
我们想用别的部分的this 可以把this存到全局变量that 我们输出that
```

```js
class Star {
  constructor(name, age) {

    this.name = name;
    this.age =age;

    // 写在这里的一定要加this
    this.sing(); 
    // 如果我把sing()方法写在constructor里面, 那么用new来创建实例的时候会自动调用该方法

  }

  // 如果方法写在类了 需要通过实例来手动调用比如ldh.sing()
  sing() {
    console.log(this.name)
  }
}

let ldh = new Star();

ldh.sing();
```

<br>

### 案例: 使用类 完成点击按钮 调用方法的逻辑
```js
class Star {
  constructor(name, age) {
    this.name = name;
    this.age =age;
    this.btn = ducument.querySelector('button');
    this.btn.onclick = this.sing;
    // 这里不要加() 要不new下就自己调用了 我们要点击后再调用
  }

  sing() {
    console.log(this.name)
  }
}
```

首先我们要获取button, 因为用new调用时, 会自动执行constructor里面代码 所以我们把获取btn的动作写在构造函数里面 

同时btn属于哪个对象的 ldh吧 所以前面要加上this 绑定点击事件的时候 不能直接写btn.onclick 也是 我们要知道哪个按钮被点击了this.btn.onclick

<br><br>

# 原型对象的应用: 扩展内置对象
可以通过原型对象, 对原来的内置对象进行扩展自定义的方法, 比如给数组增加自定义求偶数和的功能

数组里已经有了很多方法 比如翻转数组, 数组排序等 我们再添加一个求偶数和

```js
// 看看数组的原型对象中有什么样的方法
console.log(Array.prototype);

// 添加求和方法
Array.prototype.sum = function() {
  let sum = 0;

  // 谁调用这个方法就是谁的length
  for(let i = 0; i < this.length; i++) {
    if(this[i] % 2 == 0) {
        sum += this[i];
    }
    return sum;
  }
}

// 这个arr其实是new Array出来的 所以它可以使用原型对象中的方法
let arr = [1,2,3];
arr.sum();
```

<br>

**注意:**  
数组和字符串内置对象不要覆盖原型对
```js
// 这样不行
Array.prototype = {}

// 最好使用如下的方式
Array.prototype.xxx = function() {} 
```

<br><br>

# 扩展: 当调用 对象.toString() 输出 [object Object]
通过下面的示例 我们能看到 当我们调用对象的toString()方法的时候输出的是 [object Object]
```js
function Person(name, age, gender){
  this.name = name;
  this.age = age;
  this.gender = gender;
}

// 创建一个Person的实例
var per = new Person("孙悟空", 18, "男");


console.log(per);
// Person { name: '孙悟空', age: 18, gender: '男' }


// 为什么会输出 [object Object]
console.log(per.toString());
// [object Object]
```

<br>

### 为什么?
```js

function Person(name, age) {
  this.name = name
  this.age = age
}

const p = new Person("sam", 18)

// Person里面也没有toString()哪来的? - false
console.log(p.hasOwnProperty("toString"))

// 看看p对象的原型对象里有没有 - false
console.log(p.__proto__.hasOwnProperty("toString"));

// 看看p对象的原型对象的原型对象里有没有 - true
console.log(p.__proto__.__proto__.hasOwnProperty("toString"))
```

也就是 toString 放在在原型对象的原型对象里

<br>

如果我们希望在输出对象时 不输出[Object Object]

可以直接为对象添加一个toString()方法 也不去使用原型对象的原型对象里面定义的toString()方法

也就是我们可以对对象里面添加一个自定义的toString方法来覆盖原有的toString方法

```js
Person.prototype.toString = function() {
  console.log(`Person: { ${this.name} - ${this.age} }`)

  return "返回值"
}

p.toString()
```

<br><br>

# this
**解析器**在调用函数时每次都**会向函数内部传递进一个隐含的参数** 这个隐含的参数就是this

this是一个参数跟 a b 没区别只是浏览器传进来的

<br><br>

## this的指向
this的指向 在函数定义的时候是确定不了的, 只有**函数执行的时候才能确定this到底指向谁**

一般情况的最终指向的是那个调用它的对象(定时器的this是window, 因为window.setInterval())

<br>

### 根据的是调用的方式不同this会指向不同的对象
1. 以函数形式调用this永远是window

2. 以方法形式调用this就是调用方法的那个对象

3. 当函数以构造函数调用的时候this就是那个新创建的对象(实例对象)
``` 
在构造函数中的this指向对象实例 new的时候会创建空对象, 让this指向这个空的对象
```

<br>

**注意:**   
构造函数的原型对象中的this指向的是谁? 原型对象函数里面的this 指向的是 实例对象 this可以根据调用者的不同变成不同的值

<br>

### 总结: 调用方式 this指向
- 普通函数调用: window
- 构造函数调用: 实例对象(原型对象里面的方法也指向实例对象)
- 对象方法调用: 该方法所属对象
- 事件绑定方法: 绑定事件对象
- 定时器函数: window
- 立即执行函数: window

<br>

# 改变函数内部 this 指向
js中为我们提供了一些函数方法来帮我们更优雅的处理函数内部this的指向问题, 常用的

- 函数名.bind()
- 函数名.call()
- 函数名.apply()

<br>

### **<font color="#C2185">函数名.call(目标, 参数1, 参数2 ...)</font>**
call方法可以改变函数的this的指向 让目标临时有这个方法   
该函数中的this就指向这个目标

call()可以调用函数

<br>

**参数:**   
- this 或者是 目标对象  
- 实参 我们传递的数据可以在函数的形参中被接收到

```js
let obj = {name: 'sam'}

// 全局 name
name = 'erin'


function say() {
  console.log(this.name);
}


// 直接调用 say中的this指向了 全局中的 name erin
say()

// obj 临时拥有了 say方法 同时 say方法中的this指向了 obj
say.call(obj);
```

<br>

```js
function fn(a, b, c) {
  console.log(this.name)
  console.log(a,b,c)
}

fn.call(obj, "a", "b", [1,2,3])


// 假如我们使用...args形参接收实参的话 我们传递的数据都会在数组中体现
function fn(...args) { }   // ["a", "b", [1,2,3]]
```

<br>

### call的使用场景:
call()的主要作用可以实现继承 

```js
function Father(name, age) {
  this.name = name
  this.age = age
}

function Son(name, age) {
  // 将Son的this传递进去 相当于执行Father里面的逻辑时 是往Son的实例对象上添加属性, 相当于调用super
  Father.call(this, name, age)
}

let s = new Son("sam", 18)
console.log("s", s)
// Son { name: 'sam', age: 18 }
```

<br>

### **<font color="#C2185">函数名.apply(目标, [参数]) 方法</font>**
用法跟call()一样 但是**传递实参的时候必须要以数组的形式传递**

在传递实参的时候 是字符串的形式拿到的就是字符串的形式 是数组的形式拿到的就是数组的形式

返回值就是函数的返回值, 因为它就是调用函数

```js
fn.apply(o, ['pink']);
```

<br>

### 技巧:
我们可以利用apply 借助于数学内置对象求最大值
```js
let arr = [1, 66, 3, 99, 4];

// Math.max是求数字中的最大值, 但是它求的是数字的 不是数组的 
Math.max()

// 现在我们可以利用这种方式 来求数组中元素的最大值
Math.max.apply()

// 我们可以写个空不需要改变this指向 
Math.max.apply(null, arr)  

// 写null也不太好, 就好让它指向函数的调用者, Math调用的吧 让它重新指回Math
Math.max.apply(Math, arr)
```

<br>

**注意:**  
1. apply传递参数的时候 必须是数组
2. 函数接收参数的时候 可以使用 ...args 接收 那么 args就是参数数组 定义单独变量接收, 定义几个变量 可以接收几个参数
```js
// 下面我们传递的是数组 但是这里可以定义变量分别接收
let fn = (a, b) => {
  console.log(a)
}

fn.apply(this, ["sam", 18])
```

<br>

### **<font color="#C2185">函数名.bind()</font>**
bind()方法 **不会调用函数**, 但是能改变函数内部的this指向, 把原函数改造完产生一个新的函数返回给我们 **需要一个变量来接收**

<br>

**语法:**  
```js
fun.bind(thisAsg, arg1, arg2);
```

<br>

**参数:**  
- thisAsg: 在fun函数运行时指定的this值
- arg1: 传递的其它参数

返回由指定的this值和初始化参数改造的原函数拷贝(返回的是原函数改变this之后产生的新函数)

```js
let o = {
  name:'andy'
}

function fn() {
  console.log(this);
}

// 普通函数指向的是window, 我想让它指向o 给fn绑定bind这个方法,  它不会调用这个函数 只会改变this的指向 
fn.bind(o);  

// 它会返回一个bind完新的函数
let f = fn.bind(o);
f();
```

<br>

### 场景:
如果有的函数我们不需要立即调用, 但是又想改变这个函数内部的this指向此时用bind是最合适的

<br>

**需求:**  
当我们有一个按钮, 当我们点击了之后, 就禁用这个按钮, 3秒钟之后开启这个按钮

```js 
let button = document.querySelector('button');
button.onclick = function(){

  // 事件函数的this指向的是btn
  this.disabled = true;

  setTimeout(function(){
    // 我能这么写么? 不能因为定时器函数this指向的是window
    this.disabled = false;  
  }, 3000)
}

// 以前的做法
button.onclick = function(){
  // 以前我们的做法是
  let that = this;
  this.disabled = true;

  setTimeout(function(){
      that.disabled = false;  
  }, 3000)
}

// 高级做法
button.onclick = function(){
  this.disabled = true;

  setTimeout(function() {
  
      // 现在我就想让定时器函数里面的this指向btn 同时定时器里面的函数并不是马上执行 所以我们选择bind(), bind()写在定时器的外面
      this.disabled = false;  
  }.bind(this), 3000)
}
```

上面这个bind()是在定时器函数的外面, 这个this又是在button函数的里面, 这个this指向的就是btn

``setTimeout(funcion(){}.bind(button), 3000)`` 给定时器函数绑定了一个bind方法, 它不会立即调用函数, 同时我让这个定时器函数里面的this 指向了btn 因为点了谁, 谁就是this, 说以bind(button) 里面不要写button 改成this

<br>

### call apply bind总结
**相同点:**  
都可以改变函数内部的this指向

<br>

**区别点:** 
- call apply会调用函数, 并且改变函数内部的this指向  
- call和apply传递的参数不一样, call传递参数arg1 arg2形式, apply必须是数组的形式[args]
- bind 不会调用函数, 可以改变函数内部this指向

<br>

### 性能: 
传参超过3个以上的时候 call 的性能要好

<br>

### 应用场景: 
**call:**  
call经常做继承

<br>

**apply:**  
apply经常跟数组有关系的, 比如借助于数学对象实现数组最大值最小值   
跟数组传参相关的时候 使用 apply 比较好  
```js
let arr = [10, 20, 30]
let obj = {}

function fn(x, y, z) {}
fn.apply(obj, arr)
```

<br>

**bind:**  
bind 不调用函数, 但是还想改变this指向, 比如改变定时器内部的this指向 定时器不需要我们调用 是每隔一段时间自动 改变this时

<br><br>

# 继承: function
我们在父类中已经写好了很多的方法, 在子类直接拿来使用继承父类的方法, 优点就是 代码就会更简单

那在es6之前并没有给我们提供extends关键字的继承方式, 我们可以通过 构造函数 + 原型对象 模拟实现继承, 被称为组合继承

<br>

### 要点:
我们在 子类中 调用 父类构造函数

<br>

**<font color="#C2185">call()</font>**  
调用这个函数, 并且修改函数运行时的this指向
```js
Father.call(thisArg, arg1, arg2...)
```

<br>

### 核心原理:
通过 ``父类.call(this)`` 通过call将父类中的this暂时的指向了子类

这样父类中的 ``this.name = name`` 中的this就是子类的this 也就相当于在给子类对象赋值

```js
function Father(name, age) {
  this.name = name
  this.age = age
}

function Son(name, age, address) {

  // 在这里使用call的方式 调用父类构造函数
  Father.call(this, name, age)

  this.address = address

/*
  这里我们将子类中的this传入, 相当于将 
      
      Father的this -> Son的this

  这样父类中的如下代码 就相当于给子类对象赋值
    this.name = name
    this.age = age

  因为父类中的this指向子类了
*/
}
```

<br>

**定义父构造函数:**
```js
function Father(uname, age) {
  this.name = name;
  this.age = age;
}
```

<br>

**定义子构造函数:**
```js
function Son(uname, age, score) {

}
```

<br>

现在我想让子类使用父类中的属性, 但是现在 父类和子类并没有相连的关系

<br>

**而且父类子类中的this指向也不一样**  
- 父类中的this 指向 父类的实例对象
- 子类中的this 指向 子类的实例对象

<br>

**那子构造函数怎么才能拿父构造函数中的属性呢?**  
我们可以在子构造函数中调用父构造函数

我们把父构造函数当做一个普通的函数来调用 

但是注意在父构造函数里面的this是指向父类对象实例的, 子构造函数是指向子类的对象实例的

父构造函数里面的uname是在父构造函数身上的, 那么子构造函数想要使用父构造函数中的属性, 一定要把父构造函数的this改成子构造函数, 然后我就可以使用这个属性了

现在就指向了自构造函数的实例对象 还可以创建自己的属性
```js
function Son(uname, age, score) {
  Father.call(this, uname, age);
  this.score = score;
}

let son = new Son('刘德华', 18, 100);
console.log(son);
```

<br>

### 问题:
上面的方式只能继承定义在父类中的属性和方法 **要想继承原型链上的属性和方法需要下面的知识**

<br>

# 继承: 继承原型链上的属性 和 方法
一些共有的属性 我们写在构造函数里面, 但是共有的方法 我们要写在原型对象上比较合适

1. 定义父构造函数
```js
function Father(uname, age) {
  this.name = name;
  this.age = age;
}
```

2. 往父构造函数的原型对象中添加共有方法
```js
Father.prototype.money = function() {
console.log(10000);
};
```

<br><br>

## 怎么样继承父类中原型对象里的方法呢?

### 方式1: 这样可以么?
我们将子类的原型对象 指向 父类的原型对象
```js
Son.prototype = Father.prototype
```

**这么做是不行的!**  
这样直接赋值会有问题, 如果修改了子类的原型对象, **父类的原型对象也会同样被修改**

<br>

### 方式2: 这样做呢? 可以!
我们让子类的原型对象指向父类的实例对象
```js
Son.prototype = new Father()
```

new Father相当于创建了一个Father的实例对象 这是Father实例对象 和 Father的原型对象不在一个内存机制里

然后我又把 创建的Father实例对象 赋值给了 Son.prototype

相当于 Son子类的原型对象 指向了刚才创建的Father实例对象

Father的实例对象 能访问 Father原型对象里面的方法 而son原型对象 也可以通过Father实例对象访问到 Father原型对象里面的方法

<br>

### **<font color="#C2185">总结下</font>**
```js
function Father() {

};

Father.prototype.sing = function() {
  console.log(1);
}


Son.prototype = new Father();

function Son() {

};

let son = new Son();
son.sing();
```

<br>

### 注意:
```js
Son.prototype = new Father();

// 上面这样做相当于: 
Son.prototype = {};
```

这样就会把Son.prototype里面的东西覆盖掉, 所以Son.prototype里面就没有constructor了

```js
console.log(Son.prototype.constructor)  //Father
```

这就是问题 按道理Son.prototype.constructor应该指向Son才对 因为是一个覆盖操作

如果利用对象的形式修改了原型对象, 别忘了利用constructor指回原来的构造函数

<br>

### 总结: 继承父类原型对象上的属性和方法
1. Son.prototype = new Father()
2. Son.prototype.constructor = Son

<br>

### 完整示例:

创建父类
```js
function Father(name, age) {
  this.name = name
  this.age = age
}

// 往父类的原型上添加方法
Father.prototype.say = function() {
  console.log("我叫" + this.name)
}

// 测试创建父类的实例对象
const f = new Father("sam", 18)
f.say()
```

<br>

创建子类 并继承父类中的属性
```js
function Child(name, age) {
  Father.call(this, name, age)
}

const c = new Child("nn", 6)

// 父类中的属性是可以使用的
console.log(c.name)


// 报错: 父类原型上的方法我们是没有办法使用的
c.say()


// 这时输出c 我们观察下 c.prototype.constructor 还是指向自己
console.log(c)
/*
  Child: {
    name: "nn",
    age: 6,
    prototype: {
      constructor: f Child(name, age)
    }
  }
*/
```

<br>

继承父类原型上的方法
```js
function Father(name, age) {
  this.name = name
  this.age = age
}

Father.prototype.say = function() {
  console.log("我叫" + this.name)
}

function Child(name, age) {
  Father.call(this, name, age)
}


// 继承父类上原型的方法
Child.prototype = new Father()
Child.prototype.constructor = Child

c.say()

/*
如果我们不加上 Child.prototype.constructor = Child

则 c.prototype.constructor 会指向Father
Child: {
  name: "nn",
  age: 6,
  prototype: {
    constructor: f Father(name, age)
  }
}
*/
```

<br><br>

# 对象的遍历: for...in
for...in用于对数组或者对象的属性 进行循环操作, **建议对对象使用**

<br>

### 语法:
```js
for (let 变量 in 对象) {
  
}
```

<br>

**示例:**  
```js
let obj = {
  name: '',
  age: 18,
  sex: '男'
};

for (let 变量 in 对象) {
  
}
```

<br><br>

## for...in 的特点:

### 遍历数组
1. index索引为字符串型数字不能直接进行几何运算
2. 遍历顺序有可能不是按照实际数组的内部顺序
3. 使用for in会遍历数组所有的可枚举属性包括原型上的

例如上例的原型方法method和name属性 所以for in更适合遍历对象不要使用for in遍历数组

<br>

**for...in 变遍历整个原型链**  

<br><br>

# 遍历数组 字符串: for...of
如果说for...in遍历的是数组的索引(键名) 那么for...of遍历的是数组的元素的值(直接就是属性值)

它适合遍历数组 字符串等 **不能遍历对象**

<br>

### 语法:
```js
for (let 变量 in 数组) {

}

console.log(变量);       // 属性值
```

<br><br>

# Object API:

### **<font color="#C2185">Object.assign(目标对象, 源对象)</font>**
该方法将所有可枚举 和 自有属性``Object.hasOwnProperty() 返回 true的属性`` 

**从一个或多个源对象复制到目标对象**

也就是说将 **源对象** 的符合条件的属性复制到 **目标对象**

<br>

**参数:**  
- target: 目标对象, 接收源对象属性的对象, 也是修改后的返回值。

- sources: 源对象, 包含将被合并的属性

<br>

**返回值:**  
合并后的对象

<br>

**注意:**  
1. 如果目标对象 和 源对象 具有相同的key 则目标对象中的属性会被源对象中的属性覆盖 **(后面的覆盖前面的)**

2. Object.assign 方法只会拷贝源对象 可枚举的 和 自身的 属性到目标对象。

3. 深浅拷贝的问题 因为 Object.assign() 只复制属性值。假如源对象是一个对象的引用, 它仅仅会**复制其引用值, 也就是浅拷贝**

<br>

**示例: 深浅拷贝示例**
深浅拷贝指的是 源对象中的属性有引用类型的时候 该引用类型的属性的拷贝问题

对象本身是一个新的

```js
// 源对象
let obj = { name: "sam" }

// 复制对象
let res = Object.assign({}, obj)

// 输出 新对象 { name: 'sam' }
console.log(res)

// 修改源对象
obj.name = "erin"

// 输出新对象 { name: 'sam' }
console.log(res)

// false
console.log(res === obj)
```

当源对象中有引用类型的属性值 则该属性复制的是其地址值 也就是浅拷贝

```js
let obj = { name: "sam", job: { front: "vue" }}
let res = Object.assign({}, obj)

// 当我们修改源对象中的引用类型数据的时候 会影响到新的对象
obj.job.front = "react"

console.log(res)
// { name: 'sam', job: { front: 'react' } }
```

<br>

**示例: 复制对象**
```js
let obj = {name: "sam"}
let res = Object.assign({}, obj)
console.log(obj)
```

<br>

**合并对象: target目标对象就是返回值**
```js
let o1 = {a: 1}
let o2 = {b: 2}
let o3 = {c: 3}

let res = Object.assign(o1, o2, o3)
console.log(res)
// { a: 1, b: 2, c: 3 }

console.log(o1)
// { a: 1, b: 2, c: 3 }
```

<br>

### **<font color="#C2185">Object.create(proto, [propertiesObject])</font>**
create方法可以创建一个新对象 并可以指定新对象的原型对象

<br>

**参数:**  
1. proto: 返回对象的原型对象
2. propertiesObject: 
```s
# 对象的属性类型参照Object.defineProperties()的第二个参数
{
  writable:true,
  configurable:true,
  value: "hello"
}

{
  configurable: false,
  get: function() { return 10 },
  set: function(value) {
    console.log("Setting `o.bar` to", value);
  }
}
```

<br>

**返回值:**  
带有指定的原型对象和属性 的 新对象

<br>

**示例:**  
```js
// 创建一个对象 会作为某对象的原型对象
const prototypeObj = {
  baseUrl: "http://localhost:3000",
  timeout: 5000,
  connect: () => {
    console.log("连接某数据库");
  }
}


// 创建一个新对象的同时 指定该对象的原型对象
const connectObj = Object.create(prototypeObj)
console.log(connectObj)  // {}


// 输出它原型对象中的属性
console.log(connectObj.baseUrl)
// http://localhost:3000


// 调用它原型对象中的方法
connectObj.connect()
// 连接某数据库
```

<br>

**示例:**  
```js
// 取得 Array 的原型对象
let oldArrayProto = Array.prototype

// 生成了一个新的数组对象, 新对象的原型对象就是oldArrayProto 我们可以通过 newArrayProto.__proto__ 访问到oldArrayProto
let newArrayProto = Object.create(oldArrayProto)
console.log(newArrayProto)
```

<br>

**示例: 实现类式继承**  
```js
// 原型的继承的使用方式如下
function Father(name, age) {
  this.name = name
  this.age = age
}

Father.prototype.say = function() {
  console.log("我叫" + this.name)
}


function Child(name, age) {
  Father.call(this, name, age)
}

Child.prototype = new Father()
Child.prototype.constructor = Child



// 使用 create() 方法代替  new Father()
function Father(name, age) {
  this.name = name
  this.age = age
}

Father.prototype.say = function() {
  console.log("我叫" + this.name)
}


function Child(name, age) {
  Father.call(this, name, age)
}

// api
Child.prototype = Object.create(Father.prototype)
Child.prototype.constructor = Child
```

<br>

### 拿到指定属性的描述符
### **<font color="#C2185">Object.getOwnPropertyDescriptor(目标对象, "指定属性")</font>**
返回指定对象上一个自有属性对应的属性描述符。

**返回值:**  
属性描述符的对象

```js
const obj = {
  age: 18
};

// 获取该对象指定属性的描述符
const descriptor = Object.getOwnPropertyDescriptor(obj, 'age');
// {value: 'sam', writable: true, enumerable: true, configurable: true}

console.log(descriptor.configurable);
// configurable: true

console.log(descriptor.value);
// value: 42
```

<br>

### 设置指定属性的描述符
### **<font color="#C2185">Object.defineProperty(obj, 'prop', descriptor)</font>**
通过该方法, 可以在指定对象中完成 直接在一个对象上定义一个新属性, 或者修改一个对象的现有属性 来达到

- 添加 属性 和 属性值
- 对属性值 进行限制 或 控制

<br>

**要点:**  
对象中是否有指定的属性没有关系
- 有: 则修改
- 没有: 则添加

<br>

**参数:**  
1. obj: 目标对象(必传项)
2. prop: 需要定义或修改的属性的名字(原先没有的会添加)
3. descriptor: 类型对象, 数据描述符 | 访问器描述符, **注意数据描述符和访问器描述符不能混合使用, 2选1**

<br>

**数据描述符:**  
```js
{
  value: 设置属性的值, 默认为undefined,

  enumerabl: 设置目标属性是否可以被枚举(遍历), true | false, 默认为false,

  writable: 设置值是否可以重写(修改), true | false, 默认为false,

  configurable: 设置目标属性是否可以被删除或是否可以再次通过defineProperty修改该属性的特性, 默认为false,
}
```

- writable:   
我们的对象中有很多属性是很重要的, 不可以修改的, 这时候可以通过这个属性限定不允许被修改

- enumerable:   
比如买了个东西 我往对象里添加了用户的地址, 这个地址比较隐私, 不想让被枚举出来, 这时候就可以用这个属性

- configurable:  
添加的属性不允许被删除, 并且不能再通过defineProperty修改该属性的特性(让该配置只生效一次)

<br>

**示例1:**  
```js
const obj = {
  name: "sam",
  age: 18
}

Object.defineProperty(obj, "address", {
  value: "ToKyo",
  enumerable: false,
  writable: true,
  configurable: false
})

console.log(obj)
// {name: 'sam', age: 18, address: 'ToKyo'}


// 查看遍历: enumerable
for(let key in obj) {
  console.log(obj[key])
}
/*
  sam
  18

  我们设置了 enumerable: false 不允许遍历
  ToKyo并没有遍历出来
*/


// 查看修改: writable
obj.address = "china"
console.log(obj)
/*
  我们设置了 writable: false 不允许修改 

  尝试修改时并有报错

  发现我们并没有修改成功 当我们设置为true的时候 才能修改
  {name: 'sam', age: 18, address: 'ToKyo'}
*/


// 查看删除: configurable
delete obj.address
console.log(obj)
/*
  我们设置了 configurable: false 不允许删除
  尝试删除时并有报错
*/
```

<br>

**示例2:**  
对类中的属性进行控制 要求它们不能被重新赋值
```js
class UIGoods {
  constructor(data) {
    Object.defineProperty(this, "data", {
      value: data,
      writable: false,
      configurable: false
    })
  }
}
```

<br>

**优化:**  
data被重新赋值的时候 应该抛出异常
```js
class UIGoods {
  constructor(data) {
    Object.defineProperty(this, "data", {
      get() {
        return data
      },
      set(val) {
        throw new Error("该值不能被修改")
      }
    })
  }
}
```


<br>

**访问器描述符:**  
当我们需要设置或获取对象的某个属性的值的时候我们可以使用 setter/getter方法
```js
{
  get: () => 返回值,
  set: (val) => { ... },
  configurable:  
  enumerable: 
}
```

- get: 读取器  
当我们读取给定属性的时候会调用get函数, get函数的返回值就是给定属性的属性值

- set: 设置器  
当我们修改给定属性的时候会调用set函数, set函数的形参value就是新修改之后的值

<br>

**注意:**  
当我们对对象中已有属性添加 访问器 的时候, 该属性会在原对象中删除

```js
const obj = {
  name: "sam",
  age: 18
}

Object.defineProperty(obj, "name", {
  get() {
    return obj
  }
})

console.log(obj)

// {age: 18}
```

上面我们往obj中添加了 name属性 该属性在obj中是已经存在的 当我们使用get返回obj的时候 发现name属性已经被删掉了

<br>

### 技巧: 利用上述的注意点
利用上面的特性 我们可以定制一个方法 传入指定属性对目标对象中的同名属性进行过滤 

也就是将我们传入的属性过滤掉

```js
/*
  source: 源对象
  key: 要过滤掉的属性
*/
function filter(source, key) {
  return Object.defineProperty(source, key, {
    get() {
      return source
    }
  })
}

console.log(filter(source, "age"))
```

<br>

### 案例: 实现双向绑定
我们将输入框中输入的数据 展示在div中
1. 输入数据
2. 修改代理对象 会触发set方法
3. set方法中完成 将新值赋值给源对象 和 将新值展示在div中
```html
<!-- 定义输入区 -->
<div>
  输入区: <input type="text" id="inp-area" placeholder="默认值">
</div>

<!-- 定义展示区 -->
<h3>展示区: <span id="content"></span></h3>

<script>

// 获取输入框
const oInp = document.querySelector("#inp-area")
// 获取展示区
const view = document.querySelector("#content")

// 定义代理对象 页面上的数据从代理对象中提取
const msg = { }

// 定义源对象 代理对象中使用的数据从源对象中提取
const source = {
  name: "sam"
}


// 使用 defineProperty 定义响应式属性
Object.defineProperty(msg, "name", {
  get() {
    return source.name
  },
  set(val) {
    source.name = val
    view.innerHTML = val
  }
})


oInp.addEventListener("input", function() {
  // 获取输入框的值 将获取到的值展示到显示区
  msg.name = this.value
})
</script>
```

<br>

### **<font color="#C2185">Object.defineProperties(obj, props)</font>**
给一个对象设置多个属性时使用 

<br>

**格式:**  
```js
Object.defineProperties(obj, {
  属性名1: { 配置对象 },
  属性名2: { 配置对象 },
  属性名3: { 配置对象 },
})
```

<br>

**示例:**  
```js
var obj = {};

Object.defineProperties(obj, {
  'property1': {
    value: true,
    writable: true
  },
'property2': {
    value: 'Hello',
    writable: false
  }
});
```

<br>

### **<font color="#C2185">Object.entries(目标对象)</font>**
将目标对象中 可枚举的属性 组织成 [key,value] 放到一个数组中 也就是最终会形成一个二维数组

```js
const obj = {     const arr = [
  name: "sam"       ["name", "sam"]
}                 ]
```

<br>

**返回值:**  
二维数组 [[key,value], [key,value], [key,value]]

<br>

**示例:**  
```js
let obj = {
  name: "sam",
  age: 18,
  sex: "男"
}

let res = Object.entries(obj)
console.log(res)
// [['name','sam'], ['age',18], ['sex','男']]
```

<br>

**技巧:**
1. 因为得到的是 二维数组 所以可以利用解构
2. 可以使用 for...of 遍历 (数组嘛)
```js
let obj = {
  name: "sam",
  age: 18,
  sex: "男"
}

// 解构
for(let [key, value] of Object.entries(obj)) {
  console.log(key, value)
}
```

<br>

**技巧: 将Object转换为Map**  
new Map()构造函数接受一个可迭代的entries。也就是二维数组, 借助Object.entries方法你可以很容易的将Object转换为Map
```js
let obj = {
  name: "sam",
  age: 18,
  sex: "男"
}

let map = new Map(Object.entries(obj))
console.log(map)
// {'name' => 'sam', 'age' => 18, 'sex' => '男'}
```

<br>

### **<font color="#C2185">Object.fromEntries(指定结构)</font>**  
可以将如下的结构 转回对象

- 键值对构成的二维数组: [["name","sam"]]
- map
- 或其它的可迭代对象(键值对的形式)

<br>

```js
// 键值对二维数组
const arr = [ ['0', 'a'], ['1', 'b'], ['2', 'c'] ];
const obj = Object.fromEntries(arr);
console.log(obj); // { 0: "a", 1: "b", 2: "c" }


// map
let obj = {
  name: "sam",
  age: 18,
  sex: "男"
}

let map = new Map(Object.entries(obj))
console.log(map)
// {'name' => 'sam', 'age' => 18, 'sex' => '男'}

let nObj = Object.fromEntries(map)
console.log(nObj)
// {name: 'sam', age: 18, sex: '男'}
```

<br>

**技巧:**  
1. 利用 entries 将对象转为数组
2. 利用 map 修改 value 部分的值
3. 利用 fromEntries 将数组还原为对象

```js
let obj = {
  name: "sam",
  age: 18,
  sex: "男"
}

const temp = Object.entries(obj).map(([key, value]) => {
  if(key == "age") {
    return [key, value * 2]
  }
  return [key, value]
})
const _obj = Object.fromEntries(temp)
console.log(_obj)
// {name: 'sam', age: 36, sex: '男'}
```

<br>

### **<font color="#C2185">Object.keys(目标对象)</font>**
将目标对象的属性名 取出构成一个属性名组成的数组进行返回

<br>

**返回值:**  
属性名数组

<br>

### **<font color="#C2185">Object.values(目标对象)</font>**
将目标对象的属性值 取出构成一个属性值组成的数组进行返回

<br>

**返回值:**  
属性值数组

<br>

### **<font color="#C2185">Object.freeze(目标对象)</font>**
可以冻结一个对象。一个被冻结的对象再也不能被修改

<br>

**特性:**  
- 冻结了一个对象则不能向这个对象添加新的属性
- 不能删除已有属性
- 能修改该对象已有属性的可枚举性、可配置性、可写性
- 不能修改已有属性的值
- 冻结一个对象后该对象的原型也不能被修改

<br>

**返回值:**  
被冻结的对象

```js
let obj = {
  name: "sam",
  age: 18,
}

Object.freeze(obj)

// 当我们试图修改对象中的属性值时 会静默不做任何处理
obj.name = "erin"
console.log(obj)
```

<br>

### **<font color="#C2185">Object.isFrozen(目标对象)</font>**
给定对象是否被冻结

<br>

**返回值:**   
boolean 

<br>

### **<font color="#C2185">Object.getOwnPropertyNames(目标对象)</font>**
返回指定对象的 所有自身属性 的属性名 构成的数组

<br>

**返回值:**  
对象属性名构成的数组

<br>

**示例:**
```js
const obj = {
  age: 18,
  name: "sam"
};

const names = Object.getOwnPropertyNames(obj)
console.log(names)
// ['age', 'name']

names.forEach(name => {
  console.log(name)
})
```

<br>

### **<font color="#C2185">Object.getPrototypeOf(目标对象)</font>**
返回指定对象的原型 (内部[[Prototype]]属性的值)。

<br>

**参数:**  
目标对象

<br>

**返回值**  
给定对象的原型。如果没有继承属性, 则返回 null 。

<br>

### **<font color="#C2185">Object.is(value1, value2)</font>**
判断两个值是否为同一个值

当我们需要考虑到 +0 和 -0 的情况 或者 NaN的情况的时候, 我们就使用该方法 它认为
- 两个NaN是相同的
- +0 和 -0是不同的

<br>

**返回值:**  
boolean

<br>

**特性:**  
- Object.is() 与 == 不同: Object.is 不会强制转换两边的值

- Object.is() 与 === 也不相同: 差别是它们对待有符号的零 和 NaN 不同
  - === 运算符(也包括 == 运算符)将数字 -0 和 +0 视为相等, 而将 NaN 与 NaN 视为不相等。

```js
// Case 1: Evaluation result is the same as using ===
Object.is(25, 25);                // true
Object.is('foo', 'foo');          // true
Object.is('foo', 'bar');          // false
Object.is(null, null);            // true
Object.is(undefined, undefined);  // true
Object.is(window, window);        // true
Object.is([], []);                // false
var foo = { a: 1 };
var bar = { a: 1 };
Object.is(foo, foo);              // true
Object.is(foo, bar);              // false

// Case 2: Signed zero
Object.is(0, -0);                 // false
Object.is(+0, -0);                // false
Object.is(-0, -0);                // true
Object.is(0n, -0n);               // true

// Case 3: NaN
Object.is(NaN, 0/0);              // true
Object.is(NaN, Number.NaN)        // true
```

<br><br>

# Math API
Math数学对象 不是一个构造函数, 所以我们不需要new 来调用 直接使用即可

<br>

### **<font color="#C2185">Math.PI</font>**
圆周率

<br>

### **<font color="#C2185">Math.floor()</font>**
向下取整, 往小了取值

<br>

### **<font color="#C2185">Math.ceil()</font>**
向上取整, 有小数就进1

<br>

### **<font color="#C2185">Math.abs()</font>**
可以用来计算一个数的绝对值

隐式转换 会把字符串型的-1 转换为数字型 如果不是数字型的 会是NaN
```js
Math.abs('-1')
```

<br>

### **<font color="#C2185">Math.round()</font>**
可以对一个数进行四舍五入 取整

.5会往大了取 所以当为-1.5的时候 会取-1 而不是 -2 因为-1 比 -2大

<br>

### **<font color="#C2185">Math.random()</font>**
可以用来生成一个0-1之间的随机数 0-1之间 不会出现0 和 1

```js
// 生成一个0-10的随机数
Math.random() * 10


// 生成一个0-x之间的随机数
Math.round(Math.random() * x)


// 生成一个x-y之间的随机数
Math.floor(Math.random() * (max - min)) + min


// 得到一个两数之间的随机整数包括两个数在内
Math.floor(Math.random() * (max - min + 1)) + min


// 封装函数
function getRandom(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min
}
```

<br>

### **<font color="#C2185">Math.max()</font>**
可以获取多个数中的最大值

```js
let arr = [10, 1, 2]
const max = Math.max(...arr)
console.log(max);


let arr = [10, 1, 2]
const max = Math.max.apply(this, arr)
console.log(max);
```

<br>

### **<font color="#C2185">Math.min()</font>**
可以获取多个数中的最小值

<br>

### **<font color="#C2185">Math.pow(x,y)</font>**
返回x的y次幂

<br>

### **<font color="#C2185">Math.sqrt()</font>**
开方

<br>

### **<font color="#C2185">Math.log()</font>**
返回给定数的自然对数(以e为底)

- 如果传递负数 则返回NaN
- 如果传递0 则返回 -Infinity

对数是求幂的逆运算 比如除法是乘法的倒数 反之亦然

如果 a的x次方等于n 那么x叫做以a为底n的对数
```
a^x = n 比如 2^3 = 8
```

假如我们要想求x 则使用可以  
```js
Math.log(8) / Math.log(2) = 次幂
```

<br><br>

# Date对象 (日期对象)
Date对象是一个构造函数, 必须使用new来调用创建我们的日期对象, **在js中使用Date对象来表示一个时间**

<br>

## Data对象的使用方式:
```js
let date = new Date()

console.log(date)
// Thu Jun 01 2023 21:51:25 GMT+0900 (日本标准时间)
```

<br>

### 参数:

**情况1: 空参**  
返回系统的当前时间

<br>

**情况2: 指定时间**
- 数字型: 2019,10,01
- 字符型: 
  - '2019-10-1 08:08:08'
  - "12/03/2016 11:10:30"
  - "2023,10,1"

<br>

### 注意:
- 如果输入的是 **数字型** 的时候 需要 实际月份-1
- 如果输入的是 **字符型** 则没有问题

```js
// 数字型参数的问题
let date = new Date(2023,10,1)
// 输出的月份 + 1
console.log(date)
// Wed Nov 01 2023 00:00:00 GMT+0900 (日本标准时间)


// 字符型参数无问题
let date = new Date("2023,10,1")
console.log(date)
// Sun Oct 01 2023 00:00:00 GMT+0900 (日本标准时间)
```

<br><br>

## 时间对象: API

### **<font color="#C2185">date.toLocaleString([locales [, options]])</font>**
该方法可以说 并不是时间体系单独的api 只要是对象都可以调用该方法 比如
- 时间对象
- 数字对象 等

用于返回格式化对象后的字符串, 该字符串格式因语言不同返回值也会不同(不同执行环境结果可能不同-比如浏览器和node会有所不同)

可以通过决定返回的语言和具体表现, 我们下面拿时间对象来举例

<br>

**返回当前系统时间 格式如下:**

```js
const date = new Date()

// 类似localDateTime
console.log(date.toLocaleString())
// 2023/6/1 22:00:11


// 类似localDate
console.log(date.toLocaleDateString())
// 2023/6/1


// 类似localTime
console.log(date.toLocaleTimeString())
// 下午11:13:00
```

<br>

**返回值:**  
根据当地语言规定 返回时间字符串

<br>

**参数:**  
有些浏览器因为兼容性 不支持locales和options参数
为了检测是否支持参数 我们可以做下检测
```js
function toLocaleStringSupportsLocales() {
  try {
    new Date().toLocaleString("i");
  } catch (e) {
    return e​.name === "RangeError";
  }
  return false;
}
```

<br>

**参数1: locales:**  
国家地区字符串

- 中国: "zh"
- 美国: "en-US"
- 英语: "en-GB"
- 韩国: "ko-KR"
- 日本: "ja-JP-u-ca-japanese" | "ja-JP"

<br>

**参数2: options:**  
类型对象, 我们分为两个部分进行介绍 key的部分 和 value的部分

key部分的可选值有:
- hour12: 是否为12小时制, 如果为false, 则是24小时制显示
- timeZone: 时区设置, 一般为UTC-格林尼治时间时区
- timeZoneName: 时区名称显示格式
- ear: 历法显示格式
- weekday: 星期显示格式
- year: 年份显示格式
- month: 月份显示格式
- day: 日期显示格式
- hour: 小时显示格式
- minute: 分钟显示格式
- second: 秒显示格式

<br>

value部分的可选值有:
- numeric: 正常数值显示 数字
- 2-gigit: 两位数字显示
- long: 完整显示 中文
- short: 缩写显示
- narrow: 窄缩写显示

```js
let date = new Date(2022,5,12,23,13)

console.log(date.toLocaleString("ja-JP", {
  year: "numeric",
  month: "long"
}))

// 2022年6月
```

```js
<div className="month">
  {props.date.toLocaleString("zh-CN", {month: "long"})}
</div>
```

<br>

### **<font color="#C2185">getFullYear()</font>**
该方法可以获取当前对象所封装的日期中的 **年份**

<br>

### **<font color="#C2185">getMonth()</font>**
该方法可以获取当前对象所封装的日期中的 **月份(0-11)**

它会返回0-11的值
- 0是1月
- 11是12月

注意: 得到的月份要+1 ``getMonth()+1``

<br>

### **<font color="#C2185">getDate()</font>**
该方法可以获取当前对象所封装的日期中的 **几号(1-31)**
```js
var d2 = new Date("12/03/2016 11:10:30");
var date = d2.getDate();
console.log("date = " + date);
```

<br>

### **<font color="#C2185">getDay()</font>**
该方法可以获取当前对象所封装的日期中的 **周几(0-6)**

它会返回0-6的值
- 0是周日
- 1是周1

```js
var d2 = new Date("12/03/2016 11:10:30");
var date = d2.getDate();
var day = d2.getDay();
console.log("day = " + day);
```

<br>

### **<font color="#C2185">.getHours()</font>**
时

<br>

### **<font color="#C2185">.getMinutes()</font>**
分

<br>

### **<font color="#C2185">.getSeconds()</font>**
秒

<br>

### 获取毫秒数
获取距离1970年1月1日开始到现在总的毫秒数(当前日期的时间戳)
指的是从格林威治标准时间的1970年1月1日0时0分0秒, 到当前日期所花费的毫秒数

<br>

**返回值:**  
毫秒数


```js
const time = +new Date()

const time = date.getTime()

const time = Date.now()
```

<br>

**场景: 测试代码的执行性能**  
```js
var start = Date.now();

for(var i=0; i<100; i++){
  console.log(i);
}

var end = Date.now();
console.log(end - start);
```

<br><br>

# 函数
在js里面, 可能会定义非常多的相同代码或者功能相似的代码, 这些代码可能需要大量重复使用

虽然for循环语句也能实现一些简单的重复操作, 但是比较具有局限性, 此时我们就可以使用js中的函数

就是封装了一段可被重复调用执行的代码块, 通过它可以实现大量代码的重复使用

普通对象像一个塑料袋只是一个容器 而函数对象可以封装一些功能(代码)在需要时可以执行这些功能(代码) 


使用typeof来检查一个对象时会返回 ``"function"``

<br>

### 函数的使用分为两大步
- 声明函数
- 调用函数

<br><br>

## 调用函数: 函数名()
当调用函数时函数中封装的代码会按照顺序执行, **函数对象具有所有普通对象的功能**

封装到我们函数中的代码不会立即执行仅仅是存起来了, 函数中的代码会在函数被调用的时候执行

<br><br>

## 创建函数: 构造函数
```js
var fun = new Function();
```

可以将要封装的代码以字符串的形式传递给构造函数
```js
// 这个相当于把我们的代码装到了字符串里
var fun = new Function("console.log('hello,这是我的第一个函数')");
```

<br><br>

## 创建函数: 函数声明
```js
function 函数名([形参1, 形参2, 形参N]) {
  语句...

  return 返回值
}
```

<br><br>

## 创建函数: 函数表达式
函数表达式声明方式 跟 声明变量差不多, 只不过变量里面存的是值, 而 函数表达式里存的是函数
```js
let 变量名 = function() {
  
};
```

<br><br>

## 函数的参数
- 在声明函数的小括号里面是形参
- 在函数调用的小括号里面是实参

我们可以在函数的()中来指定一个或者多个形参(形式上的参数没有任和值, 占地儿用)

多个形参之间用逗号隔开声明形参就相当于在函数的内部声明了对应的变量, 但是并不赋值

<br>

### 形参的赋值
在调用函数时可以通过实参赋值给函数中对应的形参

<br>

**注意:** 
调用函数时解析器不会检查实参的类型  

所以要注意是否有可能会接受到非法的参数 如果有可能则需要对我们的参数的类型进行一个检查

<br>

**规则:**
1. 如果实参的数量 多于 形参的数量 多余的实参不会被赋值

2. 如果实参的数量 少于 形参的数量 则没有对应的实参的形参将是undefined

3. 解析器不会检查实参的数量

<br><br>

## 函数的返回值
```js
function cook(aru) {
  console.log(aru);
}
cook('大肘子')
```

其实把输出语句写在函数内部是不合理的, 写在函数内部就好比是厨师把大肘子自己吃了, 不合理吧

按道理来说函数只是为了实现某种功能, 菜炒完了应该端给使用者 所以函数应该返回一个结果给调用者 这么做才是合理的

在实际开发里面, 我们经常用一个变量来接受函数的返回结果

<br>

### 关键字: return
有的时候, 我们希望函数将值返回给调用者, 此时通过使用return 语句就可以实现

只要函数遇到return 就把后面的结果 返回给函数的调用者

**语法:**  
```js
function 函数名() {
  return 需要返回的结果;
}
let 结果 = 函数名();
// 把返回的结果给调用者(函数名())
```

return后面的值将会作为函数的执行结果返回

函数一般是用来返回结果的并不需要函数做一些特殊处理, **在函数中return后的语句都不会执行**

因为结果已经被装进 return 值中了

<br>

**注意:**  
1. return 之后的代码不被执行
2. return 只能返回一个值, 如果想返回多个结果 可以利用数组 或者 对象
3. 函数没有return 返回undefined

<br>

### 函数名.length
它会输出该函数形参的数量, 但要注意它会排除默认值的情况
```js
function fn() {}
console.log(fn.length)  // 0

function fn(a) {}
console.log(fn.length)  // 1

// 当函数的参数有默认值的使用, fn.length 不包含默认值的参数 所以为0
function fn(a = 1) {}
console.log(fn.length)  // 0
```


<br><br>

## 函数的封装的概念
就是把一个或者多个功能通过函数的方式封装起来, 对外只提供一个简单的函数借口

简单理解: 封装类似于将电脑配件整合组装到机箱中

<br><br>

## arguments (类数组)
当我们不确定要传多少个参数的时候, 可以用arguments来获取

在js中, **arguments实际上它是当前函数的一个内置对象**, 所有函数都内置了一个arguments对象

arguments对象中存储了传递的所有实参

<br>

### arguments的使用:
```js
function fn() {
  console.log(arguments)
  console.log(arguments[0] + arguments[1] + arguments[2])
}
fn(1,2,3);
```

<br>

在调用函数时浏览器每次都会传递进两个隐含参数
1. 函数的上下文对象 this
2. 封装实参的对象 arguments 

<br>

### 类数组的概念
arguments是一个 伪 数组对象不是数组 类似数组

它也可以通过索引来操作数组也可以获取长度
1. 具有数组的length属性
2. 按照索引的方式存储的
3. 它没有真正数组的方法
4. 在调用函数时我们所传递的实参都会在arguments中保存
5. 我们即使不定义形参也可以通过arguments来使用实参
```js
arguments[0]  // 第一个实参
arguments[1]  // 第二个实参
```

<br>

### arguments.callee
该属性对应一个函数对象就是当前正在执行的函数对象调用谁, callee就是谁
```js
// 打印出了函数对象的整个内容 
console.log(arguments.callee); 
```

<br>

### 函数的实参可以是任意值
1. 可以是对象
2. 可以是函数

<br><br>

## 立即执行函数
函数定义完立即被调用这种函数叫做立即执行函数立即执行函数往往只会执行一次

**格式:**
```js
(function(){
  console.log("IFEE")
})()


(function(a,b){
  console.log(a + b)
}(1,2))
```

<br>

### 作用:
创建一个独立的作用域 所有的变量都是局部变量, 函数执行完毕变量自动释放

<br><br>

# 作用域
通常的来说, 一段程序代码中所用到的名字并不总是有效和可用的, 而限定这个名字的可用性的代码范围就是这个名字的作用域
作用域的使用提高了程序逻辑的局部性, 增强了程序的可靠性, 减少了名字的冲突

简单的来说, 就是代码名字在某个范围内起作用和效果, 作用域指一个变量的作用的范围

<br><br>

## 作用域的分类:
1. 全局作用域
2. 局部作用域

<br>

### 全局作用域
整个script标签, 或者 是一个单独的js文件 全局作用域中的变量都是全局变量, 在页面的任意部分都可以访问的到

在函数内部没有声明 直接赋值的变量也是全局变量

<br>

**全局作用域的生命周期:**
- 页面打开时创建
- 页面关闭时销毁

在全局作用域中有一个全局对象window它代表的是一个浏览器窗口, 它由浏览器创建我们可直接使用 

<br>

**在全局作用域中:**  
- 创建的变量都会作为window对象的属性保存
- 创建的函数都会作为window的方法来保存

```js 
var a = 10;
console.log(a);
//这个a是保存在window的属性里

console.log(window.a)
//我们来试一下看看能不能打出 10


function fun(){
  console.log("我是fun函数");
}
window.fun();
window.alert(); 
```

<br>

### 扩展:
使用 var 和 函数声明 方式 定义的 属性 和 方法 会 挂载在window上

是用 let 和 const 声明的变量 不会挂载在window上

<br>

**全局环境是一个复合环境** 由下面的两个环境组成
- global(顶层对象)
- declsEnv(一般声明环境)

ES6之后 let const class 命令声明的全局变量 不属于顶层对象的属性 而是在一般声明环境 declsEnv 中

var声明的变量在 Global 中

<br>

### 局部作用域(函数作用域):
在函数内部就是局部作用域 这个代码的名字值在函数内起效果和作用

如果全局作用域像一个学校的话那么函数作用域就相当于一个个的班级

在局部作用域下的变量, 或者在函数内部的变量就是 局部变量, 局部变量只能在函数内部使用 **函数的形参也是局部变量**

```js 
function fn() {
  // 局部作用域
}
```

<br>

**全局作用域的生命周期:**
- 调用函数时 创建函数作用域函数
- 执行完毕后 函数作用域销毁

每调用一次函数就会创建一个新的函数作用域它们之间相互是独立的

班级中可以访问到全局作用域里的变量, 在全局作用域中无法访问到函数作用域的变量 

<br><br>

## 作用域链 (查找变量的规则)
只要是代码就有作用域 写在函数内部的就是局部作用域

如果函数中还有函数, 那么在这个作用域中就又可以诞生一个作用域

根据在内部函数可以访问外部函数变量的这种机制, 用链式查找决定哪些数据能被内部函数访问, 就称作作用域链

```js
let num = 10;

// 外部函数
function fn() {
  let num1 = 20;

  // 内部函数
  function fn2() {
    console.log(num1);  
    // 内部函数可以访问外部函数的变量
  }
}
```

<br>

### 总结: 就近原则
内部函数访问外部函数的变量, 采取的是链式查找的方式来决定取哪个值, 这种结构我们称为作用域链 一层一层依次向外层查找

多个上下级关系的作用域形成的链它的方向是从下向上或者从内到外, 查找变量时就是沿着作用域链来查找的 最外层的可以叫做0级链

<br>

### 变量的查找规则
当在函数作用域中操作一个变量时会先在自身的作用域中寻找如果有就直接使用

如果没有就向上一级进行寻找注意是上一级直到找到全局作用域
如果全局作用域也没有会报错

在函数中要访问全局变量可以使用window对象

在函数作用域中也有声明提前的特性

使用var关键字声明的变量会在函数中所有的代码执行之前被声明
函数声明也会在函数中所有的代码执行之前执行

<br><br>

# 预解析
js代码是由浏览器中的js解析器(引擎)来执行的, **js解析器在运行js代码的时候分为两步:**
- 预解析
- 代码执行

<br>

### 预解析: 变量提升
js引擎会把js里面所有的 var 还有 function 提升到 当前作用域 的最前面

预解析分为 变量预解析(变量提升) 和 函数预解析(函数提升)

<br>

**注意:**  
函数的变量会被优先提升到作用域的顶层, 然后在是var的变量

- function 在上
- var 在下

<br>

函数提升优先级比变量提升要高, 且不会被变量声明覆盖, 但是会被变量赋值覆盖。

```js
var aaa

function aaa() {
  console.log("aaa")
}

console.log(aaa)  // 输出 aaa 函数
```

上述代码相当于

```js
1. 函数aaa在作用域的顶层
2. var aaa

// 但是 函数aaa不会被 var aaa 声明覆盖, 因为没有覆盖掉所以下面仍然输出 aaa 函数


console.log(aaa)  // 输出 aaa 函数
```

<br>

如果是下面的结构 则会输出 1 因为函数aaa被变量赋值覆盖了

```js
var aaa = 1

function aaa() {
  console.log("aaa")
}

console.log(aaa)
```

<br>

同一个标识符的情况下, 变量声明与函数声明都会提升; 函数声明会覆盖变量声明, 但不会覆盖变量赋值, 即: 如果声明变量的同时初始化或赋值那么变量优先级高于函数。

提升按照书写顺序提升 不分变量 和 函数提升的优先级的问题 

```js
var a = 4
function a() {
  console.log("a")
}

// 函数先提升 被 a = 赋值 覆盖
console.log(a)
```

<br>

### 变量提升:
就是把所有的变量声明提升到当前的作用域的最前面 只提升声明 不提升赋值

**变量提升不能跨 script**
```js
console.log(num)    //undefined
var num = 10;

  ↓

var num;
console.log(num);
num = 10;
```

```js 
fun(); // 报错 fun不是一个函数
var fun = function() {
  console.log(22);
}

  ↓

var fun;
fun();
fun = function() {
  console.log(22);
}
```

<br>

### 函数提升:
就是把所有的函数声明提升到当前作用域的最前面, 不调用函数
```js
fn();
function fn() {
  console.log(2);
}

  ↓

 // 把整个函数声明提升到作用域的最前面
function fn() {     
  console.log(2);
}
fn();
```

<br>

### 案例:
```js 
f1();
console.log(c);
console.log(b);
console.log(a);

function f1() {
  var a = b = c = 9;
  console.log(a);
  console.log(b);
  console.log(c);
}

  ↓
// 函数先提升到最前面
function f1() {             
  var a = b = c = 9;
  // 相当于: var a = 9;  b = 9;  c = 9;
  // 如果想多个赋值的话: var a = 9, b = 9, c = 9
  console.log(a);
  console.log(b);
  console.log(c);
}
f1();
console.log(c);
console.log(b);
console.log(a);
// 报错  函数内部的变量访问不到会报未定义的错
```

<br><br>

# 基本包装类
```js
let str = 'andy';
console.log(str.length);
```

<br>

**思考:**  
为什么会有str.length的属性, 前面说过, 只有复杂的数据类型才有 属性和方法

简单数据类型为什么length属性呢?

<br><br>

## 基本包装类型
就是把简单数据类型 包装成 复杂数据类型

简单的两行代码 其实内部进行了如下的操作
```js
// 包装的类型
let str = 'andy';
console.log(str.length);

// 1. 把简单数据类型包装为复杂数据类型
let temp = new String('andy');

// 把临时变量的值 给str 这样str就变成复杂数据类型就有属性和方法了
str = temp;

// 销毁临时变量
temp = null;
```

在js中为我们提供了三个包装类通过这三个包装类可以将基本数据类型的数据转换为对象, 三个包装类都是什么呢?

<br>

### **<font color="#C2185">String()</font>**
可以将基本数据类型的字符串转换为String对象
```js
var str = new String();
```

<br>

### **<font color="#C2185">Number()</font>**
可以将基本数据类型的数值转换为Number对象
```js
var num = new Number();
```

<br>

### **<font color="#C2185">Boolean()</font>**
可以将基本数据类型的布尔值转换为Boolean对象
```js
var bool = new Boolean();
```

```js
var num = new Number(3);
var num2 = new Number(3);
var str = new String("hello");
var str2 = new String("hello");
var bool = new Boolean(true);
```

<br>

**注意:**  
我们在实际应用中不会使用基本数据的对象, 因为在用基本数据类型的对象做比较时会带来一些不可预料的结果 

既然不让我们用它们有什么用呢? 浏览器底层自己会用 方法和属性只能添加给对象不能添加给数据类型

<br><br>

## 字符串不可变
指的是里面的值不可变, 虽然看上去可以改变内容, 但是其实是地址变了, 内存中新开辟了一个内存空间 

**因为我们的字符串的不可变所以不要大量的拼接字符串, 不断的拼接字符串会不断的创建新的内存空间**

```js
let str = 'andy';
console.log(str);   // andy

str = 'red'
console.log(str)    // red
```

上面看上去虽然字符串值发生了变化 实际上在重新赋值为red时, 是新开辟了一个块空间, str指向了这个空间, 而andy还是在的

所以不要大量的对字符串进行重新赋值, 也不要大量拼接字符串, 因为都会开辟新的空间

<br><br>

# 字符串
字符串的所有方法, **都不会修改字符串本身**(字符串是不可变的), 操作完成后会返回一个新的字符串

<br>

### **<font color="#C2185">str.length属性</font>**
可以获取字符串的长度

<br>

### **<font color="#C2185">str[index]</font>**
H5 IE8+支持, 和charAt()等效

<br>

### **<font color="#C2185">str.charAt(index)</font>**
根据索引返回指定位置的字符

<br>

**参数:**  
index, 默认值: 0

```js
str = "hello,Atguigu";
var result = str.charAt(0);

//索引为0的元素上面的式子还可以这么写
var result = str[6];
console.log(result);         //h
```

<br>

### **<font color="#C2185">str.charCodeAt(index)</font>**
根据索引返回指定位置的字符的ASCII编码

我们键盘上的每一个键位都会对应一个ASCII码 我们可以判断用户按了哪个键

```js
let str = "sam"

// 默认值为0
let code = str.charCodeAt()
console.log(code)   // 115
```

<br>

### **<font color="#C2185">String.fromCharCode()</font>**
静态方法

可以根据字符编码去获取字符

表示16进制的时候要以0x开头, 另外它可以获取Unicode编码中的字符

```js
const str2 = String.fromCharCode(115)
console.log(str2);
```

<br>

### **<font color="#C2185">str.concat(str2, [, ...strN]))</font>**
将一个或多个字符串与原字符串连接合并, 形成一个新的字符串并返回。

<br>

**参数:**  
需要连接的字符串

<br>

**注意:**  
强烈建议使用赋值操作符(+, +=)代替 concat 方法。

<br>

### **<font color="#C2185">str.endsWith()</font>**
用来判断当前字符串是否是以另外一个给定的子字符串"结尾"的

<br>

**参数:**  
子串

<br>

**返回值:**  
boolean

```js
let str = "demo.jpg"
console.log(str.endsWith(".jpg"))
```

<br>

### **<font color="#C2185">str.startsWith()</font>**
用来判断当前字符串是否以另外一个给定的子字符串开头

<br>

**返回值:**  
boolean

<br>

### **<font color="#C2185">str.includes()</font>**
用于判断给定字符串是否包含在str中

<br>

**参数:**  
1. searchString: 要搜索的字符串
2. position: 开始搜索的位置

<br>

**返回值:**  
boolean

```js
let str = "demo.jpg"
console.log(str.includes("."))  // true
```

<br>

### **<font color="#C2185">str.indexOf()</font>**
检索给定字符串是否在str中

<br>

**返回值:**  
给定字符串 第一次出现的索引, 如果没有找到 返回 -1

<br>

**参数:**  
1. 给定字符串(默认值: undefined)
2. fromIndex 默认值: 0

<br>

**注意:**  
1. 当我们查找的是空值的时候 会返回0
2. 当我们传入fromIndex 并查找空值的时候 会返回 fromIndex
```js
let str = "demo.jpg"
console.log(str.indexOf(""))    //0

'hello world'.indexOf('', 11) // 11
```

3. indexOf()区分大小写

<br>

**示例:**  
统计字符串中 **某个字母** 出现的次数
```js
var str = 'To be, or not to be, that is the question.';

var count = 0;
var pos = str.indexOf('e');

while (pos !== -1) {
  count++;
  pos = str.indexOf('e', pos + 1);
}

console.log(count); // 4
```

<br>

### **<font color="#C2185">str.lastIndexOf()</font>**
该方法的用法跟indexOf一样不同的是indexOf是从前往后找, 而lastIndexOf是从后往前找

可以传递第二个参数来决定开始查找的位置

<br>

### **<font color="#C2185">str.localeCompare(str2, [locales], [options])</font>**
用于比较两个字符串并返回一个表示比较结果的数字

- 如果 str1 < str2 则返回 -1
- 如果 str1 > str2 则返回 1
- 如果相等 则返回0 

```js
arr.sort((a, b) => {
  return b.localeCompare(a)
})
```

前面接触过该方法 大致的使用方式如下 下面我们介绍下该api的可选参数

<br>

**参数:**  
- str2: 比较的字符串
- locales: [可选] 指定用来排序的语言
- options:
```js
{
  // 默认值: best fit
  localeMatcher: lookup | best fit,
  // 指定比较的目标是排序或者是搜索 (默认值: sort)
  usage: sort | search,
  // 指定排序程序的敏感度 (默认值: sort)
  sensitivity: sort | search,

}
```

```js
let str1 = "a"
let str2 = "b"

let res = str1.localeCompare(str2)
console.log(res)    // -1


let str1 = "c"
let str2 = "b"

let res = str1.localeCompare(str2)
console.log(res)    // 1
```

<br>

**注意:**  
locales 和 options 不是所有的浏览器都支持

<br>

### **<font color="#C2185">str.match()</font>**
根据 正则 | 给定字符 返回匹配的结果(字符串数组)

<br>

**参数:**  
正则表达式 | 字符串

(如果我们传入的是字符串 会隐式的使用 new RegExp() 对其进行转换)

<br>

**返回值:**  
返回值分为两种情况

1. 使用 g 模式: 会将所有的匹配的结果放在数组中返回
```js
var str = 'To be, or not to be, that is the question.';

const res = str.match(/e/g)
console.log(res)
// ['e', 'e', 'e', 'e']
```

2. 不使用 g 模式: 仅返回第一个匹配的结果 已经相关的详细信息

```js
const res = str.match(/e/)
console.log(res)

[
  0: "e"  // 匹配结果

  // 一个命名捕获组对象, 其键是捕获组名称, 值是捕获组, 如果未定义命名捕获组, 则为 undefined
  group: undefind,

  // 匹配的结果的开始位置
  index: 4,

  // 原字符串
  input: "To be, or not to be, that is the question.",
  length: 1
]
```

<br>

- 如果**没有传递任何参数** 则返回的就是 [""]
- 如果**没有匹配成功** 则返回 null

<br>

**示例:**   
```js
let str = 'For more information, see Chapter 3.4.5.1';

let reg = /see (chapter \d+(\.\d)*)/i;
let res = str.match(reg)

console.log(res)


[
  // 'see Chapter 3.4.5.1' 是整个匹配。
  'see Chapter 3.4.5.1',

  // 'Chapter 3.4.5.1' 被'(chapter \d+(\.\d)*)'捕获。
  'Chapter 3.4.5.1',

  // '.1' 是被'(\.\d)'捕获的最后一个值。
  '.1',

  // 'index' 属性 (22) 是整个匹配从零开始的索引。
  index: 22,
  input: 'For more information, see Chapter 3.4.5.1',
  groups: undefined
]
```

<br>

### **<font color="#C2185">str.matchAll()</font>**
根据指定的 正则 或 字符串 查找目标字符串

<br>

**参数:**  
正则表达式 | 字符串

- 传入正则 需要添加 g 模式
- 字符串不用

<br>

**返回值:**  
迭代器, 迭代器可以通过 for ... of 或者使用 Array.from(迭代器) 将迭代器转换为数组后 通过数组的方法进行遍历

<br>

迭代器中的每个元素为
```js
[
  0: "e",
  group: undefind,
  index: 4,
  input: "To be, or not to be, that is the question.",
  length: 1
]
```

<br>

**示例:**  
```js
let str = "test1test2"

// 必须使用 g
let reg = /t(e)(st(\d?))/g

// res 是 迭代器 里面有单个详情的 匹配结果
let res = str.matchAll(reg)

/*  
**res:**  
[
  [
    'test1',
    'e',
    'st1',
    '1',
    index: 0,
    input: 'test1test2',
    groups: undefined
  ],
  [
    'test2',
    'e',
    'st2',
    '2',
    index: 5,
    input: 'test1test2',
    groups: undefined
  ]
]
*/

// 可以将迭代器 转换为数组 或者使用数组的方法操作
Array.from(res).map(item => {
  console.log(item)
})

for (let matched of res) {
  console.log("matched", matched)
}

const array = [...str.matchAll(regexp)];
console.log(array[0])
```

<br>

### **<font color="#C2185">str.padEnd(num:指定长度, "用什么字符来补位")</font>**

### **<font color="#C2185">str.padStart(num:指定长度, "用什么字符来补位")</font>**
```js
'x'.padStart(5, 'ab')
```

<br>

**返回值:**  
新的str

如果省略第二个参数 默认使用空格补全长度

<br>

**应用场景:**  
为数值补全指定位数
```js
'1'.padStart(10, '0') // "0000000001"
```

<br>

提示字符串格式
```js
'12'.padStart(10, 'YYYY-MM-DD')
```

<br>

### **<font color="#C2185">str.replace(给定部分, 指定部分)</font>**
将 str 中 **给定部分** 替换成 **指定部分** 并将结果返回

<br>

**返回值:**  
新的字符串

<br>

**参数:**  
- 给定部分: 字符串 | 正则表达式
  - 传入字符串的话, 仅第一个匹配结果会发生替换
  - 传入正则的话, 可以通过 g 模式 开启全局匹配替换

- 指定部分: 字符串 | 模版字符串 | 回调
  - 字符串: 简单的将 a -> b

  - 模版字符串: 可以在新内容的文本中使用如下的 模版字符串
    - $$: 代表一个$
    - $&: 代表匹配的子串
    - $`: 代表匹配子串左侧的所有内容
    - $': 代表匹配子串右侧的所有内容
    - $n: 第几组
    - ``$<Name>``: 分组名

  - 回调: (matched, [group1, ...], postion, originString) => { return 替换成什么 }
    - 当为g模式的时候 每发生一次匹配则回调会执行一次
    - 回调的返回值会作为 替换的字符串
    - matched: 匹配的字符串
    - group: 如果正则中进行了分组 则有几组就有几个group, 没有的话则没有该参数
    - position: 匹配子串的位置
    - originString: 原字符串

```js
// 指定部分: 字符串
var str = 'To be, or not to be, that is the question.';

const res = str.replace(/e/g, "xx")
console.log(res)


// 模版字符串
var str = 'this is a dog, this is a cat';
console.log(str)
const res = str.replace(/a/, "$&新内容")
console.log(res)


// 回调
var str = 'this is a dog, this is a cat';
const res = str.replace(/(a)/g, (matched, group1, position, originString) => {
  return "替换部分"
})
console.log(res)
```

<br>

**需求: 将 ``abc12345#$*%`` -> ``abc - 12345 - #$*%``**  
```js
let str = "abc12345#$*%"
let reg = /([a-z]+)(\d+)([^\w+])/

str = str.replace(reg, (_, s1, s2, s3) => {
return `${s1} - ${s2} - ${s3}`
})

console.log(str)
```

<br>

**需求: 交换字符串中的两个单词**
```js
var re = /(\w+)\s(\w+)/;
var str = "John Smith";
var newstr = str.replace(re, "$2, $1");
// Smith, John
console.log(newstr);
```

<br>

**需求: 首大写字母改小写后 前面 + "-"**
```js
var newString = propertyName.replace(/[A-Z]/g, '-' + '$&'.toLowerCase());  // won't work
```

<br>

**需求: 在匹配到的部分前后追加标签**
```js
// 我们给教育加上链接
<main>
  在线教育是一种高效的学习方法
</main>

main.innerHTML = 
main.innerHTML.replace(/教育/, `<a href="www.baidu.com">$&</a>`)
```

<br>

### **<font color="#C2185">str.replaceAll(给定部分, 指定部分)</font>**
将 str 中 给定部分 替换成 指定部分 并将结果返回

<br>

**注意:**  
模式必须为 g

<br>

```js
/*
  $& 表示匹配的字符串, 即`b`本身
  所以返回结果与原字符串一致
*/
'abbc'.replaceAll('b', '$&')    // 'abbc'
  

/*
  $` 表示匹配结果之前的字符串
  对于第一个`b`, $` 指代`a`
  对于第二个`b`, $` 指代`ab`
*/
'abbc'.replaceAll('b', '$`')
// 'aaabc'


/*
  $' 表示匹配结果之后的字符串
  对于第一个`b`, $' 指代`bc`
  对于第二个`b`, $' 指代`c`
*/
'abbc'.replaceAll('b', `$'`)
// 'abccc'


/*
  $1 表示正则表达式的第一个组匹配, 指代`ab`
  $2 表示正则表达式的第二个组匹配, 指代`bc`
*/
'abbc'.replaceAll(/(ab)(bc)/g, '$2$1')
// 'bcab'


// $$ 指代 $
'abc'.replaceAll('b', '$$')
// 'a$c'
```

<br>

### **<font color="#C2185">str.search()</font>**
根据正则 或 字符串 返回匹配部分在str的首次出现的 **索引**

<br>

**参数:**  
字符串 | 正则

如果传递字符串吗默认会被 new RegExp(regexp) 隐式地将其转换为正则表达式对象。

<br>

**返回值:**  
index

```js
let str = "abc12345#$*%abc"

let reg = /[a-z]/g

let res = str.search(reg)
console.log(res)    // 0
```

<br>

**兼容性:**  
不好 几乎全红

<br>

### **<font color="#C2185">str.slice()</font>**
可以从字符串中截取指定的内容 不影响原字符串而是将截取到的内容返回

<br>

**参数:**  
- start: 开始索引(包括)
- end: 结束索引(不包括)

如果省略 end 则从开始截取到最后 如果是负数 则从后面开始计算, start end 都可以传递负数 最后一位为-1

```js
let str = "abcderrtg";
let res = str.slice(0,2);

console.log(res);   //ab


let str = "abcderrtg";
let res = str.slice(-3);

console.log(res);   // rtg
```

<br>

### **<font color="#C2185">str.substring()</font>**
可以用来截取一个字符串和slice类似

<br>

**参数:**  
- start: 开始索引(包括)
- end: 结束索引(不包括)

省略 end 就是从开始的全部

<br>

**注意:**  
这个方法**不能接受负值**

如果传递了一个负值则默认使用0 他会自动调整参数的位置如果第二个参数小于第一个则自动交换
(1 0) 自动交换 (0 1) 

<br>

### **<font color="#C2185">str.substr() -- 废弃了</font>**
用来截取字符串对原数组没有影响

**参数:**  
1. 截取开始位置的索引
2. 截取的长度

<br>

### **<font color="#C2185">arr.join()</font>**  
将数组转为字符串

<br>

### **<font color="#C2185">str.split()</font>**
将字符串转为数组  
传入一个指定的分隔符 或 正则 根据指定部分将str拆分成数组

<br>

**参数:**  
1. 分隔符 或 正则
2. limit: 整数, 限定返回的分割片段数量, 如设置为3 则数组中有3个片段

<br>

**注意:**  
- 如果不传递参数 则原字符串作为整体 放在数组中返回 ``[ 'abc,12345#$*%' ]``
- 如果传入空串 "" 则每个字符会被单独作为数组中的元素

```js
let str = "The quick brown fox jumps over the lazy dog";

let res = str.split(" ", 3)
console.log(res)

// [ 'The', 'quick', 'brown' ]

```

<br>

### **<font color="#C2185">str.toLowerCase()</font>**
### **<font color="#C2185">str.toUpperCase()</font>**
把字符串转换为小写, 并返回 不会影响到原字符串

```js
str = "abcffsdf"
result = str.toLowerCase();
console.log(result);
```

<br>

### **<font color="#C2185">str.trim() </font>**
去除字符串两端空格

<br>

### **<font color="#C2185">str.trimEnd()</font>**
去除字符串末尾空格

<br>

### **<font color="#C2185">str.trimStart()</font>**
去除字符串开始空格

<br><br>

# 引用数据类型: 

**js中的数值类型:**  
- String
- Number
- Boolean
- Null
- Undefined

<br>

**引用数据类型:**  
- Object

<br>

### 说明1
```js
var a = 123;
var b = a;

a++;  // a自增后b的值是多少?
```

答案是 b并没用发生改变 a和b的值完全是独立的 一个值发生了变化并不影响另外一个值 

<br>

### 说明2
```js
var obj = new Object();
obj.name = "孙悟空";

var obj2 = obj

console.log(obj.name);      //孙悟空
console.log(obj2.name);     //孙悟空

// obj.name 和 obj2.name都是孙悟空 接下来我们修改obj的name属性: 
obj.name = "猪八戒";
console.log(obj.name);      // 猪八戒
console.log(obj2.name);     // ?  猪八戒
```

也就是说修改一个变量也影响到另一个了！ 这就是引用数据类型和基本数据类型的区别 

<br>

### 基本数据类型 和 引用数据类型的区别:
js中的变量都是保存在栈内存 按照 变量 和 值的模式 保存

<br>

### 基本数据类型:
基本数据类型的值 直接在栈内存中存储   
值与值之间是独立存在的, 修改一个变量并不会影响其他的变量

<br>

解释如下 想象成两列的表 左边的是变量 右边的是值
```js
var a = 123;
// 就是我在栈内存的 左列存了个a 右列存了值123

var b = a;
// 就是我在栈内存的左列存了个b 右列的值是从a的值复制过来的 a和b都是123但是a的123和b的123没关系是互相独立的

a++;
// a现在自增了此时对变量b产生影响了么?没有a爱咋变咋变和b没关系
```

<br>

### 结构图
变量和值在内存中的结构

```js
var a = 123;
var b = a;
```

|栈内存|堆内存|
|:--|:--|
|属性名|属性值|
|a|123|
|b|123(从a的123复制来的)|

<br>

### 引用数据类型:
引用数据类型的值(对象)是保存在堆内存中的  
每创建一个新的对象就会在堆内存中开辟出一个新的空间

**而变量保存的是对象的内存地址(对象的引用)**

如果两个变量保存的是同一个对象引用时, 当一个通过一个变量修改属性时另一个也会受到影响

解释如下, 想象成左边是栈内存为2列的表 右边是堆内存为一个整体

```js
var obj = new object();

// 首先是创建了一个变量所以把变量保存在左侧栈内存左列中的格子里值保存在哪?
```

一旦看见new就意味着 我要在堆内存里开辟出一个新的空间 这个空间专门用来保存这个对象的

因为变量在栈内存中 而对象在堆内存中 所以它们之间没有关系 要用变量就操作不了对象

既然对象保存在堆内存的一个空间里 那么这块空间就会有一个对应的内存地址(比如是ox123)

这个内存空间的地址就是专门来保存 obj这个对象的

<br>

### 堆内存中的对象 和 栈内存中的变量 是怎么建立联系的?
栈内存变量里保存的其实是内存地址

<br>

想象成 栈内存左列中为obj右列中为 对象的内存地址ox123, 也就是说对象本身是没有名字的有的只是一串内存地址

```
栈空间            堆空间
|obj|地址值|  ->  ox123
```

现在我往obj里添加了一个name属性叫孙悟空 那么我是我往变量里面添加的么?

不是吧, 我们是往变量里对应的地址对应的对象里添加的 所以我们是通过地址在右侧堆内存中 刚才创建的对象空间中 添加的孙悟空 
```js
var obj = new object();
obj.name = "孙悟空";

// 如果:
var obj2 = obj;         //相当于把内存地址给了obj2
```

<br>

### **<font color="#C2185">结构图</font>**
```js
      栈内存         堆内存(内存地址: 0x123)
变量名       值          name:孙悟空     
  a         123
obj        0x123   ↗
obj2       0x123   ↗
```

<br>

**假如:**  
```js
obj2 = null;
```

相当于我修改了obj2的值之前存的是内存地址  
现在为null但只是少了链接地址并没有对堆内存的空间产生影响只是断了联系 

<br>

**注意:**  
两个一模一样的对象(内容相同) 做全等比较 也是false

<br><br>

# 简单类型 和 复杂类型
简单类型又叫做基本数据类型或者值类型, 复杂类型又叫做引用类型

<br>

### 值类型
简单数据类型(基本数据类型), 在存储时变量中存储的是值本身, 因此叫做值类型

```
string number boolean undefined null
```

null 返回的是 空的对象, 如果有个变量我们以后打算存储为对象, 暂时没想好放啥, 这个时候就给null

<br>

### 复杂数据类型(引用类型)
在存储时变量中存储的仅仅是地址(引用) 因此叫做引用数据类型

通过new关键字创建的对象(系统对象, 自定义对象), 如Object Array Date等

<br><br>

# 堆和栈

### 栈(操作系统)
简单数据类型 是存放在栈里面, 里面直接开辟一个空间 存放的是 值

<br>

### 堆(操作系统)
复杂数据类型 首先在栈里面存放地址, 16进制表示 然后这个地址指向堆里面的 数据

<br>

### 简单类型传参
函数的形参也可以看做是一个变量, 当我们把一个值类型变量作为参数传给函数的形参时, **其实是把变量在栈空间里的值复制了一份给形参**

那么在**方法内部对形参做任何修改, 都不会影响到外部变量**

```js
function fn(a) {
  a++;
  console.log(a);     11
}

let x = 10;

fn(x);

console.log(x);         10
```

<br>

**总结: 简单类型的传参是 值传递**  

<br>

### 复杂数据类型的传参:
x 赋值给 p 是地址 两个变量指向同一个对象 其中一个修改后 另一个也有影响
```js
function Person(name) {
  this.name = name;
}

function f1(x) {
  console.log(x.name);        // 刘德华
  x.name = '张学友'
  console.log(x.name);        // 张学友
}

let p = new Person('刘德华')
console.log(p.name);          // 刘德华
f1(p);
console.log(p.name)           // 张学友
```

<br><br>

# 名词解释: 

### API:
预定义的函数, 给程序员提供的一种工具, 以便能更轻松的实现想要完成的功能

<br>

### Web API:
是浏览器提供的一套操作浏览器功能 和 页面元素的API(BOM DOM)

<br><br>


# JS的执行机制

### js是单线程
js语言的一大特点就是单线程, 也就是说, 同一个时间只能做一件事, 这是因为js这门脚本语言诞生的使命所致

js是为了处理页面中的用户的交互, 以及操作DOM而诞生的

比如我们对某个DOM进行添加和删除操作, 不能同时进行, 应该先进行添加, 之后再删除 要不这个代码还没有呢 怎么删

<br>

### 单线程:
**所有任务需要排队 前一个任务结束, 才会执行后一个任务, 这样所导致的问题是:**  

如果某一个js代码执行的时间过长, 后面的代码就需要排队, 等好长时间 这样就会造成页面的渲染不连贯, 导致页面渲染加载阻塞的感觉

<br><br>

## 同步 异步
为了解决前一个代码执行完 才能 执行后一段代码的问题, 我们利用了多核cpu的计算能力, HTML5提出了web worker标准, 允许js脚本创建多个线程, 于是js中出现了同步和异步


<br>

### 同步:
前一个任务结束后 再执行后一个任务, 程序的执行顺序与任务的排列顺序是一致的, 同步的

比如: 做饭的同步做法, 我要烧水煮饭, 等水开了(10分钟) 再去切菜 炒菜

<br>

### 异步:
在做一件事情的时候, 因为这件事情会花费很长时间, 在做这件事的同时, 你还可以去处理其他的事情

比如做饭的异步做法, 我们在烧水的同时, 利用这10分钟去切菜 炒菜

<br>

### 总结:
本质区别就是 这条流水线上各个流程的执行顺序不同 

<br>

js为了解决排队或者等待时间较长的问题 把我们的任务分为了两大类

<br>

### 同步任务:
同步任务都在**主线程上执行**, 形成一个执行栈

<br>

### 异步任务:
js的异步是通过回调函数实现的

异步任务相关的回调函数 添加到 **任务队列**中(任务队列也成为消息队列)

常见的异步任务
- 普通事件: onclick
- 资源加载: load error
- 定时器: setInterval


```js 
console.log(1);

setTimeout(function(){
  console.log(2);
}, 0);

console.log(3);
```

```
执行栈                    任务队列        
console.log(1)   function fn(){ log(3) }

setTimeout(fn, 0)     ↗

console.log(3)
```


<br>

### js的执行顺序
先执行 执行栈中的同步任务

异步任务(回调函数)先放到 任务队列中 先不执行

一旦执行栈中的所有同步任务执行完毕, 系统就会按次序读取任务队列中的异步任务, 于是被读取的异步任 务结束等待状态, 进行执行栈(放入执行栈的下方代码的后面), 开始执行

- 任务队列有点像应急车道
- 执行栈有点像主车道

<br><br>

# JSON
创建一个对象
```js
// 以前说过 写属性名的时候 可以加引号或者不加 加了也不算错 name == "name"
var obj = {
  name: "孙悟空"
};

var obj = {
  "name": "孙悟空",
  "age": 18,
  "gender": "男"
};

console.log(obj.age);
```

<br>

### obj 和 json之间的关系
以后我们开发的时候 不是只有一个页面 往往有前端和后台服务器, 网页和服务器之间要交互数据

现在我要把上面的对象传递给服务器 服务器是java写的能传过去么?

不能传 js 和 java互相不认识, 也就是js中的对象只有js自己认识其他的语言都不认识

现在的问题就是 需要把对象传递给java, 能不能将这个对象 **转换成 所有语言都认识的东西**

既然对象不认识 能不能将这些东西转换成 大家都认识的东西呢 
比如 number string boolean, 那给对象 **转换为 字符串**

```js
var obj = {
  "name":"孙悟空",
  "age":18,
  "gender":"男"
};

// 转换: 下面的值部分加不加""后可以 正常我们输出的时候是不带""的
var obj = "{
  "name":"孙悟空",
  "age":18,
  "gender":"男"
}"
```

<br>

JSON就是一个特殊格式的字符串这个字符串可以被任意的语言所识别

并且可以转换为任意语言中的对象 JSON在开发中主要用来**数据的交互**


<br><br>

### JSON API:
JavaScript Object Notation JS对象表示法

JSON和JS对象的格式一样只不过JSON字符串中的属性名必须加双引号, 其他的和JS语法一致

<br>

### JSON的写法
1. 对象 {}
```json
var obj = {"name":"孙悟空", "age":18, "gender":"男"}
```

2. 数组 []
```js
var arr = [3,4,5]
```

<br>

### JSON中允许的值
1. 字符串
2. 数值
3. 布尔值
4. null
5. 对象(普通对象)
6. 数组

<br>

**函数和undefined不行 函数只有js自己认识**  

<br>

json对象写好了数据到后台了 那怎么才能用? 要是想取的话 得把
```js
var obj = '{"name":"孙悟空", "age":18, "gender":"男"}'
```

转换为对象, 我需要一个方法 将一个字符串 转换为 对象

将JSON字符串转换为JS中的对象, 在JS中为我们提供了一个工具类就叫JSON 

这个对象可以帮助我们将一个JSON转换为JS对象也可以将一个JS对象转换为JSON

<br>

### json -> js对象
### **<font color="#C2185">JSON.parse()</font>**
可以将以JSON字符串转换为js对象

它需要一个JSON字符串作为参数 会将该字符串转换为JS对象并返回
```js
var o = JSON.parse(json);   //它的返回值应该是对象
console.log(o.age);
// var obj3 = {name:"猪八戒" , age:28 , gender:"男"};
```

<br>

**参数:**  
1. 目标对象
2. (key, value) => { ... }, 在函数中可以对属性值的部分进行加工 最后使用 return 返回

<br>

### js对象 -> json
### **<font color="#C2185">JSON.stringify()</font>**
可以将一个JS对象转换为JSON字符串

需要一个js对象作为参数会返回一个JSON字符串
```js 
var str3 = {"name":"孙悟空","age":18,"gender":"男"};

// JSON这个对象在IE7和以下浏览器不支持所以在这些浏览器中会报错
let json = JSON.stringify(str3);
```

<br>

**参数:**  
1. 要转换的js对象
2. 可选, 要保留的属性, 传入null 则表示全部保留
  - ["属性名1","属性名2",...]
  - (key, value) => { ... }, 在函数中可以对属性值的部分进行加工 最后使用 return 返回
```js
const jsonString3 = JSON.stringify(obj, (key, value) => {
  if (key === 'name') {
    return value.toUpperCase();
  }
  return value;
});
console.log(jsonString3);
```

3. 制表符缩进

<br>

**自定义对象的返回内容:**  
我们可以在对象中 定义toJSON方法 内部定义该对象返回什么内容

```js
let obj = {
  name: 'sam',
  arr: [1,2,3],
  // 自定义返回内容的 toJSON 
  toJSON: function() {
    return {
      name: this.name
    }
  }
}


console.log(JSON.stringify(obj))
```

<br>

### 注意:
在使用 JSON.stringify 转换数据的时候 如果数据中包含如下的内容 则对应的属性值会被 忽略 或 转换为 null

- function
- undefined
- symbol

<br>

### **<font color="#C2185">eval()</font>**
这个函数 **会将传入的字符串当做js代码来解析执行** 并返回结果

<br>

**注意:**  
如果使用eval()执行的字符串中含有{},它会将{}当成是代码块
如果不希望将其当成代码块解析则需要在字符串前后各加一个()
```js
var str = '({"name":"孙悟空","age":18,"gender":"男"})';
```

eval()这个函数的功能很强大可以直接执行一个字符串中的js代码
但是在开发中尽量不要使用首先它的执行性能比较差然后它还具有安全隐患

<br>

**示例:**  
```js
// 这是个字符串吧 字符串中是alert代码吧
var str2 = "alert('hello');";

// 但是我就想让上面的代码执行, 这时候我们就可以用eval()
eval(str2);


// 那现在我想把var str = '{"name":"孙悟空","age":18,"gender":"男"}'
eval(str);      //报错了 缺少分号 问题在{}这
  
var str = '({"name":"孙悟空","age":18,"gender":"男"})';
var obj = eval("("+str+")");
```

如果需要兼容ie7以及以下的json操作则可以通过引入一个外部的js文件来处理, 外部文件 叫 *json2.js*

<br><br>

## JSON特殊的使用技巧

### 技巧1: 对象的深拷贝
### **<font color="#C2185">JSON.parse(JSON.stringify(obj)</font>**
利用 JSON API 实现对象的深拷贝
```js
let obj = {
name: "sam",
  job: {
    frontend: "vue"
  }
}

let _obj = JSON.parse(JSON.stringify(obj))
```

<br>

**注意1!!!!!!:**  
JSON.parse(JSON.stringify(obj))这种方式 **当数据的值为 undefined 的时候 该字段将会被舍弃**

<br>

**注意2!!!!!!:**  
JSON.parse(JSON.stringify(obj))这种方式 在循环引用: JSON.stringify() 会在传入递归数据结构时抛出异常。

<br>

### 技巧2: 数据的格式化
### **<font color="#C2185">JSON.stringify(obj, null, 2)</font>**

<br><br>

# 严格模式
js除了提供正常的模式外还有严格模式(strict mode)

es5的严格模式是采用具有限制性js变体的一种方式, 即在严格条件下运行js代码, **ie10以上才支持**

<br>

### 严格模式要点:
js语法的一些不合理 不严谨的地方 减少了一些怪异行为

消除代码原型的一些不安全的地方, 保证代码运行的安全

提高编译器效率 增加运行速度

禁用了es的未来版本中可能会定义的一些语法, 为未来新版本的js做好铺垫, 比如一些保留字 class enum export extends import super不能做变量名

<br>

### 开启严格模式:
- 可以在js中开启
- 可以在个别函数内部开启

因此在使用时, 我们可以将严格模式分 为脚本开启严格模式 和 为函数开启严格模式两种情况

<br>

### 为脚本开启严格模式: "user strict"
为整个脚本文件开启严格模式, 需要在所有语句之前放一个特定语句

```js
;

<script>
  "user strict";
</script>

// 或者

<script>
  (function(){
    "user strict";
    // 把所有的代码都写在这个立即执行函数里面
  })()
</>
```

<br>

### 为函数开启严格模式
给某个函数开启严格模式, 需要把 "user strict"; 声明放在函数体所有语句之前

```js
function fn() {
  "user strict";

  函数体;
}
```

<br><br>

## 严格模式中的变化

### 1. 变量规定
在正常模式中 如果一个变量没有声明就被赋值, 默认是全局变量,

严格模式禁止这种用法, 变量都必须先用var命令声明, 然后再使用 **变量名 先声明 再使用**

<br>

### 2. 严禁删除已经声明的变量
例如 delete x; 语法是错误的, 不能随意删除已经声明好的变量

<br>

### 3. 全局作用域中函数中的this是undefined
以前在全局作用域函数中的this指向window对象, 严格模式下全局作用域中函数中的this是undefined

<br>

### 4. 严格模式下, 构造函数不加new调用 this指向undefined 会报错
以前构造函数时, 不加new也可以调用当做普通函数 里面this指向全局对象 加了this去调用还是指向创建的对象实例
```js
// 不加new调用作为普通函数调用 这时的this指向window
function Star() {
  this.sex = 'nan'
}

Star();
console.log(window.sex)     // 因为this指向window所以可以输出 男
```

<br>

### 5. 定时器里面的this还是指向window

<br>

### 6. 函数不能有重名的参数
```js
// 以前是可以这样的
function fn(a, a) {
  console.log(a + a);
}
fn(1, 2)    // 4
```

首先不在严格模式下是可以声明重名参数的

其次上面打印出4到的原因是

- 实参1 传递给a a = 1 
- 实参2 传递给a a = 2

现在都被改成 a=2 a=2 所以结果是4

<br>

### 7. 函数必须声明在顶层
新版本的js会引入'块级作用域' 为了与新版本接轨, **不允许在非函数的代码块内声明函数**

非函数代码块
```js 
if(true) {
  function fn() {}
  fn();  // !!!语法错误
}

for(let i=0; i<5; i++) {
  function fn() {}
  fn();  // !!!语法错误
}
```

<br>

### 8. 严格模式中也不允许使用8进制

<br><br>

# 高级函数
高阶函数是对其它函数进行操作的函数, 它接收函数作为参数, 或 将函数作为返回值输出
```js    
// 参数是个函数
function fn(callback) {
  callback&&callback();
}

fn(function() {alert(1)});

// 函数作为返回值
function fn() {
  return function() {}
}
fn()
```

<br>

函数也是一种数据类型, 同样可以作为参数, 传递给另一个参数使用, 最典型的就是作为回调函数
```js 
function fn(a, b, callback) {
  console.log(a+b);

  // 这条语句写在最下面
  callback && callback();
}

fn(1,2,function() {

  // 当fn中的代码执行完毕才会执行回调函数
  console.log('我是最后调用的');
})
```

<br><br>

# 什么是闭包
**闭包(closure)指:**  
有权访问另一个函数作用域中变量的函数 被访问的变量所在的函数就是闭包函数

<br>

### **<font color="#C2185">闭包的作用</font>**
延伸了变量的作用范围

闭包是一个函数  
简单的理解就是 **一个作用域可以访问另外一个函数内部的局部变量**

```js
// 我们fun这个函数作用域 访问了另外一个函数 fn 里面的局部变量 num 此时就满足了闭包的条件

function fn() {
  // 访问了这个作用域中的变量
  let num = 10;               
                        ↑
  function fun() {      ↑
    console.log(num) // 这个作用域
  }
  fun()
}
fn()
```

<br>

### fn外面的作用域可以访问fn内部的局部变量
```js
function fn() {
  let num = 10;
  function fun() {
    console.log(num)
  }
  
  return fun;
}
let f = fn();

// 类似于:

f = function fun() {
  console.log(num)
}

// 这里f里存的就是一个函数, 既然是函数就可以调用 这里是就全局作用域 访问到了局部作用域里的值
f();
```

<br><br>

## 闭包示例:
我们通过几个例子观察下闭包

<br>

### 一个函数, 可以访问它相同的作用域的外部变量
变量a 和 函数m1 在相同的作用域内
```js
var a = 0;

function m1(){
  console.log(a++);
};
```

<br>

接下来有m1, m2两个函数, m2函数显然是不能访问到变量a的 因为不在一个作用域里, **那怎么才让m2访问到m1中的私有变量呢?**
```js
function m1(){
  var a = 100;
  console.log(a++);
};

function m2(){
  console.log(a++);
}
```

为了是m2能够访问到m1中的私有变量, 我们可以这样

<br>

1. 我们在m1函数中 定义一个新的内部函数 并return出来 内部函数中访问m1外层定义的变量
```js
function m1(){
  var a = 100;

  return function() {
    return a
  }
};
```

2. 我们在全局调用m1函数 并将m1函数的返回值交给 _m1
```js
const _m1 = m1()
```

3. 因为 m2 和 _m1 同属一个作用域 所以m2中可以调用 _m1 函数 进而使用到 m1 函数中的局部变量
```js
function m2(){
  _m1()
}

m2()
```

<br>

**垃圾回收:**   
正常来讲 当m1执行结束的时候, 内部变量a就应该被回收, 之所以没有被回收 因为m3还在引用a

<br>

### 示例:
```js
for(var i = 0; i < 5; i++) {

  setTimeout(function timer(){
    console.log(i)
  }, i * 1000)

}
```

我们的需求是 每隔一秒分别打印数字, 1 2 3 4 5 一秒一个
但是 实际得到的结果却是打印了5个5, 一秒一个

上面for循环的终止条件是, i不<5, 也就是当i满足终止循环的条件时,i的值为5

所以输出的结果反映的是 i在循环结束后的最终值 那上面的代码缺少了什么? 让我们不能打印出需求

for循环在每次进行时, 都会 捕捉 一次 i, 循环体每执行一次, 就会创建一个函数, 执行5次就会创建5个函数, 虽然这5个函数在循环中分离定义, 由于作用域的工作方式, 他们都闭包在同一个共享的全局作用域中, 而事实上只有一个i, 这样所有的函数共享一个i的引用

<br>

### **<font color="#C2185">↑ 修改下上面的代码, 这样会好用么?</font>**
```js
for(var i = 0; i < 5; i++){

  (function(){
    setTimeout(function timer(){
      cosole.log(i)
    },i*1000)
  })()

}
// 依然不好用, 这样做确实把 超时函数 放在了一个封闭的函数作用域中, 但有用一个被闭包的 空的作用域 是不够的, IIFE只是一个空的什么都不做的作用域, 它内部还需要一些东西 才能变得对我们有用 IIFE需要一个自己的变量 每次循环时都能持有一份对 i 的值的拷贝

for(var i=0; i<5; i++){
  (function(j){
    setTimeout(function timer(){
      cosole.log(j)
    },j*1000)
  })(i)
}
```

<br>

### 需求: 点击li 输出当前li的index
```js
var lis = document.querySelector('.nav').querySelectorAll('li');

for(var i = 0; i < lis.length; i++){
  // 给li绑定点击事件
  lis[i].onclick = function(){

    // 在这个事件回调用不能直接打印 i
    // 因为事件回调是异步任务, 循环是同步任务循环会立马执行, 停止循环的条件是5, 所以点击任何的 li 输出的结果都会是5
    console.log(i);
  };
}



// 那为了达到我们的需求, 我们会给lis[i] 添加一个index属性
var lis = document.querySelector('.nav').querySelectorAll('li');
for(var i=0; i<lis.length; i++){

  lis[i].index = i;               // 给lis[i] 添加了 index 属性

  lis[i].onclick = function(){
    console.log(this.index);
  };
}
```

<br>

### 需求: 闭包的方式 得到 li 的当前index
```js
var lis = document.querySelector('.nav').querySelectorAll('li');

for(var i=0; i<lis.length; i++){

  // 2, 定义形参i 用来接收实参 IFEE的i的值是实参传递进来的
  (function(i){ 
    // 4, 这时打印i 就会是0 1 2 3 4
    console.log(i); 

  // 1, 这个小括号可以接收一个参数, 我们把 i 传递进去
  })(i)
}
```

<br>

### 需求: 3秒钟后, 打印所有li中的内容
```js
var lis = document.querySelector('.nav').querySelectorAll('li');

for(var i = 0; i < lis.length; i++){

  setTimeout(function(){

    console.log(lis[i].innerHTML);
    // cannot read property 'inndeHTML' of undefind

  },3000)
}
```

定时器的回调函数也是异步任务, 所以还是会出现和实例1中一样的情况 解决办法还是一样的, 我们每次循环的时候传递进去独一无二的i就可以了

```js
for(var i=0; i<lis.length; i++){

  (function(i){
    setTimeout(function(){
      console.log(lis[i].innerHTML);
    },3000)
  })(i)

}
```

只要在IFEE中的任何函数都可以使用IFEE中的变量, 这就是闭包的应用

<br>


<br>

### 需求: 打车价格
打车起步价格为13(3公里内), 之后每多一公里增加5块钱, 用户输入公里数就可以计算打车价格, 如果有拥堵的情况, 总价格要多收10块钱的拥堵费

之前我们都会先声明一个函数, 那这个函数最终一定会执行, 又要声明又要调用很麻烦, 所以我们就直接写在匿名函数里面, 就不需要调用了

```js
var car = (function(){

  let start = 13;     //起步价
  let total = 0;      //总价

  // 这里有两个功能: 1 正常价格, 2 拥堵时的价格, 既然是两个函数我们可以这样
  return {
    // 1
    price:function(n){      //n为用户传递进来的参数, 代表公里数

      if( n <= 3){
        total = start;
      }else{
        total = start + ( n - 3 ) * 5
      }

      return total;       // 最终把总价返回
    },

    // 2
    yd:function(flag){
      // 这里我们要判断是否是拥堵, 如果拥堵在原价上加10, 如果没有是原价
      return flag ?total+10 :total;
    }
  }
})()

car.price(5);
car.yd(true);

```

这是一个立即执行函数, 一执行后返回了两个函数, 既然有返回值, 我们就可以创建变量把返回值接回来, 我们定义了一个car 来接收返回的对象

car里有两个方法, 我们可以通过点的方式使用这两个方法

<br>

### 名词解释:

**词法作用域:**  
也就是在词法阶段定义的作用域

词法作用域意味着作用域是由书写代码时函数声明的位置来决定的

js中其实只有词法作用域并没有动态作用域

this的执行机制让作用域表现的像动态作用域 this的绑定是在代码执行的时候确定的

<br>

### 迭代
迭代计算是指迭代计算是重复计算工作表直到满足特定数值条件为止

<br>

### 异步任务主要的三种情况
1. 回调函数
2. 定时器中的回调函数
3. 事件中的回调函数
4. ajax中的回调函数

异步任务多是, 只有你触发了才会执行 比如定时器(setTimeout(function(){}.3000)) 3秒后 才执行,没有到时间是不会执行的,即使我们把3000改为0, 它也不立马执行 而是把函数放到任务队列里

<br>

### 思考题: 下面的题中有没有闭包的产生
```js
let name = 'the Window';
let obj = {
  name:'my object',
  getNameFunc: function() {
    // 匿名函数中的this指向window
    return function() {
      return this.name;
    }
  }
}

console.log(obj.getNameFunc()())      // the Window
let f = obj.getNameFunc();

// 相当于
f = function () {
  return this.name;
}

// 普通函数调用this指向window
f();    
``` 

**答案:**  
对上解答 没有闭包的产生 因为内部函数没有用到外部函数的变量

<br><br>

## 如何产生闭包?
当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时就产生了闭包
```js
function fn1(){
  var a = 2;
  function fn2(){
    // 这里我引用了外部函数的变量a fn2中的闭包里才有a属性
    console.log(a);     
  };
};

fn1(); 
```

假如我只执行fn1 不执行fn2 fn2中的console能输出么? 
那fn2这个函数对象有没有产生 产生了

<br>

### 闭包到底是什么?
我们可以通过chrome工具 通过debug调试来查看 

- 理解一: 闭包是嵌套的内部函数(绝大部分人)
- 理解二: 包含被引用变量(函数)的对象(极少数人)

注意: 闭包存在于嵌套的内部函数中

<br>

### 产生闭包的条件?
执行函数定义就会产生闭包(不用调用内部函数)

函数嵌套, 内部函数引用了外部函数的数据(变量/函数) 还要执行外部函数

```html
<button>测试1</button>
<button>测试2</button>
<button>测试3</button>
```

需求: 点击某个按钮提示 点击的是第N个按钮

```js
var bts = documen.getElementsByTagName("button");

/*
  这里的bts是个数组么?不是 
  
  它是一个伪数组 而且.length不是一个固定的值而是在for循环内每次需要通过计算才能得到结果
  
  如果写bts.length要计算多遍
  那怎么做呢? 要不然拿出去在外边定义
*/
for(var i=0; i < bts.length; i++){        
  var btn = bts[i];
}


// 优化for循环的写法
for(var i=0, length = bts.length; i < length; i++) {
  // 减少多次计算, 提供性能 把bts[i] 存放到一个变量里面
  var btn = bts[i];
  btn.onclick = function(){
      
    // 这么写不对因为i是从0开始的
    alert("第"+ i + "个")
    alert("第"+ (i+1) + "个")   
  }
}

/*
  向上面这么写完点击按钮后全是第4个 那就说明i是3, 因为
  我们的函数在后面的某一个时刻才执行 当我这个函数执行的时候 循环已经结束了

  整个过程中产生了几个i 就一个i i是一个全局变量 在外面也能看到i 而我的函数还是在for循环执行完毕之后才执行, for循环执行完毕后 i是3, 也就是说这种写法不行

  循环遍历加监听 肯定是要加的 就是最后我怎么才能得到一个正确的i呢?

  我们要把每一个i 要跟 btn 对应起来吧 也就是说 每一个btn都要知道自己的下标才行, 那我就把下标 等于 i
  btn.index = i;
*/
for(var i=0, length=bts.length; i<length; i++){
  var btn = bts[i];

  // 将btn所对应的下标 保存在btn上
  btn.index = 1;
  btn.onclick = function(){
    alert("第"+  (this.index+1) +"个")   
  }
}   
```

<br>

### 换个写法: 下面的写法就是闭包
```js
for(var i=0, length=bts.length; i<length; i++){
  (function(i){
    // 我把这段代码放在了 匿名函数自调用 里面
    var btn = btns[i];                  
    btn.onclick = function(){
      alert("第"+  (i+1) +"个")  
    };
  })(i);
}
```

<br>

### 闭包的常用写法:
```js
function aaa() {
  var a = 1;

  return function(){
    a++;
    alert(a)
  }
}

var bbb = aaa();
bbb();          // 2
bbb();          // 3
bbb();          // 4
```

<br>

### 函数表达式的写法:
```js
var aaa = (function () {
  var a = 1;
  return function () {
    a++;
    alert(a)
  }
})()

aaa()       // 2
aaa()       // 3
aaa()       // 4
```

<br><br>

## 常见的闭包

### 将函数作为另一个函数的返回值
```js
function fn1(){
  var a = 2;

  function fn2(){
      a++;
      // 引用就是使用
      console.log(a);     
  };
  return fn2;     
};
fn1();
/*
  我外部执行得到了什么? 得到了整个fn2
  那我可以用一个变量来存 没有输出a 没执行呢 但闭包产生了
  如果没有闭包 这行一执行var a = 2 就消失了
*/

// 外部函数调用了一次
var f = fn1();

// 实际上是执行fn2 相当于 fn1()() 也就是调用的内部函数
f();        // 3       
f();        // 4       

// 这里a在不断的累加 那就说明了一个问题 a没有消失 a是一个局部变量吧 是fn1里的局部变量
// a什么时候产生 执行fn1的时候产生 局部变量在函数调用的时候产生调用结束后就会死亡 但是如果是3和4 那它就没有死亡
```

<br>

**上述的代码块中一共产生了几个闭包?**  
一个

如果我想产生两个闭包 该怎么办? 就看你产生了几个内部函数对象 就看你调用了几次外部函数

fn1() 这么一执行 我又把内部函数执行一次吧 说白了 怎么看闭包产生了几个 就看外部函数执行了几次

因为你在执行外部函数的时候 才会执行内部函数对象 跟内部函数执行几次没有关系,

那也就是说 我在反复执行内部函数过程中 我闭包里的数据并没有消失 为什么没有消失呢?

<br>

### 将函数作为实参传递给另一个函数调用
```js
function showDelay(msg, time){
  setTimeout(function(){
    alert("msg");
  }, time)
}
showDelay('atguigu', 2000);
```

**有没有闭包?**   
有 首先有外部函数 有内部函数 内部函数引用了外部函数变量 是因为msg 不是因为time

<br><br>

## 闭包的作用
1. 使用函数的变量在函数执行后仍然存活在内存中(延长了局部变量的生命周期)

2. 让函数外部可以操作(读写)到函数内部的数据(变量/函数)
```js
function fn1(){
  var a = 2;
  function fn2(){
    a++;
    console.log(a); 
  };

  // 把fn2暴露出去 让外部能看见
  return fn2;                      
};

fn1(); 
var f = fn1();  
f();        // 3       
f();        // 4  

/*
  如果没有闭包 函数一执行完 局部变量就会立即释放 后面再想访问就不行了

  作为局部变量在外面看不见但事实上 我们却能在外部操作局部变量

  我们又看不见局部变量 但我们能用闭包的技术能够在外部操作局部变量 相当于间接可以访问
  
  譬如 我现在在函数内部有一个变量希望外部能读到这个a 但不希望被改变
*/
```

**问题:**   
1. 函数执行完后函数内部声明的局部变量是否还存在?  
一般情况下是不存在的 但是存在于闭包中的变量才可能存在

2. 在函数外部能直接访问函数内部的局部变量么?  
不能但是通过闭包这个技术 让外部操作
```js
function fn1(){
  // 这里的a 在函数执行后还存在么? 存在 因为在闭包里
  var a = 2;

  function fn2(){
    a++;
    console.log(a); 
  };
  /*
    那这个fn2整个函数对象还在不在? 不在了 没有人引用它 成为了垃圾对象
    括号前的fn2相当于一个局部变量 闭包里没有fn2 所以自动释放

    fn3呢?有自动释放么?fn3也不在闭包里 闭包里只有a 所以fn3这个变量在函数执行完后会被自动释放
  */

  /*
    那你说连fn3都自动释放了函数对象不成为垃圾对象了么?可函数对象没有成为垃圾对象 为什么?

    是哪行导致fn3没有被释放的? 是第11708行 我用变量f 指向了 11706行console.log(a);  函数对象

    也就是说闭包还存在没消失的原因是谁导致的?var f = fn1(); 中的f导致的
  */
  function fn3(){
    a--;
    console.log(a);             
  };
  
  return fn3;
  /*
  把fn3暴露出去(把内部函数 return)
  
  return fn3 实际上 return的fn3的地址吧 里面保存的内容一旦返回后 fn3本身这个变量还在不在

  fn3本身不在了fn3虽然不在了但并不代表我函数对象成为垃圾对象了 为什么?因为 f 引用着

  只要有一个引用对象 指向着 这个对象这个对象是不会成为垃圾对象的 
  */
                    
};

fn1(); 

var f = fn1();          
f();        // 1       
f();        // 0  

/*
  这个函数对象关联这个闭包闭包里有a 关键点在于var f = fn1() f把返回值存起来了 
  假如这里改成fn1(); 后 执行完 fn3就不会存在了 
*/
```

<br><br>

## 闭包的生命周期

### 产生:
在嵌套内部函数定义执行完时就产生了(不是在调用)定义执行不是函数执行 只是创建了函数对象

<br>

### 死亡:
在嵌套的内部函数成为垃圾对象时
```js
function fn1(){
  // 在这行闭包就存在了 因为函数提升 内部函数对象已经创建了
  var a = 2;

  function fn2(){ 
    a++;
    console.log(a); 
  };

  return fn2;                             
};

// 这时候产生了闭包
var f = fn1();
f();        // 1       
f();        // 0

// 这时候闭包死亡 因为包含闭包的函数对象成为了垃圾对象也就是引用它的变量不再引用它了 
f = null

// 闭包是一个对象一个对象就有产生和死亡 执行完函数定义创建完内部函数就产生 
function fn1(){
  var a = 2;    
  var fn2 = function(){       
    a++;             
    console.log(a); 
  };
  return fn2;           
};
```

<br><br>

## 闭包的应用: js自定义模块
什么是js模块, 具有特定功能的js文件, 将所有的数据和功能都封装在一个函数内部(私有的) 只向外暴露一个包含n个方法的对象或函数

模块的使用者 只需要通过模块暴露的对象调用方法来实现对应的功能

把下面的文件写在js文件中在外面还能看到下面的内容么? 看不见 它是私有的数据 
```js
function myModule(){
  var msg = 'My aiguigu'
  function doSometing(){
    console.log('doSomething()' + msg.toUpperCase())
  }

  function doOtherthing(){
    console.log('doOtherthing()' + msg.toLowerCase())
  }
}


// 执行它没意义啊 我执行它以后 js文件中的数据又释放掉了 还是不能去操作里面的msg 我得向外面暴露一些东西
function myModule(){
  var msg = 'My aiguigu'

  // 操作数据的函数
  function doSometing(){
    console.log('doSomething()' + msg.toUpperCase())
  }

  function doOtherthing(){
    console.log('doOtherthing()' + msg.toLowerCase())
  }

  // 向外暴露
  return doSometing;
}
```

```html
<!-- 将上面的js文件引入 -->
<script type="text/javascript" src="myModule.js">

// 暴露doSometing出去后怎么用?
var fn = myModule();  
// 执行后 得到的是函数 把它放进fn中 这样再执行 相当于myModule()()
fn();  
</script>
```

假如现在我想向外暴露doSometing doOtherthing怎么做?现在我要暴露两个数据怎么办呢?

是不是用一个容器把这两个数据封装起来啊, 用什么容器? 对象呗
```js
// 向外暴露 给外部使用的方法
return {
  doSometing:doSometing,
  doOtherthing:doOtherthing      
}

// 这么调用
var module = mymodule();
module.doSometing()
module.doOtherthing()
```

<br>

### 换一个写法:
```js
(function(){
  var msg = 'My aiguigu' 
  function doSometing(){
    console.log('doSomething()' + msg.toUpperCase())
  } 
  // 这部分还是私有的 不向外部暴露的话 外部是看不见的
  function doOtherthing(){    
    console.log('doOtherthing()' + msg.toLowerCase())
  }
})()
```

<br>

之前是用return向外暴露如果是匿名函数自调用怎么向外暴露呢?,把这个要暴露的东西 添加到 window的属性

```js
window.myModule2 = {
  doSometing:doSometing,
  doOtherthing:doOtherthing   
}
```

<br>

外部是用匿名函数自调用写的上面的js文件写好后怎么用呢?
```js
// 我直接就能看见我的模块对象 直接
myModule2.doSometing();
myModule2.doOtherthing();
```

<br>

### 这两种方式哪个好一些?第二种
第一种 要想获取 js模块 必须要先执行函数才行 ``var module = mymodule();`` return后, 执行函数后 才能得到想要的闭包吧

第二种 一引用就能用了

<br>

### 示例代码:
```js
(function(window){
  var msg = 'My aiguigu'       
  function doSometing(){
    console.log('doSomething()' + msg.toUpperCase())
  }                                                     
  function doOtherthing(){    
    console.log('doOtherthing()' + msg.toLowerCase())
  }  

  window.myModule2 =  {
    doSometing:doSometing,
    doOtherthing:doOtherthing   
  }

})(window);
// 这种写法有一个好处在代码压缩的时候 会把局部变量一些函数 变成abcd 也就是说 window可能会被压缩成w. 如果没有定义就不能压缩成w
```

<br><br>

## 闭包有什么样的缺点
1. 缺点  
函数执行完后函数内的局部变量没有释放占用内存时间会变长, 容易造成内存泄漏

2. 解决  
能不用闭包就不用, 及时释放
```js
function fn1(){
  var arr = new Array[100000];
  function fn2(){
    console.log(arr.length);
  };
  return fn2;
}

// 产生闭包了么? 产生了 闭包死了么? 没有 因为 f 在, 但是也有问题f在就会导致我的数组一直没有被释放
var f = fn1();   
// 解决办法 让内部函数 成为垃圾对象 回收闭包
f = null 
```

<br>

# 内存溢出 & 内存泄漏

### 内存溢出  :
一种程序运行出现的错误, 当程序运行需要的内存超过了剩余内存时就抛出内存溢出的错误

一个程序能拥有的内存空间是有限的 超出了这个空间程序就没办法运行 就崩溃了

```js
var obj = {};
for(var i=0; i<10000; i++){
  obj[i] = new Array(100000000)
}

// 这个循环遍历会产生很多个Array对象我要把所有的对象都放在obj里面去 怎么放进去 也就是obj占用的内存会特别大
obj[i] = new Array(100000000)
```

<br>

### 内存泄漏:
意思是本来我有很大的内存可以用 但是你泄漏了一部分的内存 我可用的内存变小了, 占用的内存没有及时释放, 内存泄漏积累多了就容易导致内存溢出

<br>

### 常见的内存泄漏:
1. 意外的全局变量
```js
function fn(){
  // 这里程序员以为是局部变量
  a = 3; 
  console.log(a);
}
// 如果a =3 是局部变量的话 fn()调用完 a就会被释放 这就是意外的全局变量
fn()
```

2. 没有及时清理的计时器或回调函数
```js
// 启动定时器后不清理
var a = setInterval(function(){
  console.log('---');
},1000)

clearInterval(a);
```

<br><br>

# 递归函数
如果一个函数在内部可以调用其本身, 那么这个函数就是递归函数 简单的说就是自己调用自己的函数就是递归函数

**递归函数的作用 和 循环效果一样 反复执行**

由于递归很容易发生 '栈溢出' 的错误 所以必须要加条件 return
(因为每次调用函数都会开辟内存空间, 越开越多就死了)

<br>

### 简单的写法:
```js
// 在内部又调用了次自己
function fn() {
  fn();
}
fn();
```

先执行全局中fn() 然后进入到fn函数内部 又再次调用fn, 又进入到这个函数内部 有点像for循环

<br>

### 练习: 利用递归打印6句话
```js
let num = 1;

function fn() {
  console.log(num);

  if(num == 6) {
    return;  // 递归里面必须加退出条件
  }

  num++;
  fn();
}
fn();
```

开启函数 然后打印console 然后判断等于6么 num++ 成为了2
再次调用fn 它会再回到函数内部的开头 再执行 再打印 再判断
当到6的时候 退出 因为console在上面所以会打印完6句

<br>

### 需求: 求1 ~ n的阶乘 用户输入几 求1-n之间的阶乘
```js
function fn(n) {
  // 后一个数比前一个数大一 
  if(n == 1) {
    return 1;
  }
  return n * fn(n-1);
}
fn(3);
```

<br>

**解析:**  
假如用户输入的是3
```js
return 3 * fn(3-1)   =>   3 * fn(2)
```

到这里并不能返回一个值, 因为它必须得把fn(2)的结果拿到后才能返回 也就是说必须要把fn(2)的结果算出来才能返回

那fn(2)相当于再次调用fn这个函数此时里面传递的就是2了
```js
return 3 * fn(2)    =>   3 * (2 * fn(2-1))
```

然后还是因为fn(2-1)并不是个结果 它会继续求值

fn(1)是多少? 1把 ok, 现在都有结果了
```js
3 * (2 * 1)
```

<br>

### 利用递归函数求斐波那契数列(兔子序列)
1, 1, 2, 3, 5, 8, 13, 21...

用户输入一个数字n, 就可以求出, 这个数字对应的兔子序列值, 就是我输入的是位数, 返回的是这个位数所对应的数字

前两项相加正好等于第三项的和, 所以我们只需要知道用户输入的n的前面两项就可以计算出n对应的序列值

前两项 n-1 前面的第一项, n-2前面的第二项

<br>

### 利用递归: 根据id返回对应的数据对象
```js
let data = [
  {
    id:1,
    name:'家电',
    goods: [
      {
        id:11, 
        gname:'冰箱'
      },
      {
        id:12, 
        gname:'洗衣机'
      }
    ]
  }, 
  {
    id:2,
    name:'服饰'
  }
]
```

<br>

**需求:**  
我们想要输入id号, 就可以返回数据的对象

查询数组的每一个对象 我们用forEach来做, 既然我们想输入id号, 那么我们可以封装成一个函数 

里面有两个元素, 第一个是id为1的对象, 第二个是id为2的对象 

```js
function getId(obj, id) {
  obj.forEach(function(value, index){
  /*
    那现在我们就相当于拿到了两个最大的数组元素 分别是id1 id2的两个对象  
    
    接下来我们根据id去找元素 进行判断 每个元素都有一个id, 那么我们可以拿着用户输入的id和元素的id进行对比, 一样的话我们就返回

    如果元素的id 等于 用户输入的id
  */
  if(value.id == id) {
  /* 
    这里我们就可以拿到数据了 但是我想要的是 用户输入id 我这边返回任意对象 现在是最外成的得到了 里层的呢?
  */
      console.log(value);

  /*
  那怎么得到里层的数据呢? 继续forEach, 比如我们拿到了goods的数组 这个数组里面也有数组元素 我再次forEach然后根据id判断一下就可以拿到里面的相应数据了  

  那是不是相当于把现在这个函数再整体的执行一次呢? 这里我们就可以使用递归

  那怎么写呢?

  我么是先在外层来判断, 当外层没有的情况下我们再去里层判断 
  所以if是判断外层的, 那么我们可以写else if就是判断里层的
  */


  /* 
  在这里面怎么判断, 首先得有goods这个数组吧 而且这个里面不能为空把 如果是一个空数组就不用遍历的 所以这里应该有两个条件 

  里面应该有个goods数组并且数组的长度不为0
  */
  } else if (value.goods && value.goods.length > 0) {
    // 在这个情况下我们去遍历数组, 在这里就没必要再去写forEach了
    getId(value.goods, id);
  }
})
}
  /* 
    可是递归不是要加退出条件的么? 递归是在forEach里面它里面有一个if和else 通过if else来判断到底要不要递归 

    我们再遍历的时候数组肯定是有一条两条之类的情况 果然条数遍历完了我就不在进行递归了 相当于给我加了退出条件
  */
getId(data,11);
```

<br>

### 总结:
```js
function getId(json, id) {
  json.forEach(function(value, index){
    if(value.id == id) {
      console.log(value);
    } else if (value.goods && value.goods.length > 0) {
      getId(value.goods, id);
    }
  })
}
getId(data,11);
```

<br>

### 执行过程:
首先传入id11, 然后走到elseif因为外层没有 进入内层 elseif里面再次调用函数, 

又回到最上方 这时传入的就是内部的value.goods 走到if部分 输出语句

<br>

### 上面只是把数据打印出来了, 那怎么得到数据呢?
```js
function getId(json, id) {

  // 用来接收返回的数据
  let obj = {};

  json.forEach(function(value, index){
      if(value.id == id) {

        // 把获取到的外层数据保存到obj中
        obj = value;
        /*
          这里把结果返回 为什么把返回结果写在if里面呢? 因为结果都是在if里面得到的

          elseif只是负责递归函数而已
        */
        return obj;

      } else if (value.goods && value.goods.length > 0) {
        /*
          这里会收到上面return value返回的结果, 也就是会获取到外层得到的结果
          然后我们拿着这个结果去找value.goods
          因为函数调用必要要有返回值
        */
        obj = getId(value.goods, id);
      }
  })

  // 我们在forEach的外面把obj返回来
  return obj
}

// 有返回值了 那就必须要接受结果
let result = getId(data,11);
console.log(result);    { 空对象 } 
/*
  因为getId(value.goods, id); 这句 
  调用完函数必须要有个返回的结果 得重新更新一下我们的obj, 因为上面的obj只是外成的结果 所以我们必须要把用里层的结果把外层的obj结果覆盖掉
  返回值可以在外层的if里面得到
*/
```

<br>

### 练习阶段的整理:
```js
let data = [
  {
    id:1,
    name:'家电',
    goods: [
      { id:11, gname:'冰箱' },
      { id:12, gname:'洗衣机' }
    ]
  }, 
  {
    id:2,
    name:'服饰'
  }
]

function getTarget(source, id) {

  let target

  for(let i = 0; i < source.length; i++) {
    const item = source[i]

    // 用户输入的是外层的id
    if(item.id == id) {
      // 外层的话 我们直接将item交给target进行返回
      target = item
    } else if(item.goods && item.goods.length > 0) {
      // 如果是内层的话 我们继续调用函数 别忘了每次调用函数都会有返回值结果 它要交由target
      target = getTarget(item.goods, id)
    }
  }

  // 每次返回的执行都会拿到返回值
  return target

}

const res = getTarget(data, 11)
console.log(res)
```

<br>

### 项目中的应用示例: 
```js
function pulldownProcess(options) {
  _data = {}
  targetIndex = 1
  let {actionQueue, target, source, raw} = options


  // 遍历队列 过滤掉 值为null 对象
  actionQueue = actionQueue.filter(item => Object.values(item).some(v => v != null))

    processQueue(actionQueue, target, source, raw)
  }

  function processQueue(queue, target, source, prevResult) {
    if (queue.length === 0) {
    return;
  }

  // 取出队列中的第一个元素
  const item = queue[0];

  // 执行元素的逻辑, 并传递前面元素执行后的结果
  const result = execute(item, target, source, prevResult);
  targetIndex++

  // 处理剩余元素, 刨除队列中的第一个元素的剩余队列
  const temp = queue.slice(1)
  processQueue(temp, target, source, result);
}

function execute(item, target, source, prevResult) {
  const result = Object.entries(item).reduce((acc, [key, value]) => {

  _data[targetIndex] = {}

  // 将过滤的数据进行备份
  backup(value, prevResult, targetIndex);

  const temp = findKeyword(value, prevResult);
  for (const key in temp) {
    if (temp[key] !== null) {
      temp[key] = temp[key].filter((item) => item !== '');
    }
  }

  target = Object.assign(target, temp);
  const condition = ["workClass1"]
  target[condition] = source[condition]

  acc[targetIndex] = _data[targetIndex]

    return acc[targetIndex];
  }, {});

  return result;
}
```

<br><br>

# 浅拷贝 和 深拷贝
- 浅拷贝只是拷贝一层, 更深层次对象级别的只拷贝引用
- 拷贝拷贝多一层, 每一级别的数据都会拷贝

在以前如果想拷贝数据到另外一个对象里面 需要用到for in遍历对象

<br><br>

## 浅拷贝

### 需求: 把这个对象拷贝给另外一个对象
```js 
let obj = {
  id:1,
  name:'andy'
};

let obj2 = {};
  
// 我们可以使用for...in 遍历obj
for(key in obj) {
  console.log(key);       //属性名
  console.log(obj[key]);  // 属性值

  // 给一个对象添加属性的时候 obj.name = value, 给obj2添加属性
  obj2[key] = obj[key];
}
console.log(obj2);
```

<br>

上面的数据格式没有问题, 因为obj对象中没有引用类型的数据格式, 但是如果数据格式为

```js
let obj = {
  id:1,
  name:'andy',
  msg: {
    content: "你好"
  }
};
```

结果看似没有问题, 其实拷贝的是msg的地址, 这个地址存的还是obj里面的地址值

也就是说明一个问题 既然是地址值拷贝给了o, 那么我通过o修改msg里面的值 会影响到原来obj里面的值
```js
// 我们修改o中的数据 会影响到obj里面的数据
o.msg.age = 2;
console.log(o.msg.age);     //2
console.log(obj.msg.age);   //2

// 这就是浅拷贝, 把更深层次的对象的地址值拷贝给了o o和obj指向了同样的数据 修改其中的任何数据, 都会影响另外的数据
```

<br>

### **<font color="#C2185">Object.assign(拷贝给谁, 拷贝哪个对象);</font>**
ES6中的浅拷贝的新方法
```js
Object.assign(o, obj);
console.log(o);
```

<br><br>

## 深拷贝
深拷贝就是拷贝多层, 每一层的数据都会拷贝

深拷贝会把更深层次的对象, 重新开启一个新的空间, 把数据复制到新空间里, 再把新空间返回给对象, 这两新对象和被拷贝的对象互不干扰

```js
let source = {
  id: 1,
  name: 'andy',

  msg: {
    age:1
  },
  color: ['pink', 'red', 'blue']
};

let target = {}

function deepCopy(n, o) {
  
  // 1. 遍历数据源对象 
  for(let key in o) {

    // 2. 获取数据源对象中的值的部分
    let val = o[key]

    // 3. 判断值部分的数据类型
    // 处理值部分的数据类型为 数组 的情况
    if (checkType(val) == "array") {
      // 如果是数组 则经过 for...in 的处理就是原数组中的 index位置的元素 放到新数组中的 index位置上 
      n[key] = []
      deepCopy(n[key], val)
    
    // 处理值部分的数据类型为 对象 的情况
    } else if (checkType(val) == "object") {
      n[key] = {}
      deepCopy(n[key], val)

    // 基本数据类型: 直接放入新对象中
    } else {
      n[key] = o[key]
    }
  }
}

deepCopy(target, source)
console.log(target)


// 工具函数
function checkType(source) {
  if(Object.prototype.toString.call(source) == "[object Array]") {
    return "array"
  } else if (Object.prototype.toString.call(source) == "[object Object]") {
    return "object"
  } else {
    return null
  }
}

target.msg.age = 3
console.log(source.msg)
console.log(target.msg)
```

<br>

### 深拷贝方式2: 
### **<font color="#C2185">structuredClone(obj)</font>**
全局的 structuredClone() 对给定的obj进行深拷贝

<br>

**注意:**  
nodejs中是不行的

<br><br>

# 本地存储 (localStorage, sessionStorage)
随着互联网的快速发展, 基于网页的应用越来越普通, 同时也变的越来越复杂, 为了满足各种各样的需求, 会经常性在本地存储大量的数据, HTML5规范提出了相关解决方案

以前我们会把数据放在数据库里, 还要去服务器里面取过来再拿来使用  也有些东西根本就没有必要放在数据库里面

<br>

### 本地存储的位置:
```js
F12 --- Application --- 左侧 Storage Session Storage
```

<br>

### 本地存储的特性:
1. 数据存储在用户浏览器中
2. 设置, 读取方便, 甚至页面刷新都不会丢失数据
3. 容量较大
  - sessionStorage    约5M
  - localStorage      约20M

4. 只能**存储字符串**, 可以**将对象JSON.stringify()**编码后存储

<br>

### 5M的单位:
10M字节空间

而根据 UTF-16编码规则要么2个字节要么四个字节所以不如说是 10M 的字节数更为合理

```js
"a".length      // 1
"人".length     // 1
"𠮷".length     // 2
```

key的长度也会占用空间

<br><br>

## window.sessionStorage
生命周期 为 关闭浏览器窗口  
在同一个窗口(页面)下数据可以共享 以键值对的形式存储使用的

<br>

### **<font color="#C2185">sessionStorage.setItem(key, value)</font>**
存储数据 / 修改数据(在原来的数据上再次存储就是修改)

把数据存储在浏览器里 不关闭页面数据会一直存在

<br>

### **<font color="#C2185">sessionStorage.getItem(key)</font>**
获取数据

<br>

### **<font color="#C2185">sessionStorage.removeItem(key)</font>**
删除数据

<br>

### **<font color="#C2185">sessionStorage.clear()</font>**
清空数据

```js 
let set = document.querySelector('.set');
let get = document.querySelector('.get');
let remove = document.querySelector('.remove');
let del = document.querySelector('.del');
let text = document.querySelector('input');

set.addEventListener('click', function(){
  // 当我们点击了之后, 就可以把表单里面的值存储起来
  let val = text.value;

  sessionStorage.setItem('uname', val);

  // 点击一次存到uname中 再点击一次存到pwd中
  sessionStorage.setItem('pwd', val);
  console.log(val);
})

get.addEventListener('click', function(){
  sessionStorage.getItem('uname')
  // let result= sessionStorage.getItem('uname');
  console.log(result);
})

remove.addEventListener('click', function(){
  sessionStorage.removeItem('uname')
})

del.addEventListener('click', function(){
  sessionStorage.clear()
})
```

<br><br>

## window.localStorage
声明周期永久生效, 除非手动删除 否则关闭页面也会存在

可以**多窗口(页面)共享**, 同一浏览器都可以使用这个数据
以键值对的形式存储使用

<br>

### **<font color="#C2185">localStorage.setItem(key, value)</font>** 
存储数据 / 修改数据  
在原来的数据上再次存储就是修改呗

<br>

### **<font color="#C2185">localStorage.getItem(key)</font>**
获取数据

<br>

### **<font color="#C2185">localStorage.removeItem(key)</font>**
删除数据

<br>

### **<font color="#C2185">localStorage.clear();</font>**
清空数据

<br><br>

## 案例: 记住用户名
如果勾选记住用户名, 下次用户打开浏览器 就在文本框里面自动显示上次登录的用户名

<br>

### 案例分析:
- 把数据存起来, 用到本地存储

- 关闭页面, 也可以显示用户名, 所以用到localStorage

- 打开页面, 首先先判断是否有用户名这个数据, 如果有, 就在表单里面显示用户名, 并且勾选复选框

- 当复选框发生改变的时候 change事件 如果勾选, 就存储 否则就移除

<br><br>

# 基础总结深入: 数据类型

<br>

### 基本类型(值类型)
- string 值为: 任意字符串
- number 值为: 任意的数字
- boolean 值为: true false
- undefined 值为: undefined
- null 值为: null

<br>

### 对象类型(引用类型)
- Object 值为: 任意对象
- Function 值为: 一种特别的对象(可以执行 内部包含着可运行的代码)
- Array 值为: 一种特别的对象(数值下标(操作数据要用数值下标、内部数据是有序的))

<br><br>

## 判断数据类型
如何判断因为不同数据类型 行为不一样  不知道类型的话就不知道怎么操作

<br>

### 对数据类型进行判断的方式: 

### **<font color="#C2185">typeof</font>**
返回值: 数据类型的字符串表达

说白了返回的是字符串既然是字符串 那就是要加上引号

可以判断一个值是否是
```
undefined / number / string / boolean / function
```

不能判断的是
```
null / Object / Array
```

<br>

### **<font color="#C2185">===</font>**
可以判断一个值是否是undefined / null 因为这两个类型就一个值

```js
var a = null;
console.log(a === null);

var a = undefined;
console.log(a === undefined);
```               

<br>

### **<font color="#C2185">instanceof</font>**
返回值: 布尔值

```js
// A是不是B的实例
A instanceof B
```

它可以间接的判断A的类型 是不是一个对象? 或者 是不是一个数组?

A是不是B的实例 那也就是说B应该是一个 构造函数(因为在JS里类型是通过构造函数去表达的), 判断对象的具体类型(它会判断这是一个函数 还是一个数组) 

<br><br>

### undefined与null的区别?
都代表什么东西都没有

- undefined: 代表 定义了 没赋值
- null: 代表 定义了 并赋值 值为null

```js
var a;
console.log(a);     //undefined

var a = null;
console.log(a);     //null
```

<br>

### 什么时候给变量赋值为null呢?
- 初始赋值表明将要赋值为对象
- 结束赋值让对象成为垃圾对象

```js
var b = null;
```

初始赋值为null表明将要的赋值为对象这样可以让下一个人知道 这个b即将要被赋值一个对象 

确定对象(或者数据来了) 就赋值

```js
b = [12, 'atguigu'];
b = null;
``` 

最后释放数组所占用的内存让b指向的对象成为垃圾对象(被 垃圾回收器 回收)

<br>

### 严格区别变量类型与数据类型?
基本类型 和 对象类型

<br>

### 变量什么时候是基本类型
保存的是基本数据类型的数据 

<br>

### 变量什么时候是引用类型
保存的是地址值 
```js
var c = {};
```

这是我的对象数据这是数据是个对象 有人会说这是引用类型 何为引用类型? 

c里面存的是什么? 存的是内存地址这个类型的引用 对象在堆内存里 c在栈内存里c保存的不是对象 保存的是地址值 c本身不是对象只是说c能找到对象它保存的是内存地址

很多时候我们判断变量的类型 其实是在判断 值的类型

```js
var c = function(){ ... }; 
``` 

这个c是不是引用变量?是吧 函数是一个对象 我们将函数对象的地址值保存在c中

那我们用typeof c

```js
console.log(typeof c);      //返回的是 "function" 
``` 

它是怎么知道的?  
只看c 只看值?是function的 它只能根据存储的内容找到这个内存才能发现它是个函数对象 

<br>

### 什么数据?
存储在内存中代表特定信息的'东西'本质是010101...
**数据的特点:**  
1. 可传递
2. 可运算

<br>

一切皆数据 内存中所有操作的目标是: 数据
1. 算术运算
2. 逻辑运算
3. 赋值运算
4. 运行函数

<br>

### 什么是内存?
内存条通电以后产生的可存储数据的空间(临时的因为要通电嘛)

**内存产生和死亡:**  
内存条(电路板) -> 产生内容空间 -> 存储数据 -> 处理数据 -> 断电 -> 内存空间和数据都消失

<br>

一块小内存的两个数据
1. 内部存储的数据
2. 地址值数据 标识一块内存的
```js
var obj = {name:"tom"};
console.log(obj.name);
```

<br>

### 思考:
输出obj.name先找obj吧 读的obj内部存储的内容还是内部存储的地址?

读的是内容 只是这个内容是个地址值 .的作用是什么?

.的作用相当于 拿着ox123沿着箭头找到对应的内存  
是不是所有的变量都能 . 呢? 什么样的变量才能 . 呢?

是不是这个变量存的是内存地址才能 . 啊
name:'tom' 内存中的小标识 : 内存中存储的数据


内存中 每一个小内存都有对应的地址值 这个内存是个对象 它的地址值我们就用 其他的都不用 其他的用内存中存储的数据
```
栈内存               堆内存
a = 0x123           ox123
obj: 0x123          name:'tom'

var a = obj;
``` 

我们是在用obj的地址值么?不是 是将obj的地址值赋值给a么?不是

而是将里面的数据拷贝一份保存到a中只有一种情况才会读地址值 将一个对象赋值给谁的时候读的才是

地址值 其他的时候都是在读内存内容只是内存里有两种数据 一种是基本数据 一种是地址值数据

栈空间的小内存它可以存基本类型的数据 也可以存地址类型的数据 如果它存的是地址数据 我们称之为引用变量

<br>

### 内存的分类
栈  -> 全局变量 和 局部变量
堆  -> 对象

函数名在 栈 里面因为它本身是变量名 对象本身在堆空间里

<br><br>

## 概念

<br>

### 执行函数定义: 
就是编写函数体  
定义函数的时候其实就是执行函数定义函数体并没有执行只是创建了一个函数对象

定义函数 它创建函数对象时内部要执行一条语句
```js
this.prototype = {}     //创建了一个空的函数对象 这个对象也就是原型对象
// this是 创建的函数对象 
```

<br>

### 执行函数: 
就是fn()这才是执行了函数对象

实例对象就有隐式原型属性 那实例对象又分为两类

<br>

**函数:**    
函数是实例对象 这个实例对象有些特别 它同时又有显式原型对象 一般情况下 我们说的实例对象不是指的函数但函数它是实例对象 平时我们说创建实例对象 那肯定不是说定义一个函数 有时候我们把函数对象称之为类型对象 比如我们定义一个Person 这个Person是一个类型吧

<br>

### 函数对象是Function的实例: 
我们一般说的实例对象是 new Person 产生的 也就说 new 构造函数产生的对象

**实例对象的隐式原型和函数的显式原型有什么样的关系?**  
是相等 或者说指向同一个对象 属性说白了就是变量

prototype 和 __proto__ 这两个数形变量都是引用变量 引用变量用来指向对象他们都指向同一个对象

<br>

### __proto__属性是new实例时产生的: 
也就是说我们创建实例对象时 它的内部会产生一条语句 ``this.__proto__ = fun.prototype``(假设叫fun) 结果就是它们指向了同一个对象

```js
this.__proto__ = fun.prototype
```

<br>

我们现在赋值 相当于把prototype里面的值 这个内存的值 这个内里里面存了个地址值 赋值给__proto__

怎么样才能让两个引用变量都指向同一个对象将一个引用变量 赋值给 另一个引用变量就可以了 因为 赋值的是地址值

<br>

### 构造函数 和 它的实例对象都指向了一个空对象这个空对象真的是空的么?
它的里面还有 所有的实例对象 都有一个 隐式原型属性__proto__还有一个constructor(它叫构造器想想我一个实例对象我得知道我的构造器是谁吧)

<br><br>

# 原型链: 
用来查找对象的属性准确的说是查找实例对象的属性隐式原型组成的链 找不到返回undefined

- 如果输出一个变量没有 它会报错 **找变量是沿着作用域链找**  
- 如果输出一个属性没有它会undefined **找属性是沿着原型链找**  

<br>

JS的继承是基于原型的继承 原型是个对象吧有的时候也会说js是基于对象的继承

一个实例的原型对象可能有多个 顶部默认是object的原型 这也就是说 所有new出来的实例对象 都有toString方法 一个函数本身也是一个实例对象平常我们只观察函数身上的显示原型属性

<br>

**这么理解**  
根据test这个属性名去找这个属性 这个属性里面对应的值是一个函数
```js
obj.test()
```

<br>

### 注意: 
所有构造函数的实例对象的隐式原型 指向 构造函数的显式原型  
所有我们定义函数它的原型对象的是object的实例, 有一个例外 是object自己 它指向它自己

<br>

### 实例对象的隐式原型 等于 它所对应的显式原型: 
那我们想 一般情况下 object是不是实例对象 , 一个函数既有显式原型又有隐式原型 它自身的隐式原型和显式原型相等么? 不相等 但有一个例外

```js
A.prototype = {};
//这种的意思是 把原型对象指向了另一个对象不会影响之前创建好的实例但会影响之后创建的实例

A.prototype.xx = value;
//这种是在原型上添加属性或者方法 会影响到之前和之后创造的实例
```

<br><br>

# 执行上下文 与 执行上下文栈 
执行上下文 与 执行上下文栈 是根据变量提升和函数提升引申出来的

变量提升 和函数提升 是执行上下文 与 执行上下文栈的结果 

<br>

### 要点: 
变量先提升 接下来是函数再提升 **函数的优先级更高 是指提升的晚 后执行**  

变量提升后 var a 的a去哪去了?  
放在执行上下文里去了 执行上下文有两个 
- 一个是全局上下文
- 一个是函数上下文 

得看这条语句是写在函数外面 还是写在函数里面 如果是全局的语句 那就是提高到window里面去了 如果你是一个函数内部的语句, 只有在执行调用函数的时候 才能产生提升

<br>

**在执行上下文中 代码分为全局代码和函数内部代码 两种类型**  
一个对应的是全局上下文 一个是函数上下文

<br>

**什么时候确定全局执行上下文?**   
在全局代码执行前  
将window确定为执行上下文 确定好了以后 做预处理操作 也就是收集数据

也就是用var定义的全局变量还有函数声明的函数 还有this 收集的时候给它们赋值 变量是undefined 函数是函数对象this是window

而且把函数和变量放到哪去? 放到window里面去 也就是保存到全局执行上下文里去了

<br>

### 整个过程分3步
1. 确定执行全局上下文 window
2. 预处理
3. 执行全局代码

<br>

### 函数执行上下文调用函数的时候产生跟调用了几次函数: 
1. 创建一个函数执行上下文
2. 预处理 收集数据
3. 函数内部的局部变量 一个是形参var定义的局部变量 functon声明的函数 this  arguments 都会放在执行上下文中, 放之前要先赋值形参也要赋值 赋实参的值arguments是实参列表 局部变量undefined 函数为函数对象

<br>

做好这件事情后 就存在函数执行上下文里去, 下一步 执行函数体 就涉及到找某一个变量去执行上下文里去查 执行上下文没在对空间里面

执行上下文栈用来管理和保存执行上下文对象栈底是window 上面是函数的执行上下文   
比如下面结构栈底是window 上面是两个函数 f1和f2是什么关系f1内部调用f2才会产生这种现象

<br><br>

# 作用域
就是一块 地盘 一个代码段所在的区域, **它是静态的**(相对于上下文对象)在编写代码时就确定了

<br>

### 分类: 
- 全局作用域
- 函数作用域
- 没有块作用域, 什么是块作用域相当于大括号作用域
```js
if(true){
var c = 3;
}
// 我在外面能不能见到c 能看到就不是块作用域
console.log(c);
```

<br>

### 作用: 
隔离变量 不同作用域下同名变量不会有冲突
```js
var a = 10, b = 20;

function fn(x){
var a = 100, c = 300;
console.log('fn()',a,b,c,x);
          // a:100, b:20, c:300, x:10

function bar(x){
  var a = 1000, d = 400;
  console.log('bar()', a, b,c,d,x)
          // a:1000, b:20, c:300, d:400, x:100/200
};
bar(100);
bar(200);
};
fn(10);
```

<br>

**上面产生了几个作用域?**  
执行上下文对象是什么原则是n+1原则是调用了几次函数+1

<br>

## 产生作用域的原则
是N+1原则 N是定义了几个函数 就是几个函数作用域1是全局作用域

<br>

### 作用域和执行上下文的区别
**区别1:**  
全局作用域之外每个函数都会创建自己的作用域 作用域在函数定义时(编码时)就已经确定了而不是在函数调用时

- 全局执行上下文环境是在全局作用域确定之后js代码马上执行之前创建动态创建的
- 函数执行上下文环境是在调用函数时函数体代码执行之前创建

<br>

**区别2:**  
作用域是静态的只要函数定义好了就一直存在且不会再变化 执行上下文环境是动态的调用函数时创建函数调用结束时上下文环境就会自动释放

执行上下文环境(对象) 是从属于所在的作用域
- 全局上下文环境 --- 全局作用域
- 函数上下文环境 --- 对应的函数使用域

<br><br>

## 作用域链
嵌套的作用域 产生的 由内向外 由下向上的一个过程

多个上下级关系的作用域形成的链它的方向是从下向上或者从内到外, 查找变量时就是沿着作用域链来查找的

<br>

### 查找一个变量的查找规则: 
- 在当前作用域的执行上下文中查找对应的属性如果有直接返回否则进入2
- 在上一级作用域的执行上下文中查找对应的属性如果有直接返回否则进入3
- 再次执行2的相同操作直到全局作用域如果还找不到就抛出找不到的异常

<br><br>

## 复习: 
- 作用域的作用是用来隔离变量 在不同的作用域里定义相同的变量 不冲突
- 作用域链用来查找变量 沿着作用域链找变量, 找到就返回 找不到就要报错

<br>

比如a.b 找a是沿着作用域链找找b是沿着原型链找 找不到就返回undefined

<br>

如果我找window.a 会是undefined, 如果直接找a 会报错  
那平时 我们说 直接写a 相当于 window.a, 还是有点区别 区别就是找不到以后 它怎么处理

<br>

- 作用域是代码一书写时就确定了
- 作用域是N+1个 N是定义了多少个函数1是全局

- 执行上下文也是N+1 N是执行函数的次数 1是全局
- 执行上下文是动态产生的 尤其是函数执行上下文 不会一直存在调用的时候产生 函数执行完就死亡

- 查找一个变量 找的是作用域链 而作用域链是根据我代码定义(书写)的位置确定的, 跟调用位置没关系

<br>

### 什么是执行上下文栈(执行栈)执行上下文(可执行代码)
首先说一下 可执行代码的类型有什么

1. 全局代码  
例如加载外部的js文件或者本地标签内的代码.全局代码不包括 function 体内的代码

2. 函数代码  
function体内的代码

3. eval代码  

<br>

当js引擎遇到这三种类型的代码的时候都会进行一些准备工作

这些准备工作专业的说法就叫执行上下文, 或者说js引擎遇到这三种类型的代码的时候就会进入到一个执行上下文

每当js代码在运行的时候它都是在执行上下文中运行 执行上下文可以理解为当前代码的执行环境它会形成一个作用域

<br>

### 那么js引擎在遇到可执行代码的时候它究竟会做哪些准备工作呢?
**全局执行上下文:**   
- 浏览器引擎在执行全局代码前将window确定为全局执行上下文
- 对全局数据进行预处理
- var定义的全局变量 ==> undefined,添 加为window的属性
- function声明的全局函数 ==> 赋值为fun添加为window的方法
- this==>赋值为window,表示全局执行上下文
- 开始执行全局代码 一个程序中只会有一个全局执行上下文

```js
var num = 2;
function pow(num) {
return num * num;
}
```

<br>

**引擎如何读取上面的代码?**  
- 引擎: 第一行它是变量！将它存储在全局存储器中
- 引擎: 第二行我看到了一个函数声明 让我们也把它存储在全局存储器中

<br>

### 全局存储器: 
全局内存包含全局变量和函数声明供以后使用

**当Javascript引擎运行你的代码时它会创建:**  
- 全局执行上下文
- 全局存储器(也称为全局作用域或全局变量环境)

<br>

### 函数执行上下文: 
每当一个函数被调用时都会为该函数创建一个新的上下文 每个函数都有自己的执行上下文不过是在函数被调用时创建的

函数上下文可以有任意多个 每当一个新的执行上下文被创建它会按定义的顺序执行一系列步骤

- 在调用函数准备执行函数体之前 创建对应的函数执行上下文对象
- 对局部数据进行预处理
- 形参变量 ==> 赋值(实参) ==> 添加为执行上下文的属性
- argument s==> 赋值(实参列表)添加为执行上下文的属性

- var定义的局部变量 ==> undefined,添加为执行上下文的属性
- function声明的函数 ==> 赋值(fun),添加为执行上下文的方法
- this ==> 赋值( 调用函数的对象)
- 开始执行函数体代码

<br>

### 执行上下文的生命周期
**创建过程:**  
1. 创建变量: 即初始化函数的参数arguments提升函数及变量的声明
2. 建立作用域和作用域链
3. 确定this的指向

<br>

**执行过程:** 
1. 变量赋值 
2. 函数引用 
3. 执行其他代码

<br>

**销毁阶段:**   
执行完毕后出栈等待被回收

<br>

**创建阶段:**   
在全局执行上下文中this的值指向全局对象在浏览器中this的值➡window对象;在nodejs中指向的是➡module对象

在函数执行上下文中this的值取决于函数的调用方式(即如何被调用的).当它被一个引用对象调用则将的值this设置为该对象否则this的值设置为全局对象或undefined(在严格模式下)

<br>

**执行上下文栈:**  
在一个javascript程序中必定会产生多个执行上下文javascript引擎会以栈的方式来处理它们也就是执行上下文栈

<br>

**执行上下文栈:**  
每个函数都有自己的执行环境当执行流进入一个函数时函数的环境就会被推入一个环境栈中函数执行完后栈将其环境弹出把控制权返回给之前的执行环境

一个程序代码中包含多个函数也就是包含多个函数执行上下文为了管理好多个执行上下文之间的关系JavaScript中创建了执行上下文栈来管理执行上下文执行上下文栈是具有后进先出结构的栈结构用于存储在代码执行期间创建的所有执行上下文

当JavaScript引擎运行JavaScript代码时它会创建一个全局执行上下文并将其push到当前调用栈(函数还没解析或者是执行、调用)仅存在全局执行上下文每当引擎发现函数调用时引擎都会为该函数创建一个新的函数执行上下文并将其推入到堆栈的顶部(当前执行栈的栈顶)当引擎执行其执行上下文位于堆栈顶部的函数之后将其对应的函数执行上下文将会从堆栈中弹出并且控件到达当前堆栈中位于其下方的上下文(如果有下一个函数的话)

<br><br>

# 进程与线程
有的程序是多进程的 有的是单进程的

如果一个程序的进程中 有多个线程 那它就是多线程的程序 只有一个线程就是单线程程序

<br>

### 进程: 
程序启动了一个对应的进程就启动了程序的一次执行它占有一片独有的内存空间 可以通过window任务管理器查看进程

<br>

### 线程: 
是进程内的一个独立的执行单元是程序执行的一个完整流程 是cpu的最小单元

<br>

### 相关知识: 
我们应用程序的代码必须运行在某个进程的某个线程上也就是说一个程序启动后一个线程都没有能运行代码么? 不能

一个进程中至少有一个运行的线程 主线程进程启动后自动创建因为要运行代码 在运行之前必要要创建一个主线程

- 一个进程中也可以同时运行多个线程我们会说程序是多线程运行的
- 一个进程内的数据可以供其中的多个线程直接共享

- 多个进程之间的数据是不能直接共享的(因为进程之间的内存是独立的)
- 线程池: 保存多个线程对象的容器实现线程对象的反复利用

<br>

### 何为多进程与多线程: 
- 多进程运行: 一个应用程序可以同时启动多个实例运行
- 多线程: 在一个进程内同时有多个线程运行

<br>

### 比较单线程与多线程
**多线程:**  
- 优点: 能有效提升CPU的利用率
**- 缺点:**  
1. 创建多线程需要开销的(需要费工夫的 不是随便就有的)
2. 线程间切换开销
3. 死锁与状态同步问题

<br>

**单线程:**  
- 优点: 顺序编程简单易懂  单线程说白了就是从上往下执行 这时候编码比较简单多线程的话 编码要复杂一些

- 缺点: 效率低

<br>

### JS是单线程还是多线程
JS是单线程运行的, 但使用H5中的web Workers可以多线程运行   
启动分线程的语法

<br>

### 浏览器运行是单线程还是多线程
都是多线程运行的

<br>

### 浏览器运行是单进程还是多进程

有的是单进程的
- firefox
- 老板ie

有的是多进程
- chrome
- 新版ie

<br>

### 双核cpu: 
在同一个时间点 同时做两件事 这样两个线程在同一个时刻可以同时运行

<br>

### 单核cpu: 
也能创建多线程 创建2个线程 但它只能处理一个线程另外一个线程暂停 
-它不会等一个线程执行完再执行另一个 它会在两个线程间跳转运行 这个叫线程间的切换 不是

<br><br>

## 浏览器内核
支撑浏览器运行的最核心的程序

浏览器也是软件也是应用 也是很多代码组成 在这些代码中 有支撑它运行最核心的代码 这就是内核

<br>

**不同的浏览器内核可能不一样**  
- chrome safari: 使用的是 webkit 内核
- firefox: Gecko
- ie: Trident
- 360 搜狗等国内浏览器: Trient+webkit 设计到钱的时候 会切换到Trident 安全性比较高

<br>

### 内核由多个模块组成 有哪些呢?
主线程运行的模块

JS引擎模块: 负责JS程序的编译与运行  
也是程序 同时也是代码 浏览器内部就有的 内核中
- htmlcss文档解析模块: 负责页面文本的解析
-  DOM/CSS模块: 负责dom/css在内存中的相关处理
- 布局和渲染模块: 负责页面的布局和效果的绘制(内存中的对象)

<br>

分线程运行的模块
- 定时器模块: 负责定时器的管理
- DOM事件响应模块: 负责事件的管理
- 网络请求模块: 负责ajax请求

<br>

### 定时器引发的思考

1. 定时器真的是定时执行的么?定时器并不能保证真正的定时执行  
一般会延迟一丁点(可以接受)也可能延迟很长时间(不能接受) 设定200 实际580

<br>

2. 定时器回调函数是在分线程执行的么?  
在主线程执行的js是单线程的

3. 定时器是如何实现的?  
事件循环模型(后面讲)
```js
var start = Date.now();
console.log('启动定时器前')

setTImeout(function(){
console.log('定时器执行了'Date.now()-start)
},200)

console.log('启动定时器后')
```

<br>

### js是单线程执行的
1. 如何证明js执行是单线程的  
setTimeout()的回调函数是在主线程执行的 定时器回调函数只有在运行栈中的代码全部执行完后才有可能执行

2. 为什么js要用单线程模式而不用多线程模式
js的单线程与它的用途有关 作为浏览器脚本语言js的主要用途是与用户互动 以及操作DOM 这决定了它只能是单线程否则会带来很复杂的同步问题

3. 代码的分类
初始化代码 回调代码    回调函数中的代码

4. js引擎执行代码的基本流程 

<br>

**先执行初始化代码:**  
- 包含一些特别的代码    回调函数(异步执行)
- 设置定时器
- 绑定监听
- 发送ajax请求
- 后面在某个时刻才会执行回调代码
