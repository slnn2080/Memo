### 适配

### pc端获取宽度的方式
```js
console.log("最干净的显示区域", document.documentElement.clientWidth)   // 常用 它是视口

console.log("最干净的显示区域 + 滚动条", window.innerWidth)

console.log("最干净的显示区域 + 滚动条 + 浏览器边框", window.outerWidth)

console.log("与浏览器无关, 当前设备显示分辨率横向的值", screen.width)
```


### pc端视口
- pc端 视口的默认宽度和浏览器窗口宽度一致 在css标准文档中 视口也被称为 初始包含块
- 它是所有css百分比宽度推算的根源 在pc端可以通过上面的方式获取宽度

- pc端没有那么多的事儿 就一个视口的概念


### 移动端视口
- 移动端有两个视口 一个标准

> 1. 布局视口 (容器)
- 用于解决 早期的页面 在手机上显示的问题 早期的时候我们这样做:
- pc端网页宽度一般都为 960px ~ 1024px 这个范围
- 就算超出了该范围 960px ~ 1024px 这个区域也依然是版心的位置
- 浏览器厂商针对移动端设备设计了一个容器 先用这个容器去承装pc端的网页 这个容器的宽度一般是 *980px*

- 不同的设备可能有所差异 但相差并不大 随后将这个容器等比例压缩到与手机等宽

- 这样就可以保证没有滚动条切能完整的呈现页面 但是这样做依然有问题:
- *网页内容被压缩的太小 严重影响用户体验*


*移动端获取布局视口方式:*
- 代码上pc端的是一样的但是在不同的场景下运行 获取的目标不一样
- pc获取的是初始包含块
- sp获取的是布局视口的宽度 (一般都是固定的 980px)
```js
document.documentElement.clientWidth


document.documentElement.clientWidth
// sp端的时候输出 980

document.documentElement.clientWidth
// pc端的时候输出 852
```


**注意:**
- 布局视口经过压缩后 横向的宽度用css像素表达就不再是375px了 而是980px 因为布局视口是被压缩 而不是截取

> 扩展:
- 所以我们没有写 meta标签的时候 网页上的字 元素太小是因为布局视口压缩进手机宽度里面 等比压缩后的后果

> 思考:
- 以iphone6为例:

    物理像素: 750px
    设备独立像素: 375px   dpr: 2
    css像素: 375px


- 要想写个盒子把iphone铺满 因为dpr为2 所以程序员想铺满屏幕 要写 375px
```css
div {
    width: 375px;
}
``` 

- 上面的情况是设置了meta标签 也就是不缩放的情况下 1css像素是1设备独立像素 再考虑dpr

- 但是, 如果我们没有写meta标签 那么接住 我们写的 375px 元素的是布局视口 也就是980px那个

- 布局视口接住后 会等比缩放至和屏幕大小一样宽 所以我们写的375px一是会觉得小 二是并没有我们想想的那样 写完375px后 并没有铺满整个屏幕

---

> 2. 视觉视口
- 视觉视口就是用户可见的区域 它的绝对宽度永远和设备屏幕一样宽 但是这个宽度里所包含的css像素值是变化的

- *也就是屏幕有多大 视觉视口就有多大*

- 例如:
- 一般手机会将980个css像素放入视觉视口中 而ipad pro会将1024个css像素放入视觉视口中


> 移动端获取视觉视口方式:
- window.innerWidth
<!-- 
    不过在 ANdroid2 Opera mini UC8 中无法正确获取
    一般不通过代码看视觉视口
 -->

> 思考
- 对于 iphone6 来说 它的视觉视口

- 要用物理像素表达: 
    横向就是750个物理像素

- 要用设备独立像素表达: 
    375px

- 要用css像素表达: 
    980px 
<!-- 
    (没写meta的情况 我们的css像素是用布局视口承接的 所以是980px) 
-->

---

> 3. 理想视口(标准)
- 与屏幕(设备独立像素)等宽的布局视口 称之为理想视口
- 这里是拿设备独立像素来衡量的(怪不得设计师会参考设备独立像素出图)

- 所以也可以说理想视口是一种标准: 放布局视口宽度与屏幕等宽(设备独立像素), 靠 meta 标签实现

> 理想视口的特点
- 1. 布局视口 和 屏幕等宽 以iphone6为例 符合理想视口的标准之后
    - 设备独立像素:  375px
    - 布局视口端口:  375px

- 2. 用户不需要缩放, 滚动就能看到网站的全部内容
- 3. 要为移动端设备单独设计一个移动网站


> 设置理想视口的具体方式:
- meta标签的作用就是修改布局视口 
```html
<!-- device-width就是获取的设备独立像素 -->
<!-- 将设备独立像素赋值给布局视口 就相当于开启了理想视口 -->
<meta name="viewport" content="width=device-width;">
```

- 这样布局视口永远和屏幕等宽

> 问题:
- 你想啊 我们用布局视口是为了承接pc端的网页的 但是现在布局视口让我们修改的和设备屏幕等宽了(按照设备独立像素修改的)

- 那pc端网页的内容怎么办 原先980px的布局内容 现在变成375px的理想视口了 这布局和内容应该怎么办？

> 解答:
- 在现今的年代 我们已经不奢求一件事儿了 就是pc端的页面既能在电脑上展示 又能在手机上展示

- 为什么我们非得要让手机展示pc端的网页呢？
- 那我们就为手机端单独设计一个网页呗 



> 总结:
\\ 不写 meta 标签(不符合理想视口标准)
- 1. 描述屏幕: 
    物理像素: 750px
    设备独立像素: 375px
    css像素: 980px

- 2. 优点:
- 元素在不同设备上 呈现效果几乎一样 因为都是通过布局容器等比缩放 例如200宽的盒子 200 / 980

\\ 写 meta 标签(符合理想视口标准)
- 1. 描述屏幕
    物理像素: 750px
    设备独立像素: 375px
    css像素: 375px

- 2. 优点:
    页面清晰展现 内容不再笑到难以观察 用户体验较好

- 3. 缺点:
    同一个元素 在不同屏幕设备上 呈现效果不一样 例如 375宽的盒子 375/375 和 375/414 不是等比显示

- 所以要做适配 让程序员写的代码在任何设备上都能全屏展示
<!-- 
    理论上可以用100% 处理所有的布局 但是算起来太麻烦
    比如90.6666%
 -->

- 只要是移动端的项目 一定会开启理想视口 一旦开启 980的布局视口 就被干掉了 

- 开启理想视口之后 手机有多宽 布局视口就有多宽广 
    - 元素显示不成比例 --> 适配
    - pc页面无法承接 --> 算了吧 不接了 直接写一个移动端页面


### 缩放
- https://www.bilibili.com/video/BV1Ey4y1u7vi?p=142&spm_id_from=pageDriver&vd_source=66d9d28ceb1490c7b37726323336322b

- 这个部分没有整理
> pc端缩放


### 适配
- pc端的设计稿 给多少写多少
- sp端的设计稿 要做适配

- 设计师出图:
- 以iphone的设备独立像素出图 375px
- 以iphone的分辨率出图 750px

- 设计师设计的是一个比例关系 并不是一个死值 按照一个标准设计一个比例

- 为什么要适配?
- 由于移动端设备的屏幕尺寸大小不一 会出现同一个元素 在两个不同的手机上显示效果不一样(比例不同) 要想让同一个元素在不同设备上 显示效果一样 就需要适配

- 无论采用何种适配方式 中心原则永远是 *等比*


> 为什么不直接用百分比做适配
- 因为 使用百分比做适配的问题:
- 横向的时候 我们参考设计稿算出 横向的百分比是可以的
- 纵向的时候 我们参考设计稿算出的百分比 40% 这个40%是基于html body 的高度 并不是我们想象中的设计稿 也就是纵向没有办法写百分比

```css
/* 设计稿 375px */
div {
    width: 345px;
    height: 150px;
}

/* 100%适配的问题 */
div {
    width: 92%;   (345 / 375)
    /* 
        40%是以横向做为基准算出来的 但是代码里面的横向的40%不看 375 而是看 html body 的高度 

        这样会导致 元素的高度太大了
    */
    height: 40%;  (150 / 375)
}
```

> viewport适配
- 方法:
- 拿到设计稿之后 *设置布局视口宽度为设计稿宽度*
```html
<meta name="viewport" content="width=375;">
```

- 这样所有的设备的布局视口都是375 那我们直接按照设计稿给宽高进行布局即可


- 优点:
- 不用复杂的计算 直接使用图稿上标注的px值

- 缺点:
- 不能使用完整的meta标签 会导致在某些安卓手机上有兼容性的问题
- *不希望适配的 东西 例如边框 也强制参与了适配*
<!-- 
    比如我们设计稿里面写了
    宽: 345px
    高: 150px
    padding: 15px

    这代表了 比例关系 也就是说我们要在别的设备上也要维持这种比例关系

    那假如 设计稿上的盒子有1px边框 那么 1px 也要做比例关系么？

    边框是否参与适配(比例)是不是要问设计师
    但是 viewport 这种方式 使边框强制的使用比例了
 -->


> rem适配
- em 和 rem 都是css中的长度单位 而且两个都是相对长度单位
- 1. em 相对的是 父级元素的字体大小
- 2. rem 相对的是 根元素的字体大小

> rem适配的原理:
- 编写样式时统一使用rem位单位 在不同设备上动态调整字体大小

> 方案一: (淘宝 百度 -> 设置 html fs: 100px) 
- 设计师以iphone6作为标准机型 375px

- 在 iphone6 中
<!-- 
    ------ 375 ------

       --- 345 ---
 -->

- 在 iphone6plus 中
<!-- 
    ------ 414 ------

       --- ? ---
 -->

- 怎么求 ? 的值?

    375     414
    ---  =  ---   
    345      ?

- 414 * 345 / 375 = ?  (380.88) 
- 上面告诉我们 求一个数值为多少的时候 可以通过上面的方式求得

- 我们可以将 元素的 px 都换成 rem 作为单位 
- 我们也知道 rem 是相对于 根字体 的结果 那我们就可以这样

- 1. 375px 的设计稿 我们先修改 html 的 font-size 为 100px 这样我们就可以利用 rem 来设置元素的单位
<!-- 
    - 这样我们修改元素的 px -> rem 的时候就很好算 比如:
    - 50px -> 0.5rem
    - 345px = 3.45rem
 -->

- 2. 因为我们写的是rem都是相对单位 那在 另一台设备上的时候(414px) 我们是不是修改 414设备的 font-size 的值为一个合适的值就可以了 因为 页面元素的大小都是 rem 也就是比例关系已经确定了 那只需要修改 "根源" 就可以了

- *那怎么才能快速的确定 "根源" 的字号呢？*

- iphone6
- 1. 我们拿到手的设计稿是 375px (iphone6)
- 2. 我们手动设置的iphone6的 html fs为 100px

- iphone6 plugs
- 3. 新设备的设备独立像素能拿到 414px 那能不能求出 新设备的 html fs 应该是多少

<!-- 
    100px (根字体)              ?
    -----           =       ------
    375px (独立像素)         414px (独立像素) 
 -->

- 414 * 100 / 375 = ?

> 公式: 新设备的独立像素值 * 100 / 设计稿的宽度 = 新设备的 html font-size
- 设计稿的宽度是设计师给我们的 是我们原型

**要点:**
- 我们出iphone6的图的时候 要将 html font-size 设置为100px

- 我们在写盒子大小的使用 单位要是rem


> 动态的设置 html font-size
- 每个设备的 font-size 我们要通过计算 动态确定吧

> 获取设备独立像素
- 当我们通过 meta 标签开启理想视口的时候 
    布局视口 = 设备独立像素

- 那我们获取布局视口是不是就可以了
```css
* {
  margin: 0;
  padding: 0;
}

#demo {
  width: 3.45rem;
  height: 1.5rem;
  background-color: palevioletred;

  margin: 0.15rem auto 0;
}
```
```html
<div id="demo"></div>
  
<script>
const cpmputeRootFontSize = () => {
    // 获取手机横向的设备独立像素
    let dip = document.documentElement.clientWidth;

    // 计算根字体大小 (100是我们自己指定的 375是设计稿宽度)
    let rootFontSize = (dip * 100) / 375

    // 设置根字体
    document.documentElement.style.fontSize = rootFontSize + "px"
}

// 页面初加载的时候要执行
cpmputeRootFontSize()

// 当页面发生变化的时候 也要重新计算
/*
    window.addEventListener("resize", () => {
    cpmputeRootFontSize()
    })
*/
// 也可以这么写 
window.onresize = cpmputeRootFontSize

</script>
```

- 一般我们会将函数名起名为 adapter 适配器

--- 

> VW适配 (不是VH哦)
- 上面我们说过 为什么100%的方案不行 因为计算高度的时候是根据 html 的高度计算的

- vw / vh
- 这两个单位是相对单位
- 1vw = 等于布局视口宽度的 1%
- 1vh = 等于布局视口高度的 1%

**注意:**
- 我们算比例关系的时候 不管宽度还是高度都是拿设计稿的宽度去算 而且我们算出height的值的时候 *单位也是vw哦*

```scss
#demo {
  width: 50vw;  // 160px
  height: 10vw; // 64px
  background-color: papayawhip;
}
```

- iphone3下 设备独立像素为 320 * 640
- 因为我们开启了 meta 标签 所以 320的一半是160px 640的10%是64px

- *不过 vw 和 vh 有很严重的兼容性问题*

---

> 1物理像素边框的问题 建立在边框不参与适配的基础上
- https://www.bilibili.com/video/BV1Ey4y1u7vi?p=149&spm_id_from=pageDriver&vd_source=66d9d28ceb1490c7b37726323336322b

- 高清屏幕下 1px 对应更多的物理像素
- 所以 1px 边框看起来比较粗 解决办法
```css
@media screen and (-webkit-min-device-pixel-ratio: 2) {
    #demo {
        border: 0.5px solid black;
    }
}

/* 或者 */
@media screen and (-webkit-min-device-pixel-ratio: 2) {
    #demo::after {
        transform: scaleY(0.5)
    }
}
```

- scss课程中留的一些话 没事看看
<!-- 



- 当一个漂亮的UI小姐姐给了你一份 750px 移动端的设计稿 我们要拿着设计稿进行还原是吧
- 你说 我们能不能就拿着设计稿中标记的元素尺寸 直接写移动端的布局？

- 试试呗
- 比如 现在设计稿上写的 有个部分呢要两列布局 每列320px
- 有人说简单呀 直接写呗 那我们就先写一列

- 然后我们查看下在移动设备下的显示效果 我们会发现
- 我们只写了 320px的一个盒子 我们会发现
- 在各个设备下的尺寸都不一样 比如在iphone3 下直接就全屏了

- 至于为什么？ 这里就不过多的讲了 因为移动端这块也是一个知识点 里面也包含了很多的概念 比如
  - css像素
  - 物理像素
  - 设备独立像素
  - dpr
  - 视网膜屏呀
  - 以及各种视口呀

- 要是讲的话 最少最少得一个多小时 咱们讲的scss 所以其它的就简单铺垫一下

- 我们写的css也叫做逻辑像素 或者 就叫做css像素 再简单点理解在编辑器上敲的px都是css像素

*画图*

- 你想啊 我们就在编辑器上简单的写了一个 div高宽100 人家屏幕就给你显示了一个图形 这中间肯定有什么转化关系吧

- 简单的说 其实呢咱们写的css代码 会被显示器的显示芯片接收了 显示芯片里面呢 定义了设备独立像素 设备独立像素 和 css像素是1:1的关系 1px = 1设备独立像素 (不考虑缩放的情况下)

- 接下来 设备独立像素 需要告诉 物理像素怎么呈现效果
- 哥们啥事物理像素, 物理像素你就可以理解为屏幕显示器的分辨率 咱买电脑 人家会说 这个屏幕啊 是 1920 x 1080 的 那就是说 横向有1920个像素点 你就可以理解为 横向上有1920个会发各种颜色的小灯泡 这些小灯泡是真实存在的 这个就是物理像素

- 设备独立像素 会根据 dpr 来告诉物理像素 咱们用多少个小灯泡显示图形
- 刚才那老哥又来了 哥们啥是dpr 2010年那年乔布斯发布了视网膜屏 将屏幕分为了两种 一种呢是普通屏幕 一种呢是视网膜屏

- 说啊 在 普通屏幕 和 视网膜屏 的屏幕大小一样的情况下 视网膜屏可以将更多的小灯泡压缩到屏幕里面去
- 也就是说 同样的 5寸大小的屏幕 普通屏的分辨率是320 视网膜屏的分辨率就是640 你看同样的尺寸 我压进去了更多的小灯泡 这样显示效果会更加的细腻是么

- 但是你细品 sp.ai

---

- 上面我们看了 我们的元素在各个设备上显示的效果都不一样 这时候我们就要知道 我们不能再写死px了 怎么办呢？ 

- 我们可以按比例, 什么意思呢 比如啊 一个元素 假如我们给它的宽度设置为50% 屏幕的一半 那么这个元素是不是在各个设备下 宽度都是一样的对吧 都是屏幕的一半吗

- 那是不是说 当我们拿到ui小姐姐的设计稿的时候 我们只要算出各个元素和设计稿之间的比例关系 那么我们用比例去设置元素的大小 就能确保在各个设备上显示的效果都一样了对么

- 比如 一行两个元素 左边的占70% 右边的占30% 以这样的比例关系去布局 就没有问题了对么

- 那适配的方案有很多 比如 vw rem 都能做适配 这里我们说下 vw 适配
- vw呢是相对单位 相对于视口(也就是屏幕宽度) vw呢把屏幕分成100份

- 1vw = 1%

- 我们怎么利用vw做适配呢？ 我们举个例子
 -->

------

### 网络中关于适配的基础知识
- 所有非视网膜屏幕的iphone在垂直的时候, 宽度为320物理像素。
- 当你使用<meta name="viewport" content="width=device-width">的时候, 会设置*视窗*布局宽度(不同于视觉区域宽度, 不放大显示情况下, 两者大小一致, 见下图)为320px, 于是, 页面很自然地覆盖在屏幕上

- 这样, 非视网膜屏幕的iphone上, 屏幕物理像素320像素, 独立像素也是320像素, 因此, window.devicePixelRatio等于1.

- 而对于视网膜屏幕的iphone, 如iphone4s, 纵向显示的时候, 屏幕物理像素640像素。同样, 当用户设置<meta name="viewport" content="width=device-width">的时候, 其视区宽度并不是640像素, 而是320像素, 这是为了有更好的阅读体验 – 更合适的文字大小。

- 这样, 在视网膜屏幕的iphone上, 屏幕物理像素640像素, 独立像素还是320像素, 因此, window.devicePixelRatio等于2.


> 设备物理像素:
- 是一个物理概念, 比如设备的分辨率, Phone 5 的分辨率 640 x 1136px。
- 一个个发光的2极管


> 设备独立像素 device-independent pixels (dips):
- 是一个抽象像素, 用于向CSS中的宽度、高度、媒体查询 和 meta 的 viewport 中的 device-width 提供信息。
- 通过观察retina和非retina设备之间的区别, 可以最好地解释它们。

- 比如我们可以自己调节 屏幕的分辨率 1920px 的我们可以调节成 1440px
- 比如 原先用一个1个物理像素 表达 一个像素 现在我们用2个物理像素 表达 一个像素 这时候分辨率就缩小了一半

- 逻辑像素就是用多个发光的二极管显示一个像素的内容


> CSS像素:
- 指的是CSS中使用的逻辑像素。在CSS规范中, 长度单位可以分为两类, 绝对(absolute)单位以及相对(relative)单位。px是一个相对单位, 相对的是设备物理像素。

- 比如iPhone 5 使用的是Retina屏幕, 使用 
  2px x 2px 的设备物理像素  代表 1px x 1px 的 CSS像素, 
  
- 所以设备物理像素为640 x 1136px, 而CSS逻辑像素数为320 x 568px。

- 也就是说 我们可以从两点上来考虑
- 1. 如果 dpr 是 2 的话 那么我们写的css像素当中的 1px 在retina屏下 代表 2px
- 2. 同理 我们设计稿 如果是640px 那么css像素我们就是320px


> dpr就是设置像素比
- 获得设备像素比后, 便可得知 *设备物理像素 与 CSS像素 之间的比例*。
  - 当这个比率为1:1时, 使用1个设备物理像素显示1个CSS像素。
  - 当这个比率为2:1时, 使用4个设备物理像素显示1个CSS像素, 
  - 当这个比率为3:1时, 使用9(3*3)个设备物理像素显示1个CSS像素。

- 关于设计师和前端工程师之间如何协同：
  一般由设计师按照设备像素(device pixel)为单位制作设计稿
  前端工程师, 参照相关的设备像素比(device pixel ratio), 进行换算以及编码。

> 思考:
- 一般普通图在的1920*1080, 是很正常的, 但是如果放在的2k或者4K屏幕里面, 背景图就是模糊掉, 为什么呢？

- 在不同的屏幕上(普通屏幕 vs retina屏幕), css像素所呈现的大小(物理尺寸)是一致的, 不同的是1个css像素所对应的物理像素个数是不一致的。

  普通屏幕:
    1个css像素 对应 1个物理像素(1:1)

  retina屏幕:
    1个css像素对应 4个物理像素(1:4)


```scss
// 引入 reset.css 样式
@use "../../../node_modules/reset-css/sass/reset";

html {
  font-size: 62.5%;
}

// 当大于 dpr > 2 的时候 使文字更加的清晰
@media only screen and (-webkit-min-device-pixel-ratio: 2),
  (-webkit-min-device-pixel-ratio: 2),
  (min-resolution: 2dppx) {
  body {
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }
}

body {
  // 默认值: 在大多数non-retina显示这将给最锋利的文本
  -webkit-font-smoothing: subpixel-antialiased;
  // unset: 修改所有元素属性或父元素的值为其父元素的值(如果有继承)或其初始值
  -moz-osx-font-smoothing: unset;
  // 检索或设置移动端页面中对象文本的大小调整。
  -webkit-text-size-adjust: 100%;

  // 使用了 Noto Sans JP 的谷歌字体 并指定了默认字体
  font-family: "Noto Sans JP", sans-serif;
  font-size: 1.4rem;
  -webkit-font-smoothing: subpixel-antialiased;
  line-height: 1.75;
}
```

> 1像素问题
- 在手机上会比较明显
- 由于移动端设备大多数像素比都是大于1的
```html
<style>
  .box {
    width: 500px;
    height: 1px;
    background: red;

    /* 解决方式 像素比为3的时候 2的时候就是0.5 */
    transform: scale(1, 0.333)
  }
</style>
<div></div>
```

---

> 移动端适配相关概念

> 1. 英寸(屏幕对角线的长度)
- 一般用英寸描述屏幕的物理大小，如电脑显示器的17、22，手机显示器的4.8、5.7等使用的单位都是英寸。

> 2. 设备独立像素
- 智能手机发展非常之快，在几年之前，我们还用着分辨率非常低的手机，比如下面左侧的白色手机，它的分辨率是320x480，我们可以在上面浏览正常的文字、图片等等。

- 但是，随着科技的发展，低分辨率的手机已经不能满足我们的需求了。很快，更高分辨率的屏幕诞生了，比如下面的黑色手机，它的分辨率是640x940，正好是白色手机的两倍。

- 理论上来讲，在白色手机上相同大小的图片和文字，在黑色手机上会被缩放一倍，因为它的分辨率提高了一倍。这样，岂不是后面出现更高分辨率的手机，页面元素会变得越来越小吗？

- 然而，事实并不是这样的，我们现在使用的智能手机，不管分辨率多高，他们所展示的界面比例都是基本类似的。乔布斯在iPhone4的发布会上首次提出了Retina Display(视网膜屏幕)的概念，它正是解决了上面的问题，这也使它成为一款跨时代的手机。

- 在iPhone4使用的视网膜屏幕中，把2x2个像素当1个像素使用，这样让屏幕看起来更精致，但是元素的大小却不会改变。

- 如果黑色手机使用了视网膜屏幕的技术，那么显示结果应该是下面的情况，比如列表的宽度为300个像素，那么在一条水平线上，白色手机会用300个物理像素去渲染它，而黑色手机实际上会用600个物理像素去渲染它。

- 我们必须用一种单位来同时告诉不同分辨率的手机，它们在界面上显示元素的大小是多少，这个单位就是设备独立像素(Device Independent Pixels)简称DIP或DP。上面我们说，列表的宽度为300个像素，实际上我们可以说：列表的宽度为300个设备独立像素。

- 打开chrome的开发者工具，我们可以模拟各个手机型号的显示情况，每种型号上面会显示一个尺寸，比如iPhone X显示的尺寸是375x812，实际iPhone X的分辨率会比这高很多，这里显示的就是设备独立像素。


> 设备像素比
- 设备像素比device pixel ratio简称dpr，即物理像素和设备独立像素的比值。在web中，浏览器为我们提供了window.devicePixelRatio来帮助我们获取dpr 在css中，可以使用媒体查询min-device-pixel-ratio，区分dpr：
```css
@media (-webkit-min-device-pixel-ratio: 2),(min-device-pixel-ratio: 2){ }

```

- 当然，上面的规则也有例外，iPhone 6、7、8 Plus的实际物理像素是1080 x 1920，在开发者工具中我们可以看到：它的设备独立像素是414 x 736，设备像素比为3，设备独立像素和设备像素比的乘积并不等于1080 x 1920，而是等于1242 x 2208。

- 实际上，手机会自动把1242 x 2208个像素点塞进1080 * 1920个物理像素点来渲染，我们不用关心这个过程，而1242 x 2208被称为屏幕的设计像素。我们开发过程中也是以这个设计像素为准。

- 为了适配所有机型，我们在写样式时需要把物理像素转换为设备独立像素：例如：如果给定一个元素的高度为200px(这里的px指物理像素，非CSS像素)，iphone6的设备像素比为2，我们给定的height应为200px/2=100dp。

- 当然，最好的是，你可以和设计沟通好，所有的UI图都按照设备独立像素来出。


> 视口
- 视口(viewport)代表当前可见的计算机图形区域。在Web浏览器术语中，通常与浏览器窗口相同，但不包括浏览器的UI， 菜单栏等——即指你正在浏览的文档的那一部分。

一般我们所说的视口共包括三种：布局视口、视觉视口和理想视口，它们在屏幕适配中起着非常重要的作用。

> 布局视口
- 布局视口(layout viewport)：当我们以百分比来指定一个元素的大小时，它的计算值是由这个元素的包含块计算而来的。当这个元素是最顶级的元素时，它就是基于布局视口来计算的。

- 所以，布局视口是网页布局的基准窗口，在PC浏览器上，布局视口就等于当前浏览器的窗口大小（不包括borders 、margins、滚动条）。

- 在移动端，布局视口被赋予一个默认值，大部分为980px，这保证PC的网页可以在手机浏览器上呈现，但是非常小，用户可以手动对网页进行放大。

- 我们可以通过调用document.documentElement.clientWidth / clientHeight来获取布局视口大小


> 视觉视口
- 用户通过屏幕真实看到的区域。
- 视觉视口默认等于当前浏览器的窗口大小（包括滚动条宽度）。当用户对浏览器进行缩放时，不会改变布局视口的大小，所以页面布局是不变的，但是缩放会改变视觉视口的大小。

- 例如：用户将浏览器窗口放大了200%，这时浏览器窗口中的CSS像素会随着视觉视口的放大而放大，这时一个CSS像素会跨越更多的物理像素。所以，布局视口会限制你的CSS布局而视觉视口决定用户具体能看到什么。

- 我们可以通过调用window.innerWidth / innerHeight来获取视觉视口大小。


> 理想视口
- 布局视口在移动端展示的效果并不是一个理想的效果，所以理想视口(ideal viewport)就诞生了：网站页面在移动端展示的理想大小。

- 如上图，我们在描述设备独立像素时曾使用过这张图，在浏览器调试移动端时页面上给定的像素大小就是理想视口大小，它的单位正是设备独立像素。

- 上面在介绍CSS像素时曾经提到页面的缩放系数 = CSS像素 / 设备独立像素，实际上说页面的缩放系数 = 理想视口宽度 / 视觉视口宽度更为准确。

- 所以，当页面缩放比例为100%时，CSS像素 = 设备独立像素，理想视口 = 视觉视口。我们可以通过调用screen.width / height来获取理想视口大小。


> vw 适配的缺点
- px转换成vw不一定能完全整除，因此有一定的像素差。
- 比如当容器使用vw，margin采用px时，很容易造成整体宽度超过100vw，从而影响布局效果。当然我们也是可以避免的，例如使用padding代替margin，结合calc()函数使用等等...

- https://blog.csdn.net/weixin_42981560/article/details/124241357


> 图片模糊问题
- 我们平时使用的图片大多数都属于位图（png、jpg...），位图由一个个像素点构成的，每个像素都具有特定的位置和颜色值：

- 理论上，位图的每个像素对应在屏幕上使用一个物理像素来渲染，才能达到最佳的显示效果。

- 而在dpr > 1的屏幕上，位图的一个像素可能由多个物理像素来渲染，然而这些物理像素点并不能被准确的分配上对应位图像素的颜色，只能取近似值，所以相同的图片在dpr > 1的屏幕上就会模糊:

- 为了保证图片质量，我们应该尽可能让一个屏幕像素来渲染一个图片像素，所以，针对不同DPR的屏幕，我们需要展示不同分辨率的图片。

- 在dpr=2的屏幕上展示两倍图(@2x)，在dpr=3的屏幕上展示三倍图(@3x)。

----------------