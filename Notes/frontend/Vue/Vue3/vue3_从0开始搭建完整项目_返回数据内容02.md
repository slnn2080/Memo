## AppExpandPanel:
"el-collapse"をベースにしてパッケージしたコンポーネントです、折りたたみパネルに表示するコンテンツを格納するためのデフォルトスロットが提供されています。

<br>

### Path：
```s
/src/components/AppExpandPanel.vue
```

<br>

### AppExpandPanel Attributes
|プロパティ名|詳細|タイプ|デフォルト値|
|:--|:--|:--|:--|
|title|<font color='#C2185B'>任意</font>, タイトルの文字|string|'検査条件入力'|

<br>

### Example:
```html
<script setup lang="ts">
import AppExpandPanel from '../components/AppExpandPanel.vue'
import SearchArea from './SearchArea.vue'

defineOptions({
  name: 'WorkerMaster'
})

// ----- methods -----

// ----- lifecycle ------
</script>

<template>
  <div class="worker-container">
    <!-- 折り畳み コンポーネント -->
    <AppExpandPanel>
      <SearchArea />
    </AppExpandPanel>
  </div>
</template>

<style scoped lang="scss"></style>
```

![AppExpandPanel-example](./imgs/AppExpandPanel-example.png)

<br><br>

## AppText
このコンポーネントは、以下の3つの構造を内部で組み合わせています:
1. タイトル（ラベル）部分
2. el-input部分
3. エラーメッセージを表示する部分

スロットを提供し、このコンポーネントには Element Plus ドキュメントで提供されているプロパティを参照することができます。

<br>

### Path：
```s
/src/components/AppText.vue
```

<br>

### AppText Attributes
|プロパティ名|詳細|タイプ|デフォルト値|
|:--|:--|:--|:--|
|v-model|<font color='#C2185B'>必須</font>, 双方向バインディングの値|string|
|label|<font color='#C2185B'>必須</font>, AppTextのタイトル部分|string|''|
|required|<font color='#C2185B'>任意</font>, タイトルの後に * を追加するかどうか|boolean|false|
|errorMsgList|<font color='#C2185B'>任意</font>, エラーメッセージを格納する配列|string[]|[]|

<br>

### AppText Slots
AppText内で Element Plus ドキュメントで提供されているスロットを使用できます。
```s
https://element-plus.org/en-US/component/input.html
```

```html
<AppText
  v-model="editForm.workerCode"
  :label="t('ga_table.workerCode')"
  :error-msg-list="errorMessage.workerCode"
  :required="true"
>
  <template #prefix>
    ...  
  <template>
</AppText>
```

<br>

### AppText Example:
```html
<AppText
  v-model="editForm.workerCode"
  :label="t('ga_table.workerCode')"
  :error-msg-list="errorMessage.workerCode"
  :required="true"
/>
```

<br><br>

## AppSelect
このコンポーネントは、以下の3つの構造を内部で組み合わせています:
1. タイトル（ラベル）部分
2. el-select部分
3. エラーメッセージを表示する部分

このコンポーネントには Element Plus ドキュメントで提供されているプロパティを参照することができます。

<br>

### Path：
```s
/src/components/AppSelect.vue
```

<br>

### AppSelect Attributes
|プロパティ名|詳細|タイプ|デフォルト値|
|:--|:--|:--|:--|
|v-model|<font color='#C2185B'>必須</font>, 双方向バインディングの値|string|
|label|<font color='#C2185B'>必須</font>, AppTextのタイトル部分|string|''|
|items|<font color='#C2185B'>必須</font>, 選択肢のデータ|string[] | {label: string, value: string}[]|[]|
|required|<font color='#C2185B'>任意</font>, タイトルの後に * を追加するかどうか|boolean|false|
|errorMsgList|<font color='#C2185B'>任意</font>, エラーメッセージを格納する配列|string[]|[]|
|hasAll|<font color='#C2185B'>任意</font>, すべての選択肢を追加|Boolean|false|

<br>

### AppSelect Example:
```html
<AppSelect
  v-model="editForm.workerWorkingStatus"
  :label="t('affiliation')"
  :error-msg-list="errorMessage.workerWorkingStatus"
  :items="props.initSearchItem.workerStatusItems"
/>
```

<br><br>

## AppChartContainer
このコンポネントはChartのコンテナです、Chartをコンポネントにいれて、Chartの幅と高さを自動調整できます

<br>

### Path：
```s
/src/components/AppChartContainer.vue
```

<br>

### AppChartContainer Event
|イベント名|詳細|
|:--|:--|:--|:--|
|resizeEvent|<font color='#C2185B'>必須</font>, Resizeの時に、コールバックを指定するため|Event|

<br>

### Example
```html
<AppChartContainer @resize-event="onResize">
  <div
    ref="chartRef"
    class="chart"
  />
</AppChartContainer>
```

<br><br>

## AppTableContainer:
AppTableContainerは、**テーブル**、**編集エリア**、**新規エリア**の高さを動的に調整できます。

内部にスロットが提供されており、対応する構造を対応するスロットに配置するだけで使用できます。

<br>

### Path：
```s
/src/components/AppTableContainer.vue
```

<br>

### AppTableContainer Attributes
|プロパティ名|詳細|タイプ|デフォルト値|
|:--|:--|:--|:--|
|captionText|<font color='#C2185B'>必須</font>, テーブルのタイトルテキスト|string|''|
|editFlag|<font color='#C2185B'>必須</font>, 編集Formと新規Formの表示と非表示のコントロール変数|SCENE (enum)|SCENE.DEFAULT|
|tableData|<font color='#C2185B'>必須</font>, テーブルのデータ|Arrray[]|[]|

<br>

### AppTableContainer Slots
|スロット名|説明|スコープパラメータ|
|:--|:--|:--|
|tableArea|テーブルエリア用| { height, pagingData }, テーブルの高さとページング後のテーブルのデータ|
|editArea|新規エリアと編集エリア用|{ height }、新規エリアと編集エリアの高さ|

<br>

### AppTableContainer Expose
|イベント名|説明|
|:--|:--|
|pageForm|AppTableContainerは自身のpageFormプロパティを外部に公開し、親コンポーネントが使用できる|

<br>

**ExposeしたpageFormの使い方:**  
1. AppTableContainerコンポネントにrefをつける
```js
<AppTableContainer ref="tableWrapperRef" />
```

2. refを使って、AppTableContainerのインスタンスをとる
```js
const tableWrapperRef = ref<InstanceType<typeof AppTableContainer>>()
```
3. 下のような使い方で、ExposeしたpageFormを扱う
```js
tableWrapperRef.value.pageForm.pageNo = 1
```

<br>

### AppTableContainer Example:
1. AppTableContainerコンポネントにrefをつける
```js
<AppTableContainer ref="tableWrapperRef" />
```

2. AppTableContainerの必須プロパティを準備
```html
<AppTableContainer
  ref="tableWrapperRef"
  :caption-text="t('workerMaster.table.title', [tableData.length])"
  :edit-flag="editFlag"
  :table-data="tableData"
>

<script>
  import { SCENE } from '@/types/components/type'
  /*
  enum SCENE {
    ADD,
    UPDATE,
    DEFAULT
  }
  */
  const editFlag = ref<SCENE>(SCENE.DEFAULT)
  const tableData = reactive<tableItemType[]>([])
</script>
```

3. #tableArea slotを使って、el-tableをslotにいれる, slotからheight, pagingDataを取って、el-tableに渡す
```html
<template #tableArea="{ height, pagingData }">
  <el-table
    :data="pagingData"
    :height="height"
    @row-click="rowClickHandler"
  >
    <el-table-column
      v-for="(item, index) in tableHeaders"
      :key="index"
      :prop="item.prop"
      :label="item.label"
    >
      ...
    </el-table-column>
  </el-table>
</template>
```

4. #editArea slotを使って、EditFormをslotにいれる, slotからheightを取って、EditFormに渡す
```html
<template #editArea="{ height }">
  <EditForm
    v-model:editForm="editForm"
    :title="editFormTitle"
    :edit-flag="editFlag"
    :height="height"
    :init-search-item="initSearchItem"
    @upd-cancel-event="updCancelProcess"
    @add-cancel-event="addCancelProcess"
    @upd-save-event="updSaveProcess"
    @add-save-event="addSaveProcess"
    @upd-delete-event="updDeleteProcess"
  />
</template>
```

<br>

```html
<script setup lang="ts">
import { ref, reactive, onMounted, computed, getCurrentInstance } from 'vue'
import { useI18n } from 'vue-i18n'

// ----- component -----
import AppTableContainer from '@/components/AppTableContainer.vue'
import EditForm from './components/EditForm.vue'

// ----- types -----
import { SCENE } from '@/types/components/type'

import type {
  tableHeaderItemType,
  editFormType,
  tableItemType
} from '@/types/worker_master/screen'

defineOptions({
  name: 'WorkerMaster'
})

const { t, locale } = useI18n()
const { proxy } = getCurrentInstance()

// table conatiner ref
const tableWrapperRef = ref<InstanceType<typeof AppTableContainer>>()


//  編集Formと新規Formの表示と非表示のコントロール変数
const editFlag = ref<SCENE>(SCENE.DEFAULT)

const tableHeaders: tableHeaderItemType[] = [
  {
    label: t('ga_table.workerCode'),
    prop: 'workerCode'
  },
  {
    label: t('ga_table.workerName'),
    prop: 'workerName'
  },
  {
    label: t('hourlyRate'),
    prop: 'workPayCostPerHour'
  },
  {
    label: t('affiliation'),
    prop: 'workerWorkingStatus'
  },
  {
    label: t('team'),
    prop: 'workerTeam'
  }
]
const tableData = reactive<tableItemType[]>([])


// 編集エリアと新規エリアのタイトル
const editFormTitle = computed(() => {
  return editFlag.value === SCENE.ADD ? t('ga_table.workerRegist') : t('ga_table.workerMaster')
})
</script>

<template>
  <div class="worker-container">
    ...
    <AppTableContainer
      ref="tableWrapperRef"
      :caption-text="t('workerMaster.table.title', [tableData.length])"
      :edit-flag="editFlag"
      :table-data="tableData"
    >
      <template #tableArea="{ height, pagingData }">
        <el-table
          :data="pagingData"
          :height="height"
          @row-click="rowClickHandler"
        >
          <el-table-column
            v-for="(item, index) in tableHeaders"
            :key="index"
            :prop="item.prop"
            :label="item.label"
          >
            <template
              v-if="item.prop === 'workPayCostPerHour'"
              #default="{ row }"
            >
              <span>{{ numberFormatter(row.workPayCostPerHour) }}</span>
            </template>
          </el-table-column>
        </el-table>
      </template>
      <template #editArea="{ height }">
        <EditForm
          v-model:editForm="editForm"
          :title="editFormTitle"
          :edit-flag="editFlag"
          :height="height"
          :init-search-item="initSearchItem"
          @upd-cancel-event="updCancelProcess"
          @add-cancel-event="addCancelProcess"
          @upd-save-event="updSaveProcess"
          @add-save-event="addSaveProcess"
          @upd-delete-event="updDeleteProcess"
        />
      </template>
    </AppTableContainer>
  </div>
</template>
```

<br><br>

# CommonDialog Methodの使い方
Vueのグローバルインスタンスにオブジェクト($invoke)をマウントし、そのオブジェクトに2つのメソッドがあります。

- show: パラメータがある、ダイアログを表示するためのメソッド
- hide: パラメータがなし、ダイアログを閉じるためのメソッド

<br>

### showメソッドのパラメータ
showメソッドでは、以下のパラメータが必要です。

- type: これはsave、delete、cancelの3つの値から選択でき、それぞれ異なるダイアログに対応しています。
- cancelFn: キャンセル時のコールバック関数
- confirmFn: 確認時のコールバック関数

- title: titleをカスタムで指定したい場合に、使うパラメータです, カスタムでしたい場合typeをいれない
- content: contentをカスタムで指定したい場合に、使うパラメータです, カスタムでしたい場合typeをいれない

```js
hide: () => void
show: ({
  type: 'save | cancel | delete',
  cancelFn: function,
  confirmFn: function
}) => void
```

<br>

### 使い方:
1. getCurrentInstanceをVueからimportして、proxyを取る(thisに相当)
```js
import { getCurrentInstance } from 'vue'
const { proxy } = getCurrentInstance()
```

2. [キャンセル]ボタンをクリックしてるときのイベントの中で、いかの使い方のようにDialogを呼び出します
```js
const updCancelProcess = (): void => {
  proxy.$invoke.show({
    type: 'cancel',
    cancelFn: proxy.$invoke.hide,
    confirmFn: cancelDialogConfirmProcess
  })
}

// はいをクリックしてるときのコールバック
const cancelDialogConfirmProcess = (): void => {
  // Dialogを閉じる
  proxy.$invoke.hide()
  // 他のロジック...
}
```

3. カスタムのDialogを使う場合に、パラメータにtypeをいれない、title と content をいれます
```js
proxy.$invoke.show({
  title: 'タイトル',
  content: '内容...',
  cancelFn: proxy.$invoke.hide,
  confirmFn: updSaveDialogConfirmProcess
})
```

<br><br><br><br><br>

# Vscode插件

安装vue3语法插件 Vue Language Features(Volar)

<br><br>

# 安装 sass

```s
npm i sass sass-loader -D
```

<br><br>

# 配置代码片段

ctrl+shift+p -> snippets -> 选择 Snippets: Configure User Snippets -> New Snippets file for 'ContainerName' -> snippets file name

```json
{
	"vue3": {
		"prefix": "vue3",
		"body": [
			"<script setup lang=\"ts\">",
			"",
			"</script>"
			"",
			"<template>"
			"",
			"</template>"
			"",
			"<style scoped>"
			"",
			"</style>"
			""
		]
	}
}
```

<br><br>

# 配置别名

我们使用了path但是并没有安装 @node/types 可能哪个依赖安装过了

```js
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import path from 'path'
import AutoImport from 'unplugin-auto-import/vite'
import Components from 'unplugin-vue-components/vite'
import { ElementPlusResolver } from 'unplugin-vue-components/resolvers'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [
    vue(),
    // ...
    AutoImport({
      resolvers: [ElementPlusResolver()]
    }),
    Components({
      resolvers: [ElementPlusResolver()]
    })
  ],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, 'src')
    }
  },
  server: {
    port: 9528
  }
})
```

<br><br>

# Element Plus

### 安装

```s
npm install element-plus --save
```

<br>

### main.ts 中引入

如果使用了自动导入后 则不需要 全局引入样式 和 注册

```js
import { createApp } from 'vue'

// [可选]: 引入样式 和 elementPlus
import ElementPlus from 'element-plus'
import 'element-plus/dist/index.css'

import App from './App.vue'

const app = createApp(App)

// [可选]: 注册
app.use(ElementPlus)
app.mount('#app')
```

<br>

### 指定elementPlus全局组件类型

需要再 tsconfig.json 中通过 compilerOptions.types 指定

```json
{
  "extends": "@vue/tsconfig/tsconfig.dom.json",
  "compilerOptions": {
    "types": ["element-plus/global"]
  }
}
```

配置别名后也需要修改 tsconfig.json 文件

```json
{
  "extends": "@vue/tsconfig/tsconfig.dom.json",
  "compilerOptions": {
    "types": ["element-plus/global"],
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  }
}
```

### **<font color="#C2185B">ElementPlus类型文件的问题</font>**

当我们在运行 npm run build 打包的时候, 发现了如下的错误

```s
Entry point of type library 'element-plus/global' specified in compilerOptions
```

原因是因为我们将 typescript的版本由4 -> 5所以报的错 具体的可以先参照下面的网站

```s
https://github.com/element-plus/element-plus/issues/12119
https://blog.51cto.com/echohye/6367849
```

**对应方式:**  
我们将 types 配置项中的 `element-plus/global` 部分 修改为 `element-plus/global.d.ts`

```js
{
  "extends": "@vue/tsconfig/tsconfig.dom.json",
  "compilerOptions": {
    "types": ["element-plus/global.d.ts"],
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"],
      "vuex": ["./node_modules/vuex/types"],
      "vite-plugin-eslint": ["./node_modules/vite-plugin-eslint/"]
    }
  }
}
```

当 ElementPlus 版本升级的时候 记得要改回来

<br>

### 自动导入

1. 安装依赖

```s
npm install -D unplugin-vue-components unplugin-auto-import
```

2. 修改 vite 配置

```js
// vite.config.ts
import { defineConfig } from 'vite'
import AutoImport from 'unplugin-auto-import/vite'
import Components from 'unplugin-vue-components/vite'
import { ElementPlusResolver } from 'unplugin-vue-components/resolvers'

export default defineConfig({
  // ...
  plugins: [
    // ...
    AutoImport({
      resolvers: [ElementPlusResolver()]
    }),
    Components({
      resolvers: [ElementPlusResolver()]
    })
  ]
})
```

<br><br>

# 安装 vue-router

### 安装 依赖

```s
npm i vue-router@next
```

<br>

### 配置 router/index.ts 文件

RouteRecordRaw是类型 所以导入的时候 需要指明我们导入的是类型 使用 `import type`

```js
import { createRouter, createWebHashHistory } from 'vue-router'

// import type
import type { RouteRecordRaw } from 'vue-router'
const routes: RouteRecordRaw[] = [
  {
    path: '/',
    component: () => import('@/components/Demo.vue')
  }
]

const router = createRouter({
  history: createWebHashHistory(),
  routes
})

export default router

```

<br><br>

# 安装 Vuex@4

### 安装 依赖

```s
npm i vuex@next
```

<br>

### 配置 store

新版本的 state 是一个函数 和 data配置项一模一样

```js
import { createStore } from 'vuex'

// 定义类型
type StateType = {
  counter: number
}

const state = {
  counter: 1
}

// 指定state的类型
export default createStore<StateType>({
  state
})
```

<br>

### 引入 vuex 的时候 报找不到vuex的声明文件

**报错信息:**

```js
ts/node_modules/vuex/dist/vuex.mjs”隐式拥有 “any” 类型。
There are types at ‘d:/study/shop-admin-with-vue3-vite-ts/node_modules/vuex/types/index.d.ts’, but this result could not be resolved when respecting package.json “exports”. The ‘vuex’ library may need to update its package.json or typings.ts(7016)
```

<br>

**解决方式:**

解决方式 需要在 tsconfig.json 中的 `paths` 配置项中添加 `"vuex": ["./node_modules/vuex/types"]`

```js
{
  "extends": "@vue/tsconfig/tsconfig.dom.json",
  "compilerOptions": {
    "types": ["element-plus/global"],
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"],
      "vuex": ["./node_modules/vuex/types"]
    }
  }
}
```

<br><br>

# Gwes Vue2 Vuetify 主题色配置方式

点击 管理 / 表示设定 会跳转到 `http://localhost:9529/#/gwes/pa/settings/setting`

这个文件引入了 4 个文件

```js
// import { setLanguage, getLanguage } from '@/utils/language'
import { setTheme, getTheme } from '@/utils/theme'
```

switch 按钮 v-model 绑定了 theme

```js
<v-switch
  v-model="theme"
  class="ma-1"
  :label="$t('theme.change')"
/>

// 默认值
theme: getTheme() === 'true',
```

mounted 中先调用 checkTheme, this.$vuetify.theme.dark 的 dark 属性控制的

```js
// 看看 getTheme是不是true 如果是 则为 dark 模式 如果不是则为 light 模式
checkTheme() {
  if (getTheme() === 'true') {
    this.$vuetify.theme.dark = true
  } else {
    this.$vuetify.theme.dark = false
  }
},
```

watch 中监视 data 配置项中 theme 中的值, 根据上面的方式进行判断 最后在调用 setThme 保存 theme

```js
watch: {
  theme() {
    if (getTheme() === 'true') {
      this.$vuetify.theme.dark = false
    } else {
      this.$vuetify.theme.dark = true
    }
    setTheme(this.theme)
  }
},
```

### getTheme 和 setTheme 的逻辑

```js
import Cookies from 'js-cookie'
const key = 'theme-black'

export function checkTheme() {
  if (Cookies.get(key) === 'true') {
    this.$vuetify.theme.dark = true
  } else {
    this.$vuetify.theme.dark = false
  }
}

export function getTheme() {
  return Cookies.get(key)
}

export function setTheme(val) {
  return Cookies.set(key, val, { expires: new Date(2037, 12) })
}

export function removeTheme() {
  return Cookies.remove(key)
}
```

### js-cookie

**1. 安装**

```s
npm install js-cookie
```

**2. 引入**

```js
import Cookies from 'js-cookie'
```

**3. api**

- 设置 cookie

```js
Cookies.set('cookieName', 'cookieValue', {可选配置项});
- expires: 7 // 过期时间为7天 或一个 Date 对象
- path: cookie 的路径
- domain: cookie 的域名
- secure: cookie 是否仅在 HTTPS 连接时传输
```

- 获取 Cookie

```js
const cookieValue = Cookies.get('cookieName')
```

- 删除 Cookie

```js
Cookies.remove('cookieName')
```

### 总结

项目的 cookie 中 存储一个 theme-black: false 的键值对

每次我们点击 切换主题 的按钮的时候, 都会将 true / false 保存到 theme 变量
利用 watch 和 cookie 对象中保存的值 进行比对,

**通过 this.$vuetify.theme.dark 来控制当前的主题色是什**么

<br><br>

# Vuetify 的主题的概念

vuetify 默认就是 light 主题, 我们可以通过控制 dark 选项的值 来控制当前的主题色是深色还是浅色

```js
import Vue from 'vue'
import Vuetify from 'vuetify/lib'

Vue.use(Vuetify)

export default new Vuetify({
  theme: { dark: true }
})
```

而我们的 main.js 中的写法是

```js
const opts = {
  icons: {
    iconfont: 'mdi'
  },
  theme: {
    // 这里
    dark: false,
    // 这里用于配置主题的颜色
    themes: {
      light: {},
      dark: {
        primary: '#575757'
      }
    }
  }
}
```

当你指定一个组件为浅色或暗色时，除非另有指定，所有子组件将继承并应用同样的组件。 您可以通过更改 this.$vuetify.theme.dark 到 true 或 false 来手动打开或关闭 深色模式

当你将 this.$vuetify.theme.dark 的布尔值设置为 true（即切换到暗黑模式）时，Vuetify 会自动在所有的类名前添加一个 `.theme--dark` 的标识。这个标识会应用到 Vuetify 的组件和元素上，使它们使用暗黑模式的样式。

反之为 `.theme--light`

<br><br>

# ElementPlus 主题色

### 步骤:

**1. 在 main.js 中添加 暗黑模式下的样式**

```js
import 'element-plus/theme-chalk/dark/css-vars.css'
```

**2. 安装 vueuse**

```s
npm i @vueuse/core
```

**3. 使用 @vueuse/core 提供的api 实现主题切换**
`useDark`它是通过读取`localStorage/sessionStorage`的存储值（key 是可自定义的）。从而设置html的class

elementPlus本身就支持dark模式, 只需要在 html标签上添加 `class='dark'` 就可以切换到暗黑模式

- isDark: 它是通过这个boolean值 来控制当前的颜色是否是暗黑模式
- useToggle: 返回的方法就是在改变isDark的值

```vue
<script setup lang="ts">
import { useDark, useToggle } from '@vueuse/core'

const isDark = useDark({
  // selector: 'body', 应该还可以往指定的结构上添加
  // localStorage里面的key
  storageKey: 'darkKey',
  // class 类名
  valueDark: 'dark',
  // class 类名
  valueLight: 'light'
})
const toggleDark = useToggle(isDark)
</script>

<template>
  <div>Demo</div>
  <hr />
  <el-row class="mb-4">
    <el-button @click="toggleDark()">Change</el-button>
  </el-row>
</template>
```

```vue
<!-- 组件中的使用方式 -->
<template>
  <el-switch
    v-model="isDark"
    inline-prompt
    active-text="dark"
    size="large"
    inactive-text="light"
    @change="toggleDark"
  />
</template>
<script setup lang="ts">
const isDark = useDark()
const toggleDark = useToggle(isDark)
</script>
```

<br>

### 覆盖 elementPlus 默认的暗黑主题色

**官方网站:**  
如果您使用 scss，您也可以导入 scss 文件来实现一样的效果

1. 创建一个文件 styles/element/index.scss

```scss
/* 覆盖你需要的变量 */
@forward 'element-plus/theme-chalk/src/dark/var.scss' with (
  $bg-color: (
    'page': #0a0a0a,
    '': #626aef,
    'overlay': #1d1e1f
  )
);
```

然后在入口文件中 引入

```js
import './styles/element/index.scss'
```

<br>

**我的想法:**  
思路, 因为我们切换到暗黑模式下的时候, html身上会有dark的类名, 所以基于这点我定义了一个scss文件 分别指明 亮色 和 暗黑的时候的样式

但是elementPlus中变量的问题怎么解决 最好是覆盖

1. 使用 useDark 切换主题
2. 定义dark 和 light的scss文件 在入口文件中引入使用

```scss
html.dark {
  background-color: #8338ec;

  // 也可以在这里对elementPlus中的变量进行覆盖
  // --el-bg-color: #626aef;
  // .el-button--primary {
  //   --el-button-text-color: #ededed;
  // }
}
```

```js
import { createApp } from 'vue'

import App from './App.vue'
import router from '@/router'
import store from '@/store'

// 暗黑主题色
import 'element-plus/theme-chalk/dark/css-vars.css'
// 用于覆盖的颜色
import './styles/element/theme-dark.scss'

createApp(App).use(router).use(store).mount('#app')
```

<br>

**方式2:**
参考`https://blog.csdn.net/gsy445566778899/article/details/130843599`

1. 创建如下的scss文件

```scss
// /node_modules/element-plus/theme-chalk/src/common/var.scss
@forward 'element-plus/theme-chalk/src/dark/var.scss' with (
  // 覆盖 var.scss 中的变量 这里覆盖的应该是暗黑模式下的主色调
  $colors:
    (
      'primary': (
        'base': #8338ec
      ),
      'black': #575757
    )
);

@use 'element-plus/theme-chalk/src/dark/css-vars.scss' as *;
```

2. 在main.js中引入该文件

```js
import { createApp } from 'vue'

import App from './App.vue'
import router from '@/router'
import store from '@/store'

import './styles/element/dark/dark.scss'

createApp(App).use(router).use(store).mount('#app')
```

<br><br>

# Vue3 知识点相关

## defineOptions 宏

```s
https://vue-macros.dev/macros/define-options.html
```

它相当于我们Vue2中的options api

在Vue3.3开始我们可以使用该宏在 setup 中 定义如下内容

```js
defineOptions({
  name: 'Layout',
  inheritAttrs: false
})
```

<br>

### 注意:

和 props 有所不同，透传 attributes 在 JavaScript 中保留了它们原始的大小写，所以像 foo-bar 这样的一个 attribute 需要通过 `$attrs['foo-bar']` 来访问

<br><br>

# Vue2 和 Vue3 的生命周期

| Vue2(选项式API) | Vue3(setup)     | 描述               |
| :-------------- | :-------------- | :----------------- |
| beforeCreate    | -               | 实例创建前         |
| created         | -               | 实例创建后         |
| beforeMount     | onBeforeMount   | DOM挂载前调用      |
| mounted         | onMounted       | DOM挂载完成调用    |
| beforeUpdate    | onBeforeUpdate  | 数据更新之前被调用 |
| updated         | onUpdated       | 数据更新之后被调用 |
| beforeDestroy   | onBeforeUnmount | 组件销毁前调用     |
| destroyed       | onUnmounted     | 组件销毁完成调用   |

<br><br>

# Vue2 和 Vue3 的数据传递

| 方式             | Vue2       | Vue3                 |
| :--------------- | :--------- | :------------------- |
| 父传子           | props      | props                |
| 子传父           | $emit      | emits                |
| 父传子           | $attrs     | attrs                |
| 子传父           | $listeners | 无(合并到 attrs方式) |
| 父传子           | provide    | provide              |
| 子传父           | inject     | inject               |
| 子组件访问父组件 | $parent    | 无                   |
| 父组件访问子组件 | $children  | 无                   |
| 父组件访问子组件 | $ref       | expose&ref           |
| 兄弟传值         | EventBus   | mitt                 |

<br><br>

# Vue2 和 Vue3 中路由守卫的使用区别

| 路由名                   | Vue2               | Vue3                                    |
| :----------------------- | :----------------- | :-------------------------------------- |
| 全局前置路由守卫         | router.beforeEach  | useRouter().beforeEach                  |
| 全局后置路由守卫         | router.afterEach   | useRouter().afterEach                   |
| 独享路由守卫             | routes/beforeEnter | routes/beforeEnter                      |
| 组件内的路由守卫(进入前) | beforeRouteEnter   | options api(另一个script)/defineOptions |
| 组件内的路由守卫(更新)   | beforeRouteEnter   | onBeforeRouteUpdate                     |
| 组件内的路由守卫(离开前) | beforeRouteLeave   | onBeforeRouteLeave                      |

<br><br>

# Vue3动态引入图片的方式

还得通过 new URL 去引入

```js
// assest/ の中の画像をとるメソッド
type getAssetsResourceType = (imgName: string) => string
export const getAssetsResource: getAssetsResourceType = imgName => {
  return new URL(`/src/assets/image/${imgName}`, import.meta.url).href
}
```

<br><br>

# GWES Vue2

## Vuetify的布局结构

- v-app
  - v-app-bar: 总是放在应用顶部
  - v-navigation-drawer: 可以放置在应用的左边或右边并且可以配置在 v-app-bar 的旁边或下面。
  - v-main
    - v-container
      - router-view
  - v-bottom-navigation: 总是放在应用底部
  - v-footer: 总是放在应用底部

v-navigation-drawer 是配合 v-app-bar 使用的, 它是 导航栏的抽屉

<br>

### v-container的作用

v-container 是 Vuetify 框架中的一个组件，用于设置内容的容器，可以为内容区域提供定宽和定位。

它可以设置最大宽度、最小宽度、内外边距等样式属性，使内容在不同设备的屏幕上呈现出更好的效果。

**作用:**

1. 它是网格响应式布局的容器
2. 栅格系统的最外层是`<v-container>`标签 该标签能使里面的内容居中水平填充在页面上展示

<br><br>

## ElementPlus的布局结构

### el-container的作用

它是布局容器组件, 搭建页面的基本结构

`<el-container>`：外层容器。 当子元素中包含 `<el-header>` 或 `<el-footer>` 时，全部子元素会垂直**上下**排列， 否则会水平左右排列。

`<el-header>`：顶栏容器。

`<el-aside>`：侧边栏容器。

`<el-main>`：主要区域容器。

`<el-footer>`：底栏容器。

<br>

### 布局组件默认会有padding

可以通过css设置没

```scss
.el-header,
.el-main,
.el-aside {
  margin: 0;
  padding: 0;
}
```

### el-col 列宽可以指定auto

<br><br>

## html结构

### App组件

app组件里面里面是一个 v-app 里面包裹着一个 router-view

```html
<v-app id="inspire">
  <router-view />
</v-app>
```

<br>

### layout组件: 路由组件

layout组件是通过url访问 / 展示到 app组件的 router-view 里面的

layout组件里面 div里面有两个组件

- sidebar
- app-main

```html
<div class="app-wrapper">
  <sidebar />
  <app-main />
</div>
```

<br>

### sidebar组件

sidebar组件中有3个部分

1. 头部区域
2. 侧边栏区域 它和模块区域 使用v-if只能展示一个
3. 模块选择区域

### heard组件相关

1. 三个横线:

- w72 h64

2. gwes

- w80 h48

剩下的主要部分就是48 x 48

<br><br>

## 项目要点:

1. 自己修改的背景色 在做暗黑效果的什么 会有问题, 比如手动设置暗黑效果时的样式

2. html.dark

<br><br>

# i18n的使用方式

### 下载

```s
npm i vue-i18n@9
```

<br>

### 创建 i18n 的配置文件夹

```s
| - src
  | - lang
    - en.ts
    - ja.ts
    - zh.ts

    - index.ts # i18n 的配置文件
```

<br>

### ja.ts 语言定义文件 里面的内容

js文件 默认暴露 一个对象, 里面放置 kv

```js
export default {
  // ボタン
  search: '検索'
}
```

<br>

### 配置 i18n 的配置文件

1. 从 vue-i18n 导出 createI18n
2. 引入 Cookies 包: (要从cookie中获取当前是什么语言)
3. 引入 语言定义文件
4. 创建 message 对象, 里面配置好语言

```js
import { createI18n } from 'vue-i18n'
import Cookies from 'js-cookie'

import enLocale from './en'
import jaLocale from './ja'
import zhLocale from './zh'
import * as stringUtils from '@/utils/stringUtils'

const messages = {
  en: {
    ...enLocale
  },
  ja: {
    ...jaLocale
  },
  zh: {
    ...zhLocale
  }
}

/**
 * 言語取得
 * @return {string} 言語識別「ja、en」など
 */
function getLanguage(): string {
  const chooseLanguage: string = Cookies.get('language')
  if (!stringUtils.isEmpty(chooseLanguage)) return String(chooseLanguage)

  // if has not choose language
  const language = navigator.language.toLowerCase()
  console.log('navigator.language: ', language)
  const locales = Object.keys(messages)
  for (const locale of locales) {
    if (language.includes(locale)) {
      return locale
    }
  }
  return 'ja'
}

const i18n = createI18n({
  locale: getLanguage(),
  legacy: false,
  globalInjection: true,
  messages
})

export default i18n
```

<br>

### 入口文件中进行注册

```js
import i18n from './lang'

createApp(App).use(i18n).mount('#app')
```

<br>

### 文件中使用 i18n

```html
<!-- 方式1: -->
<script setup lang="ts">
  import { useI18n } from 'vue-i18n'

  defineOptions({
    name: 'Login'
  })

  const { t } = useI18n()
</script>

<script>
  import { getCurrentInstance } from 'vue'
  import { useI18n } from 'vue-i18n'

  import i18n from '@/lang' // 引入i8n实例

  export default {
    setup() {
      // 第一种方法：获取i18n实例对象 t 的方法1
      const { proxy } = getCurrentInstance()
      const t1 = proxy.$t('hello')
      console.log(t1)

      // 第二种方法：获取i18n实例对象 t 的方法1
      const t2 = i18n.global.t('hello')
      console.log(t2)
    },
    mounted() {
      // 第四种方法：获取i18n实例对象 t 的方法4
      const t4 = this.$t('hello')
      console.log(t4)
    }
  }
</script>
```

<br>

### i18n实例上的属性

useI18n() 方法返回的就是 i18n 实例

```js
{
  allowComposition: boolean,
  dispose: f
  mode: "composition",

  global: {
    availableLocales: ['ja', 'zh', 'en'],
    message: ComputedRefImpl, // 里面是翻译
    locale: ComputedRefImpl // 当前的 语法 ja
  }
}
```

<br><br>

# 响应式布局

- xs <768px
- sm ≥768px
- md ≥992px
- lg ≥1200px
- xl ≥1920px

<br><br>

# 登录

### permission 逻辑

白名单

```js
const whiteList = ['/login', '/changePass']
```

我们在 路由前置守卫中做了如下的逻辑

1. 获取 token
2. 判断 **如果有 token** 且 from.name 有值 有token 则方形

- 如果 访问的是 /login 则放行
- 如果 访问的是 其它页面 则放行
- 如果 访问的是 没有匹配的路径 则 跳回 /login 页面

3. 判断 **如果没有 token**

- 看你是否在白名单内, 在 则放行
- 不在白名单内 则在sessionStorage中保存你要去往的页面, 再跳转回 /login

<br>

### login页面逻辑

- **created**: 在这里检查 theme

- **mounted**: 页面一挂载的时候就会优先判断 进行一次跳转 如果没有 redirectPath 我们就需要通过 输入表单项 进行跳转

  - 修改 document.title
  - 获取 token
  - 获取 sessionStorage 中保存的 redirectPath
  - 判断 如果有 token 有 redirectPath 同时我们能从redirectPath中提取出来 moduleId 则 调用 locationRedirectPath
    - 获取 moduleId
    - 获取 当前语言 ja
    - 调用 getMenuRouteData 请求 menuList 并保存在 localStorage 中
    - 跳转到 layout 页面

- **handleLogin**: 登录表单提交的页面
  - 在 localStorage 中保存 用户输入的用户名 和 密码
  - 发起 login 请求, 请求后做如下的逻辑
    - 删除上面保存在 localStorage 中的用户名和密码
    - 在 localStorage 中保存
      - userInf
      - userCenterData
      - userLicenseList
    - 获取 redirectPath
      - 如果没有 则 跳转到 layout 页面
      - 如果有 则 跳转到 redirectPath
        - 总结:
          - 如果 跳转到 redirectPath 这里, 会发起请求menuList
          - 如果 跳转到 layout 则, menuList 的逻辑就不在这里

<br>

### mounted里面的逻辑

1. 设置 document.title
2. 获取 localStorage中的token
3. 调用 `getRedirectPath` 方法 从session中获取 permission 中保存的 redirectPath: 获取 删掉 返回
4. 判断条件 执行 `locationRedirectPath`

- 获取 pa
- 获取 lang
- 判断 有 pa lang 的时候 调用 `getMenuRouteData` 再进行跳转页面
- 如果没有 pa lang 则直接调用 页面

### 登录请求返回的内容

1. userLicenseList: 模块名 pa
2. userCenterData: 里面有一个 centerCodeList center列表
3. userInf:

当我们获取到这些数据后, 会调用 `setTokenUser...` 系列的方法, 将它们保存到 localStorage 当中

```js
{
  "code": 0,
  "message": "SUCCESS",
  "data": {
    "userInf": {
        "userId": "demo2",
        "userName": "デモユーザー2",
        "passwordChangeFlag": false,
        "centerCode": "DEMO1",
        "centerName": "デモセンター１",
        "kindName": null,
        "dateLimit": null,
        "dateLimitFlg": false,
        "pageRowMax": 10,
        "csvCharset": "UTF-8"
      }
    "userLicenseList": [
      { "moduleId": "bm", "state": true },
      { "moduleId": "wf", "state": true }
    ],
    "userCenterData": {
      "centerCodeList": [
        "DEMO1",
        "centermultiple1",
        "centermultiple2"
      ],
      "mainCenterCode": "DEMO1",
      "workPlaceClassColumnName": null,
      "workPlaceClassIndex": null
    },

  }
}
```

<br><br>

# 动态添加路由

<br><br>

# el-form

## 校验规则相关:

### Ts类型相关

```js
import type { FormInstance, FormRules } from 'element-plus'
```

- Form表单实例的类型: `FormInstance`
- Form验证规则数组的类型: `FormRules<收集表单数据对象的类型>`

<br>

### el-form 标签属性

- hide-required-asterisk: 去掉小星星

<br>

### 步骤

**1. 使用 ref 定义接收 form dom结构的 变量**

```js
const formRef = ref<FormInstance>()
```

**2. 给 el-form 添加如下的标签属性**

- model
- rules

```html
<el-form
  ref="formRef"
  class="login-main__form"
  label-position="top"
  :model="loginForm"
  :rules="loginFormRules"
  :hide-required-asterisk="true"
></el-form>
```

**3. 定义 校验规则对象 loginFormRules, 每个表单项的规则对应一个数组, 每个表单项可以指定多条规则**

- 自定义规则 使用 validator
- 正则校验 使用 pattern
- trigger: blur | change | submit

```js
const checkUsername = (_, val: string, callback: any): void => {
  const reg = /^[a-zA-Z0-9]*$/

  // 校验不通过: 调用 callback(new Error())
  if (!reg.test(val)) return callback(new Error(t('INPUT_ERR_MESSAGE.LOGIN.LOGIN_USERNAME_MORE_DIGIT_ERR')))

  // 校验通过: 调用 callback()
  callback()
}


const loginFormRules: FormRules<typeof loginForm> = {
  // 数组中每一个对象 即为一条验证规则
  username: [
    {
      required: true,
      message: t('INPUT_ERR_MESSAGE.LOGIN.LOGIN_USERNAME_NULL_ERR'),
      trigger: 'submit'
    },
    {
      max: 10,
      message: t('INPUT_ERR_MESSAGE.LOGIN.LOGIN_USERNAME_MORE_DIGIT_ERR'),
      trigger: 'submit'
    },
    {
      // 自定义规则
      validator: checkUsername,

      // 正则校验
      pattern: /^[a-zA-Z0-9]*$/,
      message: t('INPUT_ERR_MESSAGE.LOGIN.LOGIN_USERNAME_MORE_DIGIT_ERR'),
      trigger: 'submit'
    }
  ],
  password: [
    {
      required: true,
      message: t('INPUT_ERR_MESSAGE.LOGIN.LOGIN_PASSWORD_NULL_ERR'),
      trigger: 'submit'
    },
    {
      max: 20,
      message: t('INPUT_ERR_MESSAGE.LOGIN.LOGIN_PASSWORD_MOER_DIGIT_ERR'),
      trigger: 'submit'
    }
  ]
}
```

<br>

**4. 提交表单前, 调用 form 身上的 validate() 对表单项再次校验**

```js
const loginHandler = async (): void => {
  await formRef.value.validate()
  ... 校验通过的逻辑
}
```

<br><br>

# SideBar的逻辑

该页面中通过一个 `pathIsNotRoute()` 方法控制页面结构的展示和隐藏

```js
pathIsRoute() {
  return this.$route.path === '/'
},
pathIsNotRoute() {
  return !this.pathIsRoute()
},
```

- pathIsRoute: 首页 layout 页面
- pathIsNotRoute: 首页之外的页面

<br>

### 总结:

- 如果是 / 我们展示: 模块选择界面
- 如果非 / 我们展示: 其它结构

也就是我们从 login 进入到 layout 页面, 这种就展示 模块选择界面 否则就进入的后台管理界面

<br><br>

## 各个配置项的总结

###

```js
;[
  {
    moduleCode: 'wa',
    path: '/gwes/wa/workProcessAnalysis',
    name: 'workProcessAnalysis',
    meta: {
      moduleCode: 'wa',
      title: '工程別作業分析',
      screenId: 'workProcessAnalysis'
    },
    language: 'ja',
    key: 'wa_1_workProcessAnalysis',
    treeLevel: 1,
    title: '工程別作業分析',
    menuKind: '03',
    sortKey: 100,
    hidden: false,
    basePath: 'workProcessAnalysis',
    parentName: null,
    icon: '/src/assets/image/icon_work_process_analysis.png',
    hasSubMenu: true,
    isExternal: false,
    children: [
      {
        moduleCode: 'wa',
        path: '/gwes/wa/workProcessAnalysis/dailyThroughputMonitor',
        name: 'dailyThroughputMonitor',
        meta: {
          moduleCode: 'wa',
          title: '日別スループットモニタ',
          screenId: 'dailyThroughputMonitor'
        },
        language: 'ja',
        key: 'wa_0_dailyThroughputMonitor',
        treeLevel: 0,
        title: '日別スループットモニタ',
        menuKind: '01',
        sortKey: 101,
        hidden: false,
        basePath: 'workProcessAnalysis/dailyThroughputMonitor',
        parentName: 'workProcessAnalysis',
        icon: null,
        hasSubMenu: false,
        isExternal: false,
        children: []
      },
      {
        moduleCode: 'wa',
        path: '/gwes/wa/workProcessAnalysis/hourlyThroughputMonitor',
        name: 'hourlyThroughputMonitor',
        meta: {
          moduleCode: 'wa',
          title: '時間別スループットモニタ',
          screenId: 'hourlyThroughputMonitor'
        },
        language: 'ja',
        key: 'wa_0_hourlyThroughputMonitor',
        treeLevel: 0,
        title: '時間別スループットモニタ',
        menuKind: '01',
        sortKey: 102,
        hidden: false,
        basePath: 'workProcessAnalysis/hourlyThroughputMonitor',
        parentName: 'workProcessAnalysis',
        icon: null,
        hasSubMenu: false,
        isExternal: false,
        children: []
      },
      {
        moduleCode: 'wa',
        path: '/gwes/wa/workProcessAnalysis/workloadMonitor2',
        name: 'workloadMonitor2',
        meta: {
          moduleCode: 'wa',
          title: '作業実績モニタ（作業別時間毎）',
          screenId: 'workloadMonitor2'
        },
        language: 'ja',
        key: 'wa_0_workloadMonitor2',
        treeLevel: 0,
        title: '作業実績モニタ（作業別時間毎）',
        menuKind: '01',
        sortKey: 103,
        hidden: false,
        basePath: 'workProcessAnalysis/workloadMonitor2',
        parentName: 'workProcessAnalysis',
        icon: null,
        hasSubMenu: false,
        isExternal: false,
        children: []
      },
      {
        moduleCode: 'wa',
        path: '/gwes/wa/workProcessAnalysis/dailyBacklogMonitor',
        name: 'dailyBacklogMonitor',
        meta: {
          moduleCode: 'wa',
          title: '日別作業残モニタ',
          screenId: 'dailyBacklogMonitor'
        },
        language: 'ja',
        key: 'wa_0_dailyBacklogMonitor',
        treeLevel: 0,
        title: '日別作業残モニタ',
        menuKind: '01',
        sortKey: 104,
        hidden: false,
        basePath: 'workProcessAnalysis/dailyBacklogMonitor',
        parentName: 'workProcessAnalysis',
        icon: null,
        hasSubMenu: false,
        isExternal: false,
        children: []
      }
    ]
  }
]
```

<br><br>

## 报错“Cannot find module ‘./App.vue‘ or its corresponding type declaration” 问题解决方法

安装vite框架（Vue3）后，项目“main.ts” 文件中 “import App from ‘./App.vue’” 部分有红色报错提示，其他文件有些import引入文件也报错。

<br>

### 报错原因：

vite使用的是ts，ts不识别 .vue 后缀的文件, 在 TypeScript 中，当导入一个模块时，需要为该模块提供一个类型声明，以便编辑器能够正确地推断和检查模块的类型。

<br>

### 解决方式:

根目录下找到 `vite-env.d.ts` 在该文件下添加如下的代码

这个声明将告诉TypeScript如何处理.vue文件的导入。它使用了Vue的DefineComponent类型来声明.vue文件的组件类型。

```js
declare module "*.vue" {
  import { DefineComponent } from "vue"
  const component: DefineComponent<{}, {}, any>
  export default component
}
```

<br><br>

# 路由跳转逻辑
我们给导航标签绑定的是 path, 也就是说当我们点击导航标签的时候 路径会映射为 ``/gwes/pa/master/workerMaster``

```js
[
  {
    "moduleCode": "pa",

    // 这
    "path": "/gwes/pa/master/workerMaster",

    "name": "workerMaster",
    "meta": {
      "moduleCode": "pa",
      "title": "作業者マスタメンテナンス",
      "screenId": "workerMaster"
    },
    "language": "ja",
    "key": "pa_0_workerMaster",
    "treeLevel": 0,
    "title": "作業者マスタメンテナンス",
    "menuKind": "01",
    "sortKey": 601,
    "hidden": false,
    "basePath": "master/workerMaster",
    "parentName": "master",
    "icon": null,
    "hasSubMenu": false,
    "isExternal": false,
    "children": []
  },
]
```

然后再 setLeftMenuList 文件中 ``getMenuRouteData`` 方法中 会将下面的对象中的 menuRoutePath 交给 ``getNamedComponent`` 方法
```js
{
  "treeLevel": 0,
  "menuKey": "pa_0_summaryDashboard",
  "moduleCode": "pa",
  "menuKind": "01",
  "menuCode": "summaryDashboard",
  "parentMenuCode": "progressSummary",
  "sortKey": 101,
  "menuTitleName": "全体進捗ダッシュボード",
  "menuUrl": "/gwes/pa/progressSummary/summaryDashboard",
  "menuIconPath": null,
  "menuRoutePath": "summaryDashboard",
  "menuMetadata": null
}
```

``getNamedComponent`` 方法会根据 路由映射对象中的 name 和 menuRoutePath 进行比较找到对应的路由映射对象

然后会将它对象整合到 subRoutes 最后会将 subRoutes push到常量路由表中
```js
const roleRoute = {
  path: '/gwes/module',
  alias: ['/gwes/pa', '/gwes/wa', '/gwes/ia', '/gwes/so', '/gwes/ro', '/gwes/me', '/gwes/dc', '/gwes/bm', '/gwes/wf'],
  component: Layout,
  name: 'Module',
  meta: {
    hasSubMenu: true,
    hidden: true
  },
  children: [] as menuItemsType[]
}
roleRoute.children = moduleMenuItems
router.addRoute(roleRoute)
```

我们push到常量路由表中的东西就是有path 和 component 的
```js
{
  "moduleCode": "pa",


  "path": "/gwes/pa/master/calendarMaster",


  "name": "calendarMaster",
  "meta": {
      "moduleCode": "pa",
      "title": "カレンダマスタメンテナンス",
      "screenId": "calendarMaster"
  },
  "language": "ja",
  "key": "pa_0_calendarMaster",
  "treeLevel": 0,
  "title": "カレンダマスタメンテナンス",
  "menuKind": "01",
  "sortKey": 602,
  "hidden": false,
  "basePath": "master/calendarMaster",
  "parentName": "master",
  "icon": null,
  "hasSubMenu": false,
  "isExternal": false,
  "children": []
}
```

<br><br>

# Vue3项目在打包的时候 忽略类型检查
```js
{
  "build": "vue-tsc --noEmit --skipLibCheck && vite build",
  "build-temp": "vite build",
}
```

<br><br>

# 使用 v-model 传递数据到子组件

### 父组件要点
**1. 定义响应式数据**
```js
let strValue = ref<string>('default2')
// eslint-disable-next-line
let numValue = ref<number>(2)
```

**2. 使用 v-model 将数据传递给子组件**  
1. 父组件使用 ``v-model="strValue"`` 传递给子组件的数据, 子组件在使用props接收的时候 key 的名字默认为 ``modelValue``

2. 父组件可以使用 ``v-model:变量名="变量"`` 的形式, 给子组件的props起名字, 这样子组件在使用props接收的时候 key的名字为 ``testNumVal``
```html
<WorkerSearchArea
  v-model="strValue"
  v-model:testNumVal="numValue"
/>
```

<br>

### 子组件要点:
父组件使用 v-model 传递过来的数据, 我们要使用 props 来接收

**1. 不使用 TS 的接收方式**
```js
defineProps({
  modelValue: {
    // 注意: string 这种写法 控制台会提示错误 必须是String
    type: String,
    default: ''
  }
})
```

<br>

**2. 使用 TS 的接收方式**  
我们在使用TS声明接收父组件传递过来的变量的时候, 只是使用TS的type类型是不够的, 会报未声明接收的错误, 所以我们必须使用 ``withDefaults`` 默认值的形式声明接收父组件使用 ``v-model`` 传递过来的数据

1. 数据的类型的是否必须都是通过 ``type`` 来指定的
2. 使用 ``withDefaults()`` 来指定默认值
```js
type propsType = {
  modelValue: string,
  testNumVal: number
}
defineProps<propsType>()
```
```js
type propsType = {
  modelValue: string,
  testNumVal: number
}
const props = withDefaults(defineProps<propsType>(), {
  modelValue: 'default-str',
  testNumVal: 0
})
```

<br>

**3. 使用 props**  
1. 模版中可以直接使用 props 中声明的变量
2. script中需要通过 props.modelValue 来调用变量

<br>

**4. 修改 基本类型 的 props**  
如果我们要是想在子组件中修改父组件使用 v-model 传递过来的 props 需要使用 defineEmits() 宏通过 emit 来发射事件 通知父组件来进行修改, **父组件并不用在子组件身上绑定自定义事件**

1. defineEmits 写法1: 数组, 我们传入数组, 元素为 ``update:变量名``
2. defineEmits 写法1: 对象
```js
type emitsType = {
  (e:"update:msg", msg:string):void,
  (e:"update:count", count:number):void,
}

const emit = defineEmits<emitsType>()


// 3.3+：另一种更简洁的语法
const emit = defineEmits<{
  change: [id: number] // 具名元组语法
  update: [value: string]
}>()
```

示例:
```js
// props声明接收部分
type propsType = {
  demo: string
}
const props = withDefaults(defineProps<propsType>(), {
  demo: 'default-str'
})


// 自定义事件部分
const emit = defineEmits(['update:demo'])

const clickHandler = (): void => {
  console.log('clickHandler', props.demo)
  emit('update:demo', '修改str')
}
```

<br><br>

## v-model 使用上的通用要点:
### 1. 修改 使用 v-model 绑定的 **基本类型** 的数据
如果我们要是想在子组件中修改父组件使用 v-model 传递过来的 props 需要使用 defineEmits() 宏通过 emit 来发射事件 通知父组件来进行修改,这时 **父组件并不用在子组件身上绑定emit发射的自定义事件**

1. defineEmits 写法1: 数组, 我们传入数组, 元素为 ``update:变量名``
2. defineEmits 写法1: 对象
```js
type emitsType = {
  (e:"update:msg", msg:string):void,
  (e:"update:count", count:number):void,
}

const emit = defineEmits<emitsType>()


// 3.3+：另一种更简洁的语法
const emit = defineEmits<{
  change: [id: number] // 具名元组语法
  update: [value: string]
}>()
```

<br>

**示例:**
```js
// props声明接收部分
type propsType = {
  demo: string
}
const props = withDefaults(defineProps<propsType>(), {
  demo: 'default-str'
})


// 自定义事件部分
const emit = defineEmits(['update:demo'])

const clickHandler = (): void => {
  console.log('clickHandler', props.demo)
  emit('update:demo', '修改str')
}
```

<br>

### 2. 修改 使用 v-model 绑定的 **引用类型** 的数据
**方式1: 使用 reactive 响应式数据转换props过来的对象**  
1. 父组件使用 v-model 给子组件传递了 对象
```html
<script>
  type objType = {
    name: string,
    age: number
  }
  const obj = reactive<objType>({
    name: 'sam',
    age: 0
  })
</script>

<WorkerSearchArea
  v-model:form="obj"
/>
```

2. 子组件部分
```js
// 1. 声明接收
type propsType = {
  form: {
    name: string,
    age: number
  }
}
const props = withDefaults(defineProps<propsType>(), null)

// 2. 子组件定义响应式数据, 用于将props过来的对象转换为组件内部的state
const searchForm = reactive(props.form)

// 3. 定义 emit 通知父组件进行修改
const emit = defineEmits(['update:form'])

// 4. 按钮的回调
const clickHandler = (): void => {
  // 修改 组件内部的状态, 然后将该状态交给emit的参数2
  searchForm.name = 'erin'
  searchForm.age = 18
  emit('update:form', searchForm)
}
```

<br>

**注意:**  
如果父组件传过来的数据是异步获取的，则需要使用 watch 进行监听
```js
watch(() => props.modelValue, () => { sea.value = props.modelValue })
```

<br>

**方式2: 使用 computed**  
使用 computed 这种方式 不用使用 emit 来通知父组件进行修改, 直接就是双向绑定到父组件的对象中
```js
// 1. 声明接收props
type propsType = {
  form: {
    name: string,
    age: number
  }
}
const props = withDefaults(defineProps<propsType>(), null)


// 2. 使用 computed 返回 props.form
const searchForm = computed(() => props.form)

// 3. 模版中可以直接使用 v-model 绑定 searchForm 中的数据
<el-input v-model="searchForm.name"></el-input>
```

因为 props.form 是一个对象, 所以如下的方式的set并不起作用, 因为我们没有修改 props.form 本身 地址值的问题
```js
const searchForm = computed({
  get() {
    return props.form
  },
  set(v) {
    console.log(v)
  }
})
```

<br><br>

# Intl 对象 的使用
它提供了如下的3种功能

- 字符串对比 Collator, 用于语言敏感字符串比较的 collators构造函数
- 数字格式化 NumberFormat, 根据语言来格式化日期和时间的类的构造器类
- 日期和时间格式化 DateTimeFormat, 是对语言敏感的格式化数字类的构造器类

<br>

### Intl.DateTimeFormat
能使日期和时间在特定的语言环境下格式化

<br>

**语法:**  
**<font color="#C2185B">Intl.DateTimeFormat('语言标识', [options]).format(时间对象)</font>**  
```js
new Intl.DateTimeFormat('en-US').format(date)
// Expected output: "12/20/2020"
```

<br>

**参数:**  
1. local: string, en-US, ja-JP, zh-Hans-CN
2. options: 自定义日期时间格式化方法返回的字符
```js
// 请求参数 (options) 中包含参数星期 (weekday)，并且该参数的值为长类型 (long)
let options = {
  weekday: "long",
  year: "numeric",
  month: "long",
  day: "numeric",
  year: "numeric",
  month: "numeric",
  hour: "numeric",
  minute: "numeric",
  second: "numeric",
  hour12: false,
  timeZone: "America/Los_Angeles",
};
console.log(new Intl.DateTimeFormat("de-DE", options).format(date));
```

<br>

### Intl.NumberFormat
能使数字在特定的语言环境下格式化

<br>

**语法:**  
**<font color="#C2185B">Intl.NumberFormat('语言标识', [options]).format(数字)</font>**  
```js
new Intl.NumberFormat("zh-Hans-CN-u-nu-hanidec").format(number)
```

<br>

**参数:**  
1. local: string, en-US, ja-JP, zh-Hans-CN, 用于格式化数字的语言环境。默认值为当前用户的语言环境。
2. options: 定义返回字符串的格式
  - style：数字格式的样式。可以是decimal（十进制）、currency（货币）或percent（百分比）。默认值为decimal。
  - currency：如果样式为currency，则使用的货币代码。默认值为当前用户的货币代码。
  - currencyDisplay：如果样式为currency，则货币符号的显示位置。可以是symbol（符号）、code（代码）或name（名称）。默认值为symbol。
  - minimumIntegerDigits：数字的最小整数位数。默认值为 1。
  - minimumFractionDigits：数字的最小小数位数。默认值为 0。
  - maximumFractionDigits：数字的最大小数位数。默认值为 3。
  - minimumSignificantDigits：数字的最小有效数字位数。默认值为 1。
  - maximumSignificantDigits：数字的最大有效数字位数。默认值为 21。

```js
// 请求参数 (options) 中包含参数星期 (weekday)，并且该参数的值为长类型 (long)
let options = {
  style: "currency | unit",
  // 日元不使用小数位
  currency: "EUR | JPY",
  // 限制三位有效数字
  maximumSignificantDigits: 3,
  unit: "kilometer-per-hour | liter",
  unitDisplay: "long",
};
console.log(new Intl.NumberFormat("pt-PT", {
  style: "unit",
  unit: "kilometer-per-hour",
}).format(50),);
```

<br>

**千分位 逗号 分隔:**
```js
new Intl.NumberFormat().format(3500) // "3,500"
new Intl.NumberFormat().format('3500') // "3,500"。数字字符也能正确处理
```

<br>

**最多保留 4 位小数:**
```js
new Intl.NumberFormat(undefined, { maximumFractionDigits: 4 }).format(123456.78967)
// "123,456.7897"
```

<br>

**最少两位，最多四位:**
```js
new Intl.NumberFormat(undefined, { maximumFractionDigits: 4 }).format(123456.78967)
// "123,456.7897"
```

<br>

**加币种前缀:**
```js
const number = 123456.789;
// 美元 "$123,456.79"
new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(number) 
// 人民币 "¥123,456.79"
new Intl.NumberFormat('zh-CN', { style: 'currency', currency: 'CNY' }).format(number)
// 日元 "￥123,457"
new Intl.NumberFormat('ja-JP', { style: 'currency', currency: 'JPY' }).format(number)
// 韩元 "￦123,457"
new Intl.NumberFormat('ko-KR', { style: 'currency', currency: 'KRW' }).format(number)
```

<br>

**百分比显示:**
```js
[0.01, 1.2, 0.0123].map(num => {
    return new Intl.NumberFormat(undefined, { style: 'percent', maximumFractionDigits: 2 }).format(num) 
})
// ["1%", "120%", "1.23%"]
```

<br>

### Intl.Collator
用于语言敏感的字符串比较。

<br>

**语法:**  
```js
console.log(['Z', 'a', 'z', 'ä'].sort(new Intl.Collator('de').compare));
// Expected output: Array ["a", "ä", "z", "Z"]

console.log(['Z', 'a', 'z', 'ä'].sort(new Intl.Collator('sv').compare));
// Expected output: Array ["a", "z", "Z", "ä"]

console.log(
  ['Z', 'a', 'z', 'ä'].sort(
    new Intl.Collator('de', { caseFirst: 'upper' }).compare,
  ),
);
// Expected output: Array ["a", "ä", "Z", "z"]
```

<br><br>

## 保留两位小数的技巧, 第三位小数位不要哦
2300.125 有这样一个数字, 我们不考虑最后一位小数, 希望这个数字保留两位小数
```js
Math.floor(2300.125 * 100) / 100

// 1. 2300.125 * 100 = 230012.5
// 2. Math.floor 向下取整 230012
// 3. / 100 = 2300.12
```

<br><br>

### Vue3: JSON.stringify 的问题
1. reactive的对象 是可以通过 JSON.stringify 直接转的
2. ref 和 computed 的数据, 需要.value后才能进行转换

<br><br>

# Vuelidate
1. 如果要使用正则 需要引入 ``@/utils/validatorCustomRules`` 文件 在里面我们定义好正则的规则 引入 通过如下的方式使用
```js
alphanumeric: helpers.withMessage(t('INPUT_ERR_MESSAGE.LOGIN.LOGIN_USERNAME_MORE_DIGIT_ERR'), alphaNumRule)
```

2. 如果要使用方法进行验证, 方法中需要return true / false, true是验证通过 false则是验证失败
```js
const checkWorkPayCostPerHour = (value: string | number): boolean => {
  const num = parseFloat(value)
  if (num) {
    if (
      num < 0 ||
      Math.floor(num).toString().length >= 7 ||
      (num % 1 !== 0 && num.toString().split('.')[1].length >= 3)
    ) {
      return false
    }
  }

  if (num < 0 || num > 999999.99) {
    return false
  }

  return true
}

workPayCostPerHour: {
  ...
  checkWorkPayCostPerHour: helpers.withMessage(t('ga_message.sixDigitsRangeError'), checkWorkPayCostPerHour)
},
```

<br><br>

# Ts: 从对象中获取对应的属性的时候 报的Ts错误
解决方式我们在 类型中 追加 [key: string] 索引签名 就可以了 索引签名是用来描述对象的索引类型的一种语法。在这个例子中，[key: string] 声明了一个索引签名，表示这个对象可以包含任意字符串类型的属性，而对应的属性值的类型是 infoItemType。这样的声明允许你使用任意字符串作为属性名来访问对象，并且 TypeScript 将确保这些属性的值符合 infoItemType 类型。

```js
const dialogInfo = computed(() => {
  // Element implicitly has an 'any' type because expression of type 'any' can't be used to index type 'patternType'.
  return pattern[contentType.value]
})

type patternType = {
  save: infoItemTyep,
  delete: infoItemTyep,
  cancel: infoItemTyep,
  default: infoItemTyep,
  [key: string]: infoItemTyep
}
```

<br><br>

# BEM规范: 可复用的css组件
bem是为了模块化css的一种规范

```s
https://github.com/awesome-css-group/awesome-css

Naming conventions & Methodologies

https://getbem.com/
```

```s
block   element   modifier
-----   -------   --------
  块      元素      修饰符
```

<br>

### Block: 组件
独立的实体，它本身是有意义的。可以理解为组件块 代表了更高级别的抽象或组件 一个block就是一个独立的功能的区块, 比如头部是个block 表单功能输入框也可以是一个block, block的功能可大可小

虽然块可以嵌套并相互交互，但它们在语义上保持相等;
没有优先级或等级。没有DOM表示的整体实体(如控制器或模型)也可以是块。

```s
header, container, menu, checkbox, input
```

<br>

### Element: 组件中的块
块的一部分，block的后代, 它没有独立的意义，在语义上与其块绑定在一起。

它是block的一部分不能独立使用, 所有的element都是与block紧密关联的 例如一个带有icon的输入框, 那么这个icon就是这个输入框block的一个Element 脱离了输入框block那么这个icon也就没有意义

```s
menu item, list item, checkbox caption, header title
```

<br>

### Modifier
块或元素上的标志。用它们来改变外表或行为。

它是用来修饰block和element的 表示block或者element在外观或行为上的改变, 例如前文提到的输入框block, 当鼠标悬停时边框高亮, 那么这个高亮的效果就应该用modifier来实现
```s
disabled, highlighted, checked, fixed, size big, color yellow
```

我觉得修饰符可以是不同于通用样式 具有独立的样式的时候我们使用修饰符

比如如下的情况
我们可以在通常情况下有一个正常的按钮，在不同的情况下有两个状态。

因为我们使用BEM通过类选择器对块进行样式化，所以我们可以使用任何我们想要的标签(button、a甚至div)来实现它们。

命名规则告诉我们使用 ``块-修饰符-值`` 语法。
```html
<button class="button">
	Normal button
</button>
<button class="button button--state-success">
	Success button
</button>
<button class="button button--state-danger">
	Danger button
</button>
```

使用修饰符的时候 一定带着原有的 块, 就比如上面那样, 修饰符仅是在原有的样式的基础上 来追加新的样式 不同的外观等 它是基于块的

也就是针对块的某一部分的样式进行重定义

<br>

### 嵌套层级很深的时候
块体结构应**进行平面化处理** 不需要反映块的嵌套DOM结构。所以，这种情况下的类名应该是:

```scss
.block {}
.block__elem1 {}
.block__elem2 {}
.block__elem3 {}
```

块的DOM表示可以嵌套:
```html
<div class='block'>
    <div class='block__elem1'>
        <div class='block__elem2'>
            <div class='block__elem3'></div>
        </div>
    </div>
</div>
```

**优点:**  
除了使类看起来更漂亮之外，它还使元素只依赖于块。

因此，在对界面进行更改时，您可以轻松地在块中移动它们。块DOM结构的更改不需要对CSS代码进行相应的更改。

<br>

### 要点: 全局css不推荐
bem不推荐我们使用全局css改变块的样式, 因为bem是推荐组件思想写样式, 我这个组件中使用了h2用来表示组件的title

而不是我们写一个title来控制网站中的所有title

<br>

### BEM命令
1. 尽量只使用类名选择器 不要使用tag或者id选择器
2. 使用小写字母 数字 或 -, 多个单词描述的时候使用 - 来链接
3. 使用两个__来链接block和element
4. 使用两个-- 来链接modifier和element或block


下图中 我们可以将每张卡片做为一个块
```html
<!-- product 就是块 一张卡片 -->
<div class="product">
  <!-- 当中每一个部分 比如 header desc img footer 是属于元素的部分 -->
  <div class="product__status"></div>
  <div class="product__model"></div>
  <div class="product__description"></div>
  <div class="product__image"></div>
  <div class="product__footer"></div>
</div>

<!-- 修饰符: 不同与通用样式 具有独立的样式的时候我们使用修饰符 -->
<div class="product product--recomannded">
</div>
```

<br><br>

# scss目录结构
```s
| - styles
  | - foundation # プロジェクトの基本スタイル（MixinTools、変数など）
    - _mixin.scss
    - _variable.scss

  | - module # スタイルモジュール（ボタンに関するスタイルここにおく、コンポーネント化にみたい感じ）
    - head
    - text
    - button
    - padding

  | - layout
  - styles.scss
```

<br><br>

# Echarts

### 类型
```s
npm install @types/echarts --save-dev
```

1. Echarts的实例的Ts类型为: echarts.ECharts
2. Echarts的option的Ts类型为: echarts.EChartOption
3. typeof Echarts返回的是Echarts构造函数的类型 跟 实例类型不一样哈


<br>

### 注意点:
vue3中 echarts 的返回的实例对象 需要使用 markRaw包裹一下, 让其不要成为响应式数据, 不然会报属性和方法找不到的错误
```js
//                       ↓
chartInstance.value = markRaw(getInitChart(chartRef.value, res.themeName))
```

<br><br>

# Moment的代替案 -> dayjs

Day.js 提供了一些处理时区的方法，但需要注意的是，Day.js 本身并没有内建的时区功能。它通常使用原生的 JavaScript Date 对象，而 Date 对象在处理时区方面有一些限制。

然而，你可以使用一些插件来增强 Day.js 处理时区的能力。例如，可以使用 dayjs-ext 插件，该插件为 Day.js 添加了一些处理时区的功能。

以下是一个简单的例子，展示了如何使用 dayjs-ext 插件处理时区

### dayjs-ext 插件
```s
https://github.com/prantlf/dayjs
https://www.npmjs.com/package/dayjs-ext

npm i dayjs-ext
```

<br><br>

# AppSelect默认值的问题
Vue2的时候 会组织成一个如下格式的数据格式 供option标签来显示
```js
{
  label: '文字',
  value: 'code'
}
```

Vue2的时候 label的默认值是null, 当我们点击 [清除] 按钮后 会将 option 选择的值 设置为 '',
因为没有匹配上 下拉框中就会是 空 的状态

<br>

Vue3的时候, label的默认值不能是null, 因为如果将 null 交给 ElOption 的话会报错, 因为ElOption只能是 string number object等, 它不接收null值

所以Vue3的时候我们将 allText 的部分的数据格式定义为如下
```js
{
  label: allText,
  value: ''
}
```

v-model绑定的初始值如果是也''的话, 那么就会展示allText


<br><br>

# Filter功能

### initInfo:
1. 在 mounted 的时候 会调用 initInfo 方法, 在该方法中会调用 getUserCenterList 方法获取到一个数组 res.data 它是每一个center信息的对象
```js
{
  "centerCode": "Center-GA-001",
  "centerName": "GAセンター１",
  "belongType": "M",
  "businessDate": "20231120",
  "currentCenterFlag": "1",
  "areaCode": null
}
```

2. 会将 center信息的数组 保存到实例的 centers 属性上
3. 根据 currentCenterFlag 字段 获取到 当前选择的center 然后将里面的 centerCode 保存到 workCenterCode
4. 调用 onChangeCenter 方法, 传入 workCenterCode

### onChangeCenter:
onChangeCenter的参数为传入的 workCenterCode, 会将该workCenterCode保存到searchForm.centerCode里面

然后组织请求参数
```js
const param = {
  centerCode: newCenterCode
}
```

调用 getInit 请求方法, 该方法会拿到

1. messageList: {}, ``"ui_common_center_code": "センターコード"``, 用于初始化 下拉框 的 label
2. pulldownCenter: 每个下拉框横向全满的数组
3. workPlacePullDownData: 下拉框中的选项吧
4. conditions: 下拉框是否展示的控制对象
3. dateTo: {}
4. dateFrom: {}

<br>

2. 然后会将获取到的信息为 searchForm 赋值
  1. searchForm中的 centerCode 被赋值
  2. dateFrom 和 dateTo  被赋值
  3. timeFrom 和 timeTo 和 workClass和workPlaceClass等被赋值为null

3. 作业分类的下拉框具有默认值

4. 清空存放错误消息的对象
5. 设置各个下拉框的label值
6. 设置各个下拉框是否展示的对象
7. 将 pulldownCenter 和 workPlacePullDownData 分别交给 centerWorkPlaceAll 和 workPlacePullDownData 属性

8. 调用 initWorkPlaces 方法

<br>

### initWorkPlaces
1. 该方法会调用 ``stUtil.formatWorkPlaceFilterSource(this.centerWorkPlaceAll, this.workPlacePullDownData)`` 方法 会将返回的结果 交给了 filterRawData
```js
{
  allItems: 原始的横向全数据数组
  fields: ["workClass1" ~ ] 的数组 只是key的部分
  uniqueItems: 从workPlacePullDownData对象中根据key将下拉框的值(数组) 推到了该属性中
}
```

2. 调用了 setFilter 方法

### setFilter
它里面只干了一件事情, 就是根据 searchForm 里面的数据, 然后过滤filterRawData中保存的数据, **然后拿到下拉框过滤后的数据**
```js
{
  workClass1: ['入荷', '格納', '出荷', 'ピック']
}
```

### initSelect
这个方法中只做了两件事
1. 初始化searchForm 将work系列重新置为null
2. 调用 setFilter


### setWorkPlaceValue
它是 AppSelect 的input事件的回调

回调中会拿到 newValue, filedName 两个参数
1. 判断 newValue 是不是为null, 如果为空则将searchForm对应字段的值设置为null
2. 否则有值的情况下就将searchForm对应字段的值设置为该值


### setFilter过滤数据都在哪里进行调用了
1. clickClearButton 点击 clear 按钮的时候 里面调用了 initSelect - setFilter
2. setWorkPlaceValue



### null 值的问题
我们在 selectItems 计算属性中 只能这么设置, 因为这里的label和value是要传递给 el-option的 它只接收String | Number | Boolean | Object, 不接收null值

所以这里只能设置为 ``''``
```js
const temp = {
  label: allText,
  value: ''
}
```

<br>

## [Vue Router warn]: No match found for location with path
我们是在layout页面挂载和login的时候 才会调用方法添加异步路由, 但是当我们刷新页面的时候 vue会优先检查url查看是否有匹配的路由 这时我们还没有添加呢 所以报的错

<br><br>

# 全体進捗ダッシュボード 逻辑


## Circular01.vue 中做了什么

### props
它接收两个数据
1. chartConfig
2. searchCondition

**chartConfig:**  
它是 init api 请求回来的数据中的 componentInfos 数组中的 一项 (item) 另外包括了 colorTheme 对象
```js
{
  "show_estimated_end_time": "1",
  "show_worker": "0",
  "chartTypeNo": "1",

  "colorTheme": { ... }

  "condition_work_class1": "入荷",
  "component_type": "Circular01",
  "sortKey": "1",
  "transition_value": "summaryDashboardByFloor",
  "component_width": "3",
  "transition_type": "1",
  "title": "入荷",
  "key": "Center-GA-001_1",
  "chartTypeName": "",
}
```

<br>

**searchCondition:**  
就是已经有值的searchForm
```js
{
  "centerCode":"Center-GA-001",
  "workPlanDate":"2023-10-24",
  "workEndDate":"2023-12-11",
  "workEndTime":"04:36"
}
```

<br>

### computed: loading
当 loading 发生变化的时候 会emit load 事件 发送会父组件的参数有

它会在请求前和请求后 被改变
```js
{ loading: newValue, searchTarget: this.searchTarget }
```

searchTarget是定义在实例上的一个boolean属性, 代表这 是否是检索对象

<br>

**searchTarget改变的时机**
1. 在 searchData方法 中 key和searchForm一致, 但是如果固有条件同key的值 和 searchForm中的值不一致的时候 searchTarget = false

2. search api 执行后 为修改为 true 如果没有响应的话被修改为 false

<br>

**loading改变的时机**  
请求前为 true 请求后为false

<br>

### mounted
1. 将 chartConfig 交给 ``getConfigCondition`` 交工后返回 configCondition, 也就是根据父组件传递过来的 chartConfig, 提取 和 追加有用的字段 **组织成子组件固有定的检索条件**
```js
this.configCondition: {
  chartTypeNo: 
  showEstimatedEndTime:
  showWorker:
  workClass1:
}
```

2. getInitialChartData 调用该方法 获取chart的初始化的配置对象

3. 调用 initChart 方法

<br>

### initChart
1. 首先调用 initChartWithTheme 获取 chart实例
2. 拿到 饼形图的颜色配置对象
3. 组织 chart options
4. setOption

<br>

### searchData
该方法在 watch 里面被调用, watch会监视从父组件传递过来的 searchCondition 当它里面的值有改变的时候 就会触发回调 执行searchData

并且会将最新的父组件中修改的 searchCondition 的值传入到 searchData 中

<br>

**内部逻辑:**  
1. 定义了target boolean类型的变量
2. 拿到下面的key value部分, 如果key在固有检索条件对象(configCondition)中不存在, 或者值和value不一致的时候 将target设置为false
```js
{
  "centerCode":"Center-GA-001",
  "workPlanDate":"2023-10-24",
  "workEndDate":"2023-12-11",
  "workEndTime":"04:36"
}
```

3. 如果 target 为false, 则做如下部分的初始化处理, 并且return掉
  1. this.searchTarget 设置为false, 表示 不是检索对象
  2. this.mergedCondition 设置为 {}
  3. chartData 设置为初始值
  4. 重新 initChart
  5. loading 设置为false

4. 如果 target 为true, 则将 父组件修改后的 searchCondition 和 子组件固有的检索条件对象 合并
```js
this.mergedCondition = {
  ...this.configCondition,
  ...addCondition
}
```

5. 在发送请求前 设置loading = true, 响应回来后设置loading = false

6. 拿到 mergedCondition 发送 search请求
  - 如果有res.data 则将 this.searchTarget 设置为 true
  - 如果没有res.data 则将 this.searchTarget 设置为 false
```js
"data": {
  "planWorker": 0.0,
  "resultCount": 0,
  "totalRatio": 0,
  "resultWorker": 0,
  "warning": "none",
  "targetRatio": 0,
  "endTime": "--:--",
  "totalCount": 0,
  "targetCount": 0

  "planWorker": 0.0,
  "resultCount": 24,
  "totalRatio": 20,
  "resultWorker": 0,
  "warning": "occurred",
  "targetRatio": 20,
  "endTime": "--:--",
  "totalCount": 118,
  "targetCount": 118
}
```

7. 请求成功后调用 setDisData 方法 展示chart的数据

<br>

### setDispData
1. 调用 this.getInitialChartData() 获取初始化的 newData
2. 使用 res.data 非 newData 进行赋值

3. 加工 endTime 字段
  - 如果响应中有 endTime 且 endTime 是e开头的, 则去掉e 并设置一种 title (作業終了)
  - 如果响应中有 endTime 且 endTime 不是e开头的, 则设置另一种 title (終了予定時刻)

4. 加工 字号
5. 设置 颜色 和 错误文字的要暗色
6. 计算 chart 所使用的数值
7. setOption
8. 将 newData 交给 this.chartData 供模版中的其它位置使用

<br><br>

## ProgressSummaryDashboardCenter

### beforeRouteLeave
每次离开该组件的时候 关闭两个 setTimeout

<br>

### computed
selectedCenterCode 关联的centerCode的下拉框, 当值发生变化的时候 会重新调用 onChangeCenter

<br>

### watch::searchForm
当searchForm发生变化的时候 会将 autoReSearch 只为 false, 该变量大概是用于当检索条件发生变化的时候, 自动再检索会停止

<br>

### watch:route
这段逻辑 理论上来说是不会执行的, 因为该组件在 router-view 出口里面, 当url变化的时候 该组件会重新挂载和加载

这时watch的逻辑每次都会重新创建, 而watch第一次不会执行 所以这段逻辑理论上来说是不会执行的

1. 从 to 的url上获取如下的对象
```js
{
  autoPlayId: '',
  centerCode: '',
  displayOrder: ''
}
```

2. 从 from 的url上获取如下的对象
```js
{
  autoPlayId: '',
  centerCode: '',
  displayOrder: ''
}
```

3. 判断
  - 如果要去的页面的url上没有 autoPlayId 而 当前页面url上有 autoPlayId 做 initInfo 处理
  - 如果要去的url 和 当前的 url 一致的话, 同时要去的url上有 autoPlayId 做 initInfo 处理

  - initInfo 就是 mounted 中调用的 初始化逻辑

<br>

### mounted
调用了 initInfo 逻辑

<br>

### methods: initInfo
1. 从 当前页面的url 上获取如下的对象 并保存到 this.autoPlayQueryParams
```js
{
  autoPlayId: '',
  centerCode: '',
  displayOrder: ''
}
```

2. 将 isShowAutoPlayButtonArea 变量设置为 false, 隐藏自动播放区域的按钮 但是如果 autoPlayQueryParams 中有 autoPlayId 的话 那么就将其设置为 true

3. 将 isShowNormalButtonArea 的值 设置为 !isShowAutoPlayButtonArea 也就是说这两个区域是互斥的

4. 设置chart的theme 获取到 this.colorTheme 对象

5. 调用 getUserCenterList 拿到 centerCode 下拉框的数据 将其保存到 **this.centers** 中, 然后根据数组中的元素项中的 currentCenterFlag 找到当前的选择的centerCode, 将第一次加载时候选择的centerCode保存在**this.workCenterCode**中

6. 调用了 onChangeCenter

<br>

### methods: onChangeCenter
该方法中调用了 
- getInit api
- searchDate 中也是调用 getInit api

<br>

**onChangeCenter有两个参数**
- newCenterCode
- afterSearch: true

<br>

**该方法会在如下的时机被调用**
1. 当我们在下拉框中选择了新的centerCode的时候
2. initInfo的最后 使用第一次加载页面用户当前的centerCode 调用了onChangeCenter
3. 在点击 清除 按钮的时候 使用第一次加载页面用户当前的centerCode 调用了onChangeCenter

<br>

**逻辑:**  
1. 将将传入的 newCenterCode 保存到 this.searchForm.centerCode 中
2. 将 chartDatas 清空 this.chartDatas = []
3. 整理出 getInit 请求的 参数, 拿到响应
```js
{
  autoPlayId: '',
  centerCode: '',
  displayOrder: ''
}


// 响应
{
  workEndDatetime: {
    "localDateTime": "2023-12-11T07:09:23.955098",
    "date": "2023-12-11",
    "time": "07:09"
  },
  workPlanDate: {
    "localDateTime": "2023-12-11T07:09:23.955098",
    "date": "2023-12-11",
    "time": "07:09"
  }
  autoPlayConditions: "",
  messageList: {
    "ui_common_center_code": "センターコード",
    "ui_common_work_class1": "作業分類１",
    ...
  },
  pulldownCenter: [
    ["ピック", "荷主A", "シングル",  "GTP", ... ],
    ...
  ],
  workPlacePullDownData: {
    workPlaceClass2-6: ["南棟", "場所2テ", "北棟", ...],
    workClass1-6: [ ... ]
  },
  conditions: {
    "search_interval": "60s",
    "search_auto": "1",
    "show_work_class1": "0",
    "show_work_class2": "0",
    "show_work_class3": "0",
    "show_work_class4": "0",
    "show_work_class5": "0",
    "show_work_class6": "0",
    "show_work_place_class2": "0"
    "show_work_place_class3": "0",
    "show_work_place_class4": "0",
    "show_work_place_class5": "0",
    "show_work_place_class6": "0",
  },

  autoPlayData: {
    "autoPlayId": null,
    "workPlanDate": null,
    "workPlanDateSetName": null,
    "offSetBusinessDate": null,
    "workEndDate": null,
    "centerCode": null,
    "centerName": null,
    "workPlaceClass2": null,
    "workPlaceClass3": null,
    "workPlaceClass4": null,
    "workPlaceClass5": null,
    "workPlaceClass6": null,
    "workClass1": null,
    "workClass2": null,
    "workClass3": null,
    "workClass4": null,
    "workClass5": null,
    "workClass6": null,
    "carryforwardKind": null,
    "carryforwardKindName": null,
    "refreshInterval": null,
    "switchingInterval": null,
    "nextDisplayOrder": null,
    "nextMenuRoutePath": null
  },

  componentInfos: [
    {
      "component_type": "Circular01",
      "show_estimated_end_time": "1",
      "sortKey": "1",
      "transition_value": "summaryDashboardByFloor",
      "component_width": "3",
      "transition_type": "1",
      "condition_work_class1": "入荷",
      "chartTypeNo": "1",
      "show_worker": "0",
      "title": "入荷",
      "key": "Center-GA-001_1",
      "chartTypeName": ""
    } x 4
  ]
}
```

4. 拿到响应后 为 searchForm 进行赋值
5. 拿到响应后 为 searchPrevForm 进行赋值

6. 清空 errorMsg
7. 为表单labels赋值 使用 res.messageList
8. 为表单是否展示的boolean对象进行赋值
9. 初始化下拉框过滤相关的功能
```js
// 作業場所・分類リストの初期化
this.centerWorkPlaceAll = res.pulldownCenter

// 作業場所・作業分類プルダウンデータ
this.workPlacePullDownData = res.workPlacePullDownData
```

10. 每次 onChangeCenter 的时候 会调用 this.getComponentConfig(res.componentInfos) 将componentInfos响应加工后放到 **this.chartDatas** 中
```js
{
  config: {
    // 这个部分就是 componentInfos 的 item
    "component_type": "Circular01",
    "show_estimated_end_time": "1",
    "sortKey": "1",
    "transition_value": "summaryDashboardByFloor",
    "component_width": "3",
    "transition_type": "1",
    "condition_work_class1": "入荷",
    "chartTypeNo": "1",
    "show_worker": "0",
    "title": "入荷",
    "key": "Center-GA-001_1",
    "chartTypeName": "",
    colorTheme: { ... }
  },

  // 表单中有值的项  onChangeCenter的时候 该属性是一个空对象
  "searchCondition": {
    "centerCode": "Center-GA-001",
    "workPlanDate": "2023-10-24",
    "workEndDate": "2023-12-11",
    "workEndTime": "07:16"
  },
  "loading": false,
  "show": true
}
```

11. 自动检索设定
  1. this.autoSearch 的值 跟如下的两个条件有关
    1. res.conditions.search_auto === '1'
    2. isShowAutoPlayButtonArea 为 true 的时候

    - **autoReSearch被修改的时机**: 这个值在watch searchForm 发生变化 和 onChangeCenter 的时候 被修改为false 在searchData的时候被修改为true

    - **autoReSearch的作用**: 搜索后，下次是否自动再搜索

  2. 将 this.autoReSearch = false

  3. 如果展示的是 自动播放按钮的区域要做如下的逻辑
    - 调用 reflectWorkPlaceProperties 方法将返回结果放到 this.searchForm 中
    - reflectWorkPlaceProperties方法中做了什么?
      - 根据 searchFormShow 看看哪个下拉框处于展示状态 如果处于展示状态 并且 该key在autoplayData中还是有值的, 则将autoplayData中的值放到searchForm中

    - 整理 autoPlaySendQueryParams 对象
    ```js
    this.autoPlaySendQueryParams.autoPlayId = this.autoPlayQueryParams.autoPlayId
    this.autoPlaySendQueryParams.centerCode = this.autoPlayQueryParams.centerCode
    this.autoPlaySendQueryParams.displayOrder = res.autoPlayData.nextDisplayOrder
    this.autoPlaySendQueryParams.nextMenuRoutePath = res.autoPlayData.nextMenuRoutePath
    ```

    - 将 res.autoPlayConditions 赋值给 this.autoPlayConditions

  4. 如果 afterSearch 和 this.autoSearch 都为true 则再次的执行 this.searchData()

  5. 当展示的是自动播放区域的时候 就调用 this.autoPlayExec()

12. 设置 filter 功能 this.initWorkPlaces()

<br>

### searchData
1. 进行表单区域的验证

2. 如果 chartDatas 中有一项的loading为true的时候 则return掉

3. 调用 this.getComponentSearchData() 加工数据 将返回的结果交给 this.chartDatas
  - 将searchForm中有值部分组织成一个对象放到 searchCondition 中
  - 也就是说 调用该方法后 chartDatas 中只有 config 和 searchCondition 了

4. 清除上一次的定时器
5. 将 autoReSearch 设置为 true 也就是说检索后再次的检索
6. 在延迟定时器中做了如下的逻辑
  - 如果 autoReSearch 为 true 则接着判断 searchForm 和 searchPrevForm 中的 workPlanDate', 'workEndDate', 'workEndTime 三个字段的值是否相等 如果相等 则发起 getInit 请求 

  - 请求回来后 再次的更新 searchForm 和 searchPrevForm 中的时间字段

  - 递归调用 searchData

<br>

### chartOnLoad
这个回调是在子组件发情 search api 请求前后 都会被触发

它有两个参数
1. param: { loading: newValue, searchTarget: this.searchTarget }
2. index: 第几个组件的下标

如果 chartDatas[index] 有值的话, 那就将它当中的 loading设置为子组件传递回来的值

然后拿到该 chartDatas[index] show 的属性 放入到 bfShow (原始值)

然后我们修改 this.chartDatas[index].show 的值 它的值为动态决定的, 它是否展示 是根据 子组件传递回的searchTarget 或者是 this.showNoTargetChart 的值决定

如果 原始值 bfShow 和 修改后的值不等, 则使用如下的格式更新 this.chartDatas[index]
```js
if (bfShow !== this.chartDatas[index].show) {
  const item = this.chartDatas[index]
  this.$set(this.chartDatas, index, item)
}
```

### 动作确认
1. mounted 
2. initInfo 
3. onChangeCenter 
4. 父组件: searchData - 自动检索
  - 子组件 watch:searchCondition
    - 子组件: searchData

onChangeCenter在整理 this.chartDatas 的时候, 它的值时候 整理出来的对象是
```js
{
  config: { 有值 }
  loading: false
  searchCondition: { 空对象 }
  show: true
}
```

所以子组件第一次接收到的 searchCondition 的值 就是 {}

子组件监听的是 父组件传递到子组件的 searchCondition searchCondition也是 chartDatas 当中的 searchCondition

只有父组件在执行完 searchData 之后 searchCondition 才会有值 是么

