# 为什么需要虚拟DOM
无论是vue和react它们的官网中没有任何一个词说了 虚拟DOM是用来提升效率的 

因为虚拟DOM不仅没有提升效率 它反而会拖累效率, 我们可能想 难道有了虚拟DOM之后就不需要真实的DOM了么

Vue也好还是React也好它最终要导致页面发生变化 它必须要操作真是DOM 它直接操作真是的DOM不就完事了么

为什么还要在中间搞一个虚拟DOM呢? 为什么还要绕一圈呢? 因为你会发现绕了一圈之后还要操作DOM

<br>

### 虚拟DOM出现的真正原因
我们从两个层面说这个问题

<br>

**1. 框架设计层面**  
vue 和 react 它们的框架设计理念是基于数据驱动的 就是说以数据为中心 我更改了数据 界面要自动变

问题就来了 一个组件可能牵扯到100个DOM元素 我改动了组件的某一个数据 那这100个元素里面哪个元素有变化 它搞不清楚

实际上从逻辑上来讲的话 是能搞清楚的 但是框架要搞清楚这一点是非常困难的 困难的话就暴力一些

因此vue也好还是react也好 它们都有一个render函数 这个函数的作用就是数据一旦变化 我就要全量的生成界面

这个组件的界面上可能有100个元素 我这个数据发生变化 可能只影响到其中的一个元素 但是由于这些框架不知道 那就把这个组件全部的渲染一遍

由于它是这样去设计的 就导致了如果在这里面使用真实DOM的话(真实DOM操作很昂贵) 因此就会严重的拖累效率 它没有办法逼到后来实在没有办法了 所以在render函数中 折个中 

我既然是全量生成界面 那我就不生成真实DOM了 我生成虚拟dom 这是一个妥协的结果 生成虚拟DOM后 就是100对象 跟之前的100个对象进行对比 一对比过后就可以发现到底是哪个东西变了 然后把变的这个东西 再去操作变的这个东西的真实DOM 这样稍微要好一些

而svelte就不是这样, 详见问题2

在基于这种框架的设计下 效率已经很低了 没有办法 因此来搞出来的一个虚拟DOM 缓解下效率低下的问题

原生要比框架的效率要高, 如果可以直接操作真实DOM就可以了

<br>

**2. 跨平台的原因**  
现在的前端框架 不仅仅能在浏览器里面使用 它也可以在小程序中使用 或者移动端 或者桌面端进行使用 

因此它是一个抽象层 它不能去绑定具体的界面的 我们说的真实DOM指的是什么? 浏览器环境才有真实DOM 一旦脱离了这个环境 那就要打上一个问号了

所以它不能跟真实DOM直接绑定 因此它搞了一个所有环境都能够认识的虚拟DOM 因为虚拟DOM就是一个普通的对象 根据不同的环境 去使用这个虚拟DOM 渲染出界面

这样就可以实现一套代码在多端运行了 这是跨平台的需要

<br>

### 总结
基于上述的两个原因 才出现了虚拟DOM 而不是简单的一句提高了效率 它提高了什么效率?

<br>

### 问题:
如果虚拟DOM能够提升效率, 那么React Fiber在干什么?

React Fiber出现的动机就是来解决虚拟DOM的问题的, React中虚拟DOM的效率问题要比Vue中严重的多 所以Vue不需要这个Fiber 而React是需要的

React 之前的版本使用了递归调用的方式来处理组件的渲染和调度，这可能导致一些性能问题，尤其是在大型应用中。

React Fiber 的目标是通过引入一套新的调度算法，将递归调用改为可中断的、分阶段的执行，从而提高 React 应用的性能和用户体验。这并不是直接与虚拟 DOM 的效率有关，而是与 React 的整体渲染流程和调度机制有关。

关于虚拟 DOM，React 使用虚拟 DOM 的目的是为了更高效地更新 DOM。虚拟 DOM 本身并不是 React Fiber 的主要目标，而是 React 使用的一种优化手段。虚拟 DOM 可以帮助 React 在更新时进行局部更新，而不是直接操作真实的 DOM。

React Fiber 的引入是为了提高 React 应用的渲染性能和响应性，而不是直接解决虚拟 DOM 效率问题。

<br>

### 问题2:
虚拟DOM能够提升效率 Svelte 它没有虚拟DOM 为什么它的效率更高呢?

svelte是编译形态的 它在编译的期间 就能知道我这个数据对应哪个真实的DOM, 我直接去改它对应的真实DOM就可以了

它就不会绕上面的一大圈 所以它的效率非常高

在 Svelte 中，组件的代码在构建时会被编译成高效的 JavaScript 代码，这个编译过程将模板、样式和逻辑都整合在一起。这种编译时的特性使得 Svelte 在运行时几乎没有框架本身的代码。相反，生成的代码更直接地操作 DOM 元素

具体来说，Svelte 的编译器会分析组件中的模板，识别出组件的状态变化以及与 DOM 元素的关联。然后，编译器生成的代码会直接操作 DOM，而不需要虚拟 DOM 的中间层。这种直接的关联使得 Svelte 能够在编译时确定哪个数据对应哪个 DOM 元素，而不需要在运行时进行全量的虚拟 DOM 对比。

<br>

**编译时操作：**
svelte 在组件构建时进行编译，生成的代码直接包含了与 DOM 直接交互的逻辑。

<br>

**无虚拟 DOM：**   
Svelte 不使用虚拟 DOM，而是在编译时就确定了组件状态变化对应的 DOM 操作。

<br>

**直接操作 DOM：**  
由于编译时已知数据和 DOM 元素的关系，Svelte 生成的代码可以直接操作 DOM，而不需要进行全量的虚拟 DOM 对比。

<br>

这使得 Svelte 具有很高的性能，因为它避免了运行时进行复杂的虚拟 DOM 操作，而在编译时已经确定了数据和 DOM 元素之间的映射关系。

