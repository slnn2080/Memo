{"version":3,"file":"vue.js","sources":["../src/compiler/parse.js","../src/compiler/index.js","../src/global.js","../src/observe/dep.js","../src/observe/watcher.js","../src/vdom/index.js","../src/vdom/patch.js","../src/lifecycle.js","../src/observe/array.js","../src/observe/index.js","../src/state.js","../src/init.js","../src/index.js"],"sourcesContent":["const ncname = `[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z]*`\nconst qnameCapture = `((?:${ncname}\\\\:)?${ncname})`\n\n/*\n  /^<((?:[a-zA-Z_][\\-\\.0-9_a-zA-Z]*\\:)?[a-zA-Z_][\\-\\.0-9_a-zA-Z]*)/\n  匹配开始标签名 情况有两种\n  1. <xxx\n  2. <div:xxx   标签带命名空间的情况\n*/\nconst startTagOpen = new RegExp(`^<${qnameCapture}`)\n\n\n/*\n  /^<\\/((?:[a-zA-Z_][\\-\\.0-9_a-zA-Z]*\\:)?[a-zA-Z_][\\-\\.0-9_a-zA-Z]*)[^>]*>/\n  匹配结束标签名\n  1. </xxx>\n*/\nconst endTag = new RegExp(`^<\\\\/${qnameCapture}[^>]*>`)\n\n\n/*\n  匹配属性 的正则\n  正则中\n    分组1: 属性的key\n    分组3 或者 分组4 或者 分组5: 属性的value\n     \"\"        ''     没有引号\n*/\n// \n// \nconst attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/\n\n // 匹配标签结束的  > or />\nconst startTagClose = /^\\s*(\\/?)>/\n\n// 解析 html 的模块: htmlparser2\n\n// 胡子语法的正则 {{分组1}} 分组1就是表达式的变量\nconst defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g\n\n// -----------------------\n\nexport function parseHTML(html) {\n\n  // 元素类型\n  const ELEMENT_TYPE = 1\n\n  // 文本类型\n  const TEXT_TYPE = 3\n\n  // 用于存放元素的\n  const stack = []\n\n  // 指向栈顶的元素的指针 栈顶元素都是当前匹配到元素的父亲 所以我们的变量名也这么起\n  let cuurentParent = null\n\n  // 根节点 它也是最后的 ast 语法树\n  let root = null\n\n  // 整理 AST树中的节点对象\n  function createASTElement(tag, attrs) {\n    return {\n      tag,\n      attrs,\n      type: ELEMENT_TYPE,\n      parent: null,\n      // 在解析开始标签的时候并不知道孩子是谁 先给个空\n      children: []\n    }\n  }\n\n  // 利用 栈结构的特性 构建了一棵树(弹幕说遇到单标签就有问题了)\n  // 进栈构建父子关系 出栈就把当前作为栈顶的儿子\n\n  // 处理开始标签\n  function handleStart(tag, attrs) {\n    // 将零散的开始标签 组织成树节点\n    let node = createASTElement(tag, attrs)\n\n    // 如果没有根节点该节点本身就是根节点\n    if(!root) {\n      root = node\n    }\n\n    // 如果栈顶有值 则让 当前节点的爸爸为 栈顶元素\n    if(cuurentParent) {\n      node.parent = cuurentParent\n\n      // 给栈顶元素添加儿子(当前元素)\n      cuurentParent.children.push(node)\n    }\n\n    stack.push(node)\n\n    // 让当前这个节点指向栈顶元素\n    cuurentParent = node\n  }\n\n\n  // 处理文本\n  function handleText(txt) {\n\n    txt = txt.replace(/\\s/g, \"\")\n\n    // 如果文本有值的 我们再插入 文本是当前栈顶元素的孩子\n    txt && cuurentParent.children.push({\n      // 文本节点的类型是文本\n      type: TEXT_TYPE,\n      // 文本内容\n      text: txt,\n      // 文本节点的父节点也是栈顶元素\n      parent: cuurentParent\n    })\n  }\n\n  // 处理结束标签\n  function handleEnd(tag) {\n    // 遇到结束标签的时候 将栈顶元素弹出栈 并更新 cuurentParent\n    stack.pop()\n    // 更新cuurentParent\n    cuurentParent = stack[stack.length - 1]\n  }\n\n\n  // 将匹配的内容删除(也可以理解为截取目标字符串的指定长度)\n  function advance(len) {\n    html = html.substring(len)\n  }\n\n  // 解析开始标签的方法\n  function parseStartTag() {\n\n    // 使用 正则startTagOpen 看看是不是开始标签\n    const start = html.match(startTagOpen)\n\n    // console.log(\"start标签: \", start)\n    /*\n      start为数组[0, 1, {}]\n\n      0: \"<div\"\n      1: \"div\"\n      groups: undefined\n      index: 0\n      input: \"<div id=\\\"app\\\">\\n    <div style=\\\"color: red;\\\">{{name}} -- hello</div>\\n    <span>{{age}}</span>\\n  </div>\"\n      length: 2\n\n      0: 匹配的内容\n      1: 分组内容: 标签名\n    */\n\n    if(start) {\n      // 如果是开始标签的话 则将结果组织成一个对象\n      const match = {\n        // 标签名\n        tagName: start[1],\n        // 标签属性\n        attrs: []\n      }\n\n      // console.log(match)\n      /*\n        {\n          attrs: []\n          tagName: \"div\"\n        }\n      */\n\n      \n      // 当匹配到内容(如开始标签) 要将该部分内容删除 advance前进的意思 那前进多少呢 就是匹配内容的总长度\n      advance(start[0].length)\n      // console.log(html)\n      /*\n        html现在的内容为: \n          id=\"app\">\n          <div style=\"color: red;\">{{name}} -- hello</div>\n          <span>{{age}}</span>\n        </div>\n      */\n\n\n      /*\n        接下来开始匹配属性 我们需要不停的用正则匹配属性 \n        我们要循环匹配 只要不是开始标签的结束(正则: startTagClose) 就一直来匹配\n      */\n      // 如果不是开始标签的结束则一直匹配 同时每次匹配的时候我们还需要将属性保留起来\n      let attr;\n\n      // 开始标签的结束 >\n      let end;\n\n      while(!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n        // 每次匹配到结果 我们继续删掉匹配到的内容 也就是调用 advance() 方法\n        advance(attr[0].length)\n\n        // 将 标签属性 整理到 match.attrs 中\n        match.attrs.push({\n          name: attr[1],\n          // 如果是 disable 的情况 可以直接给个true\n          value: attr[3] || attr[4] || attr[5] || true\n        })\n      }\n\n      // console.log(\"标签属性: \", attr)\n      /*\n        0: \" id=\\\"app\\\"\"\n        // key\n        1: \"id\"\n        2: \"=\"\n\n        // 3 | 4 | 5 为value\n        3: \"app\"\n        4: undefined\n        5: undefined\n      */\n\n      // console.log(html)\n      /*\n        >\n          <div style=\"color: red;\">{{name}} -- hello</div>\n          <span>{{age}}</span>\n        </div>\n      */\n\n      // 上面我们发现还有一个 开始标签的 > 结束 我们也应该把它也删掉 它被我们保存到 end 变量中了\n      if(end) advance(end[0].length)\n      // ↑\n      // 到上面这里 开始标签整体的处理完毕\n      \n      // match是开始标签对象\n      // console.log(\"开始标签对象:\", match)\n      /*\n        match: {\n          tagName: \"div\",\n          attr: [\n            {\n              name: id,\n              value: app\n            }\n          ]\n        }\n      */\n      return match\n    }\n\n\n    // 不是开始标签则return false\n    return false\n  }\n\n\n  /*\n    // 我们的html字符串是这样的\n    <div id=\"app\">\n      <div style=\"color: red;\">{{name}} -- hello</div>\n      <span>{{age}}</span>\n    </div>\n    \n    逻辑: 每解析一个部分我们就从html字符串中把这个部分删除掉 当字符串都被截取完毕 就停止解析\n    示例: \n      解析开始标签 <div \n          就从上面的html字符串中删掉该部分\n      解析属性 id=\"app\"\n          就从上面的html字符串中删掉该部分\n\n      最后都没有了就结束了\n\n    特点: \n      html最开始肯定是一个 <\n\n    示例:\n      0\n      ↓\n      <div>html</div>\n\n      html.indexOf(\"<\") 索引为0 肯定是标签 \n      当我们解析完开始标签的时候 删除开始标签 变成\n\n          ↓\n      html</div>\n\n      那我们再去取 < 在html字符串中的位置时 那 < 的位置是不是就是文本结束的位置\n  */\n\n  // 使用循环解析html字符串 当字符串为空退出循环\n  while(html) {\n\n    // 如果 < 的查询结果为0 说明是标签\n    // textEnd如果=0 则说明是开始标签 >0 则说明是文本结束的位置\n    let textEnd = html.indexOf(\"<\")\n\n    // 这种情况下为开始标签\n    if(textEnd == 0) {\n\n      // parseStartTag()解析开始标签的方法, 返回值为开始标签的解析结果\n      const startTagMatch = parseStartTag()\n\n      // console.log(html)\n      /*\n        <这部分的处理完了>\n          <div style=\"color: red;\">{{name}} -- hello</div>\n          <span>{{age}}</span>\n        </div>\n\n        处理完这个部分后 下面这行可能还是开始标签 还是属性\n        <div style=\"color: red;\">\n\n        但是总有一天都会被截掉 该遇到文本了 这时候 textEnd > 0\n      */\n\n      // 如果 startTagMatch 有值 就直接跳过本轮的操作\n      if(startTagMatch) {\n\n        // 拿到开始标签的内容后 我们交给 handleStart() 来进行处理\n        handleStart(startTagMatch.tagName, startTagMatch.attrs)\n        continue\n      }\n\n      // 到这 就是如果不是开始标签 就是结束标签 返回当前结束标签的名字 endTagMatch为匹配到的结束标签\n      let endTagMatch = html.match(endTag)\n      // console.log(\"endTagMatch\", endTagMatch)\n\n      // 直接是 结束标签 的原因 <div></div> 的情况\n      // 结束标签不用处理直接删除就可以\n      if(endTagMatch) {\n        // console.log(\"endTagMatch\", endTagMatch)\n        advance(endTagMatch[0].length)\n\n        // 拿到 结束标签后 我们交给 handleEnd() 来处理\n        handleEnd(endTagMatch[1])\n        continue\n      }\n    }\n\n    // 到标签文本的位置了 我们就需要将文本获取到 找到文本将文本提取出来\n    if(textEnd > 0) {\n\n      // 文本内容\n      let text = html.substring(0, textEnd)\n      // console.log(\"标签文本的内容\", text)\n\n      // 同时 我们匹配了文本的内容后也要删掉这个部分\n      if(text) {\n        // 拿到标签文本后 交给 handleText来处理\n        handleText(text)\n        advance(text.length)\n      }\n      // console.log(html)\n    }\n  }\n\n  // 看看html是否为空\n  // console.log(\"html\", html)\n\n  /*\n    上面的部分的整体流程文字叙述:\n    <div id=\"app\">\n      <div style=\"color: red;\">{{name}} -- hello</div>\n      <span>{{age}}</span>\n    </div>\n\n    while(html) 中的 html 是 整个模板内容\n    第一次:\n      textEnd == 0\n      parseStartTag()方法中是根据开始标签的正则来进行匹配\n      所以能匹配到开始标签\n      startTagMatch有值 然后 continue\n      直接开始下一轮循环\n\n    第二次:\n      textEnd > 0 \n      提取文本内容 本次提取的文本内容是空格加换行\n      然后删掉该部分 进入下一轮循环\n\n    第三次:\n      <div style=\"color: red;\">{{name}} -- hello</div>\n        <span>{{age}}</span>\n      </div>\n      第三次进来的时候html这样\n      textEnd == 0\n      parseStartTag()方法中是根据开始标签的正则来进行匹配\n      匹配到 <div style=\"color: red;\">\n      startTagMatch有值 然后 continue\n      直接开始下一轮循环\n\n    第四次:\n      textEnd > 0 \n      提取文本内容 本次提取的文本内容是空格加换行\n      然后删掉该部分 进入下一轮循环\n\n    第五次:\n      </div>\n        <span>{{age}}</span>\n      </div>\n      遇到了结束标签\n      textEnd == 0\n      parseStartTag()方法中是根据开始标签的正则来进行匹配\n      没有匹配到 所以走了 \n      if(endTagMatch) {\n        advance(endTagMatch[0].length)\n        continue\n      }\n      删除结束标签 然后继续开始下一轮循环\n\n\n    也就是说整体的逻辑是删除一个部分重新一轮\n  */\n\n\n  /*\n    最终我们要根据 开始 文本 结束 这三个部分转化为一个抽象语法树\n    树结果的话 肯定会有层级关系 比如谁是父亲 谁是孩子\n\n    大体我们应该组织的结构是这样的\n    {\n      tag: \"div\",\n      // 元素的类型 取元素的 nodeType 我们这里主要有两种类型 一类是文本 一类是元素\n      type: 1,\n      attrs: [{}],\n      // 父元素,\n      parent: null(根元素是null),\n      // 儿子的数组里面还可能会再套一层\n      chlidren: [{}]\n    }\n\n    我们需要根据 上面整理好的另算数据解析成一棵树 那零散数据怎么构建父子关系呢\n    <div id=\"app\">\n      <div style=\"color: red;\">{{name}} -- hello</div>\n      <span>{{age}}</span>\n    </div>\n\n    我们可以整一个栈型结构\n      当我们匹配到 开始标签的时候 我们将 div 推进栈 之后当我们匹配到下一个 div 的时候\n      我们就知道 第二个div 是栈顶div的儿子(数组中的最后一个)\n\n    当遇到结束标签的时候 我们把栈顶的元素 弹出栈\n    [第一个div, 第二个div]\n    第二个div(栈顶)是第一个div的孩子 当遇到结束标签</div> 的时候 我们将栈顶的元素弹出栈\n\n    当再遇到开始标签(span)的时候 我们就知道 span 的爸爸是 栈顶的元素\n    [第一个div, span]\n\n    依次类推 栈顶元素是当前匹配到元素的父亲\n\n    也就是说我们可以根据栈来模拟出来树形关系\n  */\n\n  // 将最终生成的 ast语法树 返回\n  return root\n  // console.dir(root, {depth: null})\n\n} ","import { parseHTML } from \"./parse\";\n\n// 对获取的template内容进行编译\nexport function compileToFunction(template) {\n  // debugger\n  // 1. 将 template 转化成 ast 语法树\n  let ast = parseHTML(template)\n  // console.log(ast)\n\n  // 2. 生成 render 方法 (render方法执行的返回的结果就是 虚拟DOM)\n  let code = codegen(ast)\n  // console.log(code)\n\n  code = `with(this){return ${code}}`\n  let render = new Function(code)\n  // console.log(\"render: \", render.toString())\n\n  // 将render函数暴露出去\n  return render\n}\n\n\n// codegen 将树拼装成 render代码\nfunction codegen(ast) {\n\n  // code就是最终要生成的东西\n  let code\n\n  // 生成 render 函数 孩子参数的部分\n  let children = genChildren(ast.children)\n\n  // 开始拼接成 render函数的返回值 _c(\"div\" ... )\n  code = `_c('${ast.tag}', ${ast.attrs.length > 0 ? genProps(ast.attrs): null}${ast.children ? `,${children}` : \"\"})`\n\n  // console.log(code)\n  return code\n}\n\n// 处理 child 的函数\nconst defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g\nfunction gen(node) {\n  /*\n    child 就是一个个的node节点 \n    然后我们需要判断下 看看该节点是文本还是元素\n\n    如果是文本的话 我们需要创建文本\n    如果是元素的话 就生成元素\n  */\n  // 元素\n  if(node.type == 1) {\n    return codegen(node)\n\n  // 文本 文本有几种情况 标签里面是纯文本 或者是{{age}} 或者是{{name}}hello\n  } else {\n    let text = node.text\n    \n    if(!defaultTagRE.test(text)) {\n      /*\n        text:  world\n        普通字符串的情况下 我们使用 _v() 包裹\n\n        _v(\"text\")\n      */\n      return `_v(${JSON.stringify(text)})`\n\n    } else {\n      /*\n        text: {{name}}hello{{name}}\n        当遇到这种特殊字符串的时候 我们要将 变量使用 _s() 包裹起来\n        然后整体使用 _v() 包裹\n\n        _v( _s(name) + 'hello' + _s(name))\n\n        在转的时候我们需要将这3部分组织好 然后使用 + 来进行拼接\n        // c: 创建元素 v: 创建文本 s:json.stringify()\n      */\n\n      /*\n        用于存放 文本内容 如\n        {{name}}hello{{name}}\n\n        _s(name) hello _s(age)\n      */\n      let tokens = []\n\n      // 根据 defaultTagRE 正则 匹配到的结果\n      let match = null\n\n      /*\n        defaultTagRE 正则使用的是 exec() 同时 正则里面加上了g\n        这是我们就要考虑 lastIndex 的问题\n        这里设置为0 这样每次调用 gen() 方法的时候 会从0重新开始\n      */\n      defaultTagRE.lastIndex = 0\n\n      /*\n        最后匹配到的位置\n        下面的循环是根据 {{}} 正则来找对应的胡子里面的内容\n\n        但是 胡子之外的内容我们也要拿到 比如 hello 所以我们要记录下 最后匹配的位置 \n        方便我们截取 hello 的部分\n\n        每次循环的时候 我们要记录 lastIndex \n        比如:\n\n        index         index\n          0            13\n          ↓            ↓\n          {{name}}hello{{name}}\n                 ↑\n                 8\n             lastIndex\n\n        这样我们就能根据索引 找到hello文本\n      */\n      let lastIndex = 0\n\n      // 这个就是数据分割 循环 if 匹配不同的情况 放到数组中\n      // 我们使用 defaultTagRE 来捕获目标文本 将每次捕获的结果放入到 tokens 数组中\n      while(match = defaultTagRE.exec(text)) {\n        // console.log(match)\n        /*\n          match: [\n            0: \"{{age}}\"\n            1: \"age\"\n          ]\n        */\n        \n        // 拿到当前匹配的位置 拿到后往 tokens 数组中放\n        /*\n          0            13\n          ↓            ↓\n          {{name}}hello{{age}}\n        */\n        let index = match.index\n        // console.log(index) // 0 13\n\n        if(index > lastIndex) {\n          // lastIndex是上一次的位置 8 如果index > lastIndex 说明两个{{}} 之间有文本\n          // 那么 我们就 截取text字符串 从 lastIndex 位置 截取到 第二次index 13 之间的文本\n          tokens.push(JSON.stringify(text.slice(lastIndex, index)))\n        }\n\n\n        \n        // 放入匹配的内容 _s(name) 我们这么放到数组中\n        tokens.push(`_s(${match[1]})`)\n        \n        /*\n          第一次的时候 0 + 8 ({{name}}.length length是数个数 不是索引 所以从1开始数)\n          每次循环的时候保存下 lastIndex\n        */\n        lastIndex = index + match[0].length\n        // console.log(lastIndex) // 8 20\n      }\n\n      /*\n        {{name}} hello {{age}} 这还有文本的情况 我们将这个部分也放入 tokens 数组中\n                             ↑\n        因为lastIndex 记录的是 这个位置 如果 lastIndex < text.length 说明后面还有文本\n      */\n      if(lastIndex < text.length) {\n        tokens.push(JSON.stringify(text.slice(lastIndex)))\n      }\n      \n      // console.log(tokens.join(\"+\"))\n      // _s(name)+hello+_s(age)+world\n      // 标记\n      return `_v(${tokens.join('+')})`\n    }\n    \n  }\n\n}\n\n// 整理children的函数\nfunction genChildren(children) {\n  if(children) {\n    return children.map(child => gen(child)).join(\",\")\n  }\n}\n\n// 整理属性的函数\nfunction genProps(attrs) {\n  // console.log(\"attrs: \", attrs)\n  // 属性的格式: {name: value}\n  let str = \"\"\n  for(let i = 0; i < attrs.length; i++) {\n    let attr = attrs[i]\n\n    /*\n      我们也可以使用 qs 库\n\n      标签属性是 style 的情况下 我们要进行特殊处理\n      语法树中关于 style 的数据结构\n      {name: 'style', value: 'color: red; background: pink'}\n\n      转为\n      {color: \"red\", background: \"pink\"}\n    */\n    if(attr.name == \"style\") {\n      // 最终我们要整理成 style: {} 的像是 这个{}就是obj\n      // console.log(\"value:\", attr.value)\n      let obj = {}\n\n      // 根据 ; 拆分\n      attr.value.split(\";\").forEach(item => {\n        // 根据 : 拆分\n        let [key, value] = item.split(\":\")\n       \n          /*\n            style=\"background: pink;\n            当是上面的形式的时候 我们在 ; 分割的时候 后面会是 \"\": undefined\n            所以我们做下判断\n\n            {background: 'pink'}\n          */\n          if(key) {\n            key = key.trim()\n            value = value.trim()\n            obj[key] = value\n          }\n      })\n\n      attr.value = obj\n    }\n\n    // id: app, app的部分也要是字符串 我们使用 stringify()\n    str += `${attr.name}: ${JSON.stringify(attr.value)},`\n  }\n\n  // 不要 str 最后的 , 然后在 str 的外侧加上 {}\n  return `{${str.slice(0, -1)}}`\n\n  /*\n    _c(\n      'div', \n      {\n        id: \"app\",\n        style: {\"background\":\"pink\"}\n      }\n    )\n  */\n}\n \n","// 策略\n// 策略: 策略中的才会合并成一个数组\nconst strats = {}\nconst lifecycle = [\n  \"beforeCreate\",\n  \"created\"\n]\n\nlifecycle.forEach(lifecycleName => {\n  strats[lifecycleName] = function(p, n) {\n    // 第一次 Vue.options 是 {} 的\n    if(n) {\n      // 到这里还能进入if里面 说明 p有值 n有值 那么p肯定是一个数组\n      if(p) {\n        // p n都有的情况下 就将它们放在一个数组中\n        return p.concat(n)\n\n      // n有 但是p没有\n      } else {\n        // 将n包装成数组\n        return [n]\n      }\n\n    // 没有 n 的话 就没有意义的 p爱是啥是啥\n    } else {\n      // 如果儿子没有则用父亲即可\n      return p\n    }\n  }\n})\n\n\n// 工具函数 也可以提取到 utils 里面\nexport function mergeOptions(preOptions, newOptions) {\n  const options = {}\n\n  // 我们观察下 之前 和 新的 如果有相同属性的话合并在一起 不同属性的话以新的为准\n  for(let key in preOptions) {\n    mergeField(key)\n  }\n\n  for(let key in newOptions) {\n    // 所以这里我们合并 preOptions 没有的key 因为 preOptions 合并过了 这里就不用合并了\n    if(!preOptions.hasOwnProperty(key)) {\n      mergeField(key)\n    }\n  }\n\n\n  function mergeField(key) {\n    // 策略模式\n    // 如果 key 是策略中有的走策略 没有走默认\n    if(strats[key]) {\n      options[key] = strats[key](preOptions[key], newOptions[key])\n    } else {\n      // newOptions中的优先因为要以新的为准\n      options[key] = newOptions[key] || preOptions[key]\n    }\n  }\n\n  return options\n}\n\n\n\nexport function initGlobal(Vue) {\n\n  // 在 Vue 身上添加一个静态属性 options 和 静态方法 mixin\n  Vue.options = {}\n\n  // 参数: 用户在使用 mixin({}) 时候传进来的对象 \n  Vue.mixin = function(mixin) {\n\n    // !!这里的this是 Vue 本身\n\n    // 拿到 mixin 对象后 我们需要将 mixin对象 和 Vue.options 进行合并 产生一个新的对象\n    this.options = mergeOptions(this.options, mixin)\n    \n    // 为了链式调用\n    return this\n  }\n}\n","// 每一个属性都会有对应的一个 dep 用作依赖收集 所以dep也会有好多个\nlet id = 0\n\n// 属性的dep要收集watcher \nclass Dep {\n  constructor() {\n    this.id = id++\n\n    // 这里存放着当前属性对应的watcher有哪些 一个属性可能有多个watcher\n    this.subs = []\n  }\n\n\n  // 在调用 depend() 的时候 会先让watcher记住dep 因为调用的watcher的addDep方法 该方法内部是通过dep的实力调用addSub() 将watcher添加到subs数组中\n  depend() {\n    // this.subs.push(Dep.target)\n\n    // Dep.target是 watcher 我调用addDep()方法将这个Dep传过去 让Watcher也能记住dep\n    Dep.target.addDep(this)\n  }\n\n  addSub(watcher) {\n    // 将传过来的watcher放到subs数组中\n    this.subs.push(watcher)\n  }\n\n  notify() {\n    // 让自己身上存的所有watcher 让watcher做更新操作\n    this.subs.forEach(watcher => watcher.update())\n  }\n}\n\n// 静态属性: 静态属性只有一份 我们 import 导入 dep 文件的时候 它身上就有这个属性\nDep.target = null\n\n\n// watcher栈\nlet stack = []\n \n// 参数: 要传递进来 watcher \nexport function pushTarget(watcher) {\n  // 将传递进来的watcher 放到stack中\n  stack.push(watcher)\n\n  // 调用该方法会给 Dep.target 赋值\n  Dep.target = watcher\n}\n\n// 渲染结束后清空 Dep.target\nexport function popTarget() {\n  // 删掉栈顶的watcher\n  stack.pop()\n\n  // Dep.target = null 在没有其他类型的watcher时 stack[stack.length - 1]为undefined\n  Dep.target = stack[stack.length - 1]\n}\n\nexport default Dep","import Dep, { popTarget, pushTarget } from \"./dep\"\n\n// 每次创建 watcher 都给它一个唯一值\nlet id = 0\n\n// Watcher 里面有更新组件的方法 this.get()\nclass Wacher {\n  /**\n   * \n   * @param {*} vm 我们需要知道当前的watcher是哪个实例的\n   * @param {*} exprOrFn 实例(组件)对应的渲染函数 vm._update(vm._render()) 我觉得叫render更好\n   *      exprOrFn在计算属性中 是用户指定的get()回调\n   *      exprOrFn在watch中 是回调指定的要监视的值\n   * @param {*} options 布尔类型标识是一个渲染watcher\n   * @param {*} cb watch的回调 当属性变化时 执行的回调\n   */\n  constructor(vm, exprOrFn, options, cb) {\n    // 每次创建 实例 的时候 让id++ 这样每个watcher都有自己的id\n    this.id = id++\n\n    // 布尔类型: 标识是何种watcher\n    this.renderWatcher = options\n\n\n    // 如果我们传入的exprOrFn是字符串 那么我们要将字符串改成一个函数\n    if(typeof exprOrFn == \"string\") {\n      this.getter = function() {\n        // 从 vm 上获取要监视的属性 vm.firstname\n        return vm[exprOrFn]\n      }\n    } else {\n      // 函数\n      this.getter = exprOrFn\n    }\n    // 标识是否是 用户要写的 watch \n    this.user = options.user\n    \n    // 保存用户传入的 watch 回调\n    this.cb = cb\n\n    \n\n    // deps: 用来保存一个watcher对应了哪些dep 后续我们实现计算属性 和 一些清理工作的时候需要用到\n    this.deps = []\n    this.depsId = new Set()\n\n\n    // 拿到传入的lazy\n    this.lazy = options.lazy\n    // 计算属性会使用 dirty 作为缓存值 默认lazy为true dirty就为true\n    this.dirty = this.lazy\n\n    // this.lazy为true我们啥都不管 只有不为true的时候我们new Watcher的时候才调用更新组件的方法\n    // this.lazy ? undefined : this.get()\n\n    // 当 watch 的时候 我们 老值保存在 this.value 上\n    this.value = this.lazy ? undefined : this.get()\n\n    // 初渲染 先调用一次\n    // this.get()\n\n    this.vm = vm\n  }\n\n  // 计算属性 watcher 在如果是脏的情况下 需要调用的方法\n  evaluate() {\n    // 当计算属性watcher的时候 我们传入的fn会是 计算属性的get() get()会有返回值 我们将这个返回值绑定到实例身上\n    // 也就是绑定到了 watcher身上 计算属性的值如果不是脏的 就会使用watcher身上的 相当于缓存到 watcher身上了\n    this.value = this.get()\n\n    // 标识为脏\n    this.dirty = false\n  }\n\n  get() {\n    // 当我们创建渲染watcher的时候(页面渲染的时候) 我们会把当前的渲染watcher放到dep的target上\n \n    // 下面调用this.getter() == vm._update(vm._render()) 就会取值 取值的时候就会走到 defineReactive - getter 上\n    // Dep.target = this\n    // 我们通过下面的方法将 渲染watcher 放到 Dep.target 上 该方法内部维护了一个stack\n    pushTarget(this)\n\n    // vm._update(vm._render())还具有取值的功能 因为render的时候nameage这些变量都会从vm上取值 我们只要一调用该函数就会到 vm 上取值\n    // this.getter() 就是 return this.firstname + this.lastname 但是 watcher 类的this是watcher吧 我们要从vm身上取值吧\n    let value = this.getter.call(this.vm)\n\n    // 渲染完后清空\n    // Dep.target = null\n    // 用下面的方法进行 清空操作 把 stack中的watcher删掉\n    popTarget()\n\n\n    // 计算属性中需要拿到返回值 所以我们这样操作下\n    return value\n  }\n\n  // 一个组件对应着多个属性 重复的属性也不用记录 我们期望让watcher和dep是相互记忆的\n  addDep(dep) {\n    // 利用id去重\n    let id = dep.id\n\n    // 看看 depsId 有没有 该id\n    if(!this.depsId.has(id)) {\n      this.deps.push(dep)\n      this.depsId.add(id)\n\n      // 让 dep 把 watcher 也记住 将watcher(this)传过去 \n      dep.addSub(this)\n    }\n  }\n\n  // 修改模版中依赖的属性 会触发更新操作\n  update() {\n\n    // 更新前判断 如果是lazy说明是计算属性\n    if(this.lazy) {\n      // 依赖值发现变化了 标识计算属性是脏值\n      this.dirty = true\n    } else {\n      // 让组件重新渲染\n      // this.get()\n\n      // 为了完成修改多个属性后统一渲染一次 我们将 watcher 放入到队列中 将当前的watcher暂存起来\n      queueWatcher(this)\n    }\n  }\n\n  // 修改多个属性后 统一为一次更新的操作 再次封装到了run()里面\n  run() {\n    // new Watcher 构造器在执行 this.get() 的时候 将老值保存在this.value身上\n    let oldValue = this.value\n\n    // 当我们在执行这里的时候 就能获取到新的值\n    let newValue = this.get()\n\n\n    // 如果是 watch\n    if(this.user) {\n      // 执行 用户传入的 watch 回调\n      this.cb.call(this.vm, newValue, oldValue)\n    }\n  }\n\n  // 让计算属性中的依赖也记住渲染watcher\n  depend() {\n    // 我们拿到存放的所有dep 这里我们要使用dep\n    let i = this.deps.length\n    while(i--) {\n      // dep收集watcher会有对应的depend方法 让计算属性watcher也收集渲染watcher\n      this.deps[i].depend()\n    }\n  }\n}\n\n\nlet queue = []\n\n// 源码中是利用对象来进行watcher的去重的\nlet has = {}\n\nlet pending = false\n\n\n/*\n  当 修改属性的时候 最终会走 update()方法 其中的逻辑为 每次修改之后我们都会将watcher暂存到一个队列中 \n*/\nfunction queueWatcher(watcher) {\n  const id = watcher.id\n  // has对象中没有id 则忘队列中放\n  if(!has[id]) {\n    queue.push(watcher)\n    has[id] = true\n\n    // 不管 update() 执行多少次最终只执行一轮刷新操作 类似onece 同时是也不管我们怎么修改属性 新刷新一次队列\n    // 第一次肯定是 false\n    if(!pending) {\n      nextTick(flushSchedulerQueue)\n      pending = true\n    }\n\n  }\n}\n\n// 将队列中的任务一个个的拿出来进行执行\nfunction flushSchedulerQueue() {\n  // 将 queue 拷贝一份\n  let flushQueue = queue.slice(0)\n\n  // 回初始化操作\n  queue = []\n  has = {}\n  pending = false\n\n  /*\n    清空队列任务之前 我们先将watcher置为空\n\n    然后清空 flushQueue 中的任务 \n    上面开始回初始化的另一个好处 在刷新的过程中可能还有新的watcher\n    因为页面修改了属性就会触发update() -> 就会收集watcher到queque中 我们将这时候的新的watcher 重新放到queue中 下一轮再执行 \n\n    这也是批处理逻辑 先执行第一批(flushQueue) 第一批的执行过程中可能有第二批(放到queue中)\n  */\n  flushQueue.forEach(q => q.run()) \n}\n\n\n// 回调的队列\nlet callbacks = []\nlet waiting = false\nexport function nextTick(cb) {\n  callbacks.push(cb)\n\n  if(!waiting) {\n    // 利用 setTimeout 将逻辑拿到任务队列中执行\n    setTimeout(flushCallbacks, 0)\n\n    /*\n      还可以这样哦 放到微任务中\n      Promise.resolve().then(flushCallbacks)\n    */\n  }\n\n  waiting = true\n\n  /*\n    老师这么写的\n    if(!waiting) {\n      setTimeout(() => {\n        flushCallbacks()\n      }, 0)\n    }\n  */\n}\n\nfunction flushCallbacks() {\n  let cbs = callbacks.splice(0)\n\n  waiting = false  \n  callbacks = []\n\n  // 按照顺序依次执行\n  cbs.forEach(cb => cb())\n}\n\nexport default Wacher\n\n","// 创建元素 就是 _c() 或者 h() 都是一个方法\n// data = {} 没有附上默认值 那么当没有标签属性的时候 data就是null\nexport function createElementVnode(vm, tag, data = {}, ...children) {\n  // 这里这么处理 如果没有data 那么key就是undefined\n  let key = data?.key\n  if(key) delete data.key\n\n  return vnode(vm, tag, key, data, children)\n  \n}\n\n// _v()\nexport function createTextVnode(vm, text) {\n  return vnode(vm, undefined, undefined, undefined, undefined, text)\n}\n\n\n// 创建 Vnode 的方法\n// ast做的是 语法层面的转化 它描述的是语法本身 (html长什么样是能解析出来什么样)\n// vnode 描述的是dom元素 可以增加一些自定义的属性 (虚拟节点可以增加很多属性 比如 vm)\nfunction vnode(vm, tag, key, data, children, text) {\n  return {\n    vm,\n    tag,\n    key,\n    data,\n    children,\n    text,\n    // 这里还可以增加 事件 插槽 指令等属性\n  }\n}\n\n\n// 看看两个虚拟节点是否是同一个\nexport function isSameVnode(vnode1, vnode2) {\n  // 我们看看 vnode 的标签名 和 key 是否都一致\n  return vnode1.tag == vnode2.tag && vnode1.key == vnode2.key\n}\n","import { isSameVnode } from \".\"\n\n// 根据 vnode 创建真实的 元素\nexport function createElm(vnode) {\n  // 取出属性\n  let {tag, data, children, text} = vnode\n\n  // 说明 tag 是一个标签 (tag还可能是undefined 因为文本节点的时候只有text属性)\n  if(typeof tag == \"string\") {\n    /*\n      vnode: {\n        children: (2) [{…}, {…}]\n        data: {id: 'app', style: {…}}\n\n        el: div   // 多了 el 节点(真实的)\n\n        key: undefined\n        tag: \"div\"\n        text: undefined\n        vm: Vue\n      }\n      为了后面 实现diff算法 我们将创建好的元素 放在 vnode 上\n      这里将真实节点 和 虚拟节点对应起来 后续如果修改属性了 我们可以直接找到 虚拟节点对应的真实节点(VDOM: vnode, TDOM: vnode.el), 来修改属性 所以虚拟节点上会挂载着真实节点\n    */\n    vnode.el = document.createElement(tag)\n\n\n    // 处理属性: 更新 vode.el 元素的 data属性(data是标签属性)\n    // patchProps参数: 1. 节点, 2. 旧节点的标签属性, 3. 新节点的标签属性\n    patchProps(vnode.el, {}, data)\n\n\n    // 处理子节点:\n    children.forEach(child => {\n      // 将 child(子标签 子节点) 也创建成真实节点 将子节点放入到它的父节点中 也相当于给 el添加内容\n      vnode.el.appendChild(createElm(child))\n    })\n\n  } else {\n    // 如果 tag 不是字符串 我们就要创建文本节点 同样也要挂载到虚拟节点上\n    vnode.el = document.createTextNode(text)\n  }\n\n  // console.log(vnode)\n  // 返回真实元素\n  return vnode.el\n}\n\n\n// 处理标签属性的方法\nexport function patchProps(el, oldProps = {}, props = {}) {\n  // console.log(\"el: \", el)\n  // console.log(\"oldProps: \", oldProps)\n  // console.log(\"newProps:\", props)\n\n  /*\n    追加逻辑:\n      老的属性中有 新的属性中没有 要删除老的属性 因为我们要以新节点的标签属性为准\n  */\n  let oldStyle = oldProps.style || {}\n  let newStyle = props.style || {}\n\n  // 做style属性的处理 循环老的style对象看看新的中有没有 (老的样式中新的样式中没有则删除)\n  for(let key in oldStyle) {\n    if(!newStyle[key]) {\n      // 如果新的属性中没有 就将节点中对应的key置为空\n      el.style[key] = \"\"\n    }\n  }\n\n\n  // 做标签属性的处理(除了style属性) 老的属性中有 新的属性中没有 删除属性\n  for(let key in oldProps) {\n    if(!props[key]) {\n      el.removeAttribute(key)\n    }\n  }\n\n\n  // 将属性循环一遍赋值到元素上 用新的覆盖掉老的\n  for(let key in props) {\n    // 如果 key 是 style\n    if(key == \"style\") {\n      /*\n        标签上的 style 是这么写的  style = \"color:red\"\n\n        我们的props里面的style属性是\n        style: {background: 'pink', width: '100px'}\n      */\n      for(let styleName in props[key]) {\n        el.style[styleName] = props[key][styleName]\n      }\n    } else {\n      el.setAttribute(key, props[key])\n    }\n  }\n\n  \n}\n\n\n// 比较两个虚拟节点: 初始化 和 更新 节点的功能\nexport function patch(oldVnode, vnode) {\n\n  // 判断 oldVnode 是否是真实dom元素\n  const isRealElement = oldVnode.nodeType\n\n  // 如果是则为: 初渲染流程\n  if(isRealElement) {\n\n    // 给 oldVnode 换个名字 在初渲染的逻辑中 也好理解 初渲染的时候 el 是一个真实的元素\n    const el = oldVnode\n\n    // 获取它的父元素\n    const parentEl = el.parentNode  // body\n    \n    // 创建真实元素\n    let newELm = createElm(vnode)\n\n    // 将 newELm 插入到老节点的下面\n    parentEl.insertBefore(newELm, el.nextSibling)\n\n    // 删除老节点\n    parentEl.removeChild(el)\n\n    // 我们让 patch() 方法有返回值 将 newElm 返回出去\n    return newELm\n\n    \n  } else {\n    // diff算法\n    return patchVnode(oldVnode, vnode)\n  }\n}\n\n\n// 我们将比较两个节点的逻辑抽离到一个函数中\nfunction patchVnode(oldVnode, vnode) {\n  // 1. 判断两个节点是否是同一个节点 tag == tag && key == key\n  if(!isSameVnode(oldVnode, vnode)) {\n    // 不是同一个节点的情况\n    /*\n      老的虚拟节点在第一渲染的时候 我们会将虚拟节点和真实节点对应在一起 虚拟节点的.el属性上 就有真实节点\n\n      export function createElm(vnode) {\n        ...\n        // 将真实的节点放在了虚拟节点.el上\n        vnode.el = document.createElement(tag)\n        ...\n      }\n    */\n\n    // 通过 oldVnode.el 找到页面上渲染的节点 通过它的爸爸替换成新的节点\n\n    // 参数: 用新的vnode创建的新的真实节点 替换掉老的真实的节点 \n    let el = createElm(vnode)\n    oldVnode.el.parentNode.replaceChild(el, oldVnode.el)\n\n    // 返回新的el 保持返回的都是一个新的节点\n    return el\n  }\n\n  /*\n    上面return了 能走到这里说明两个节点是一样的 \n    我们先复用旧节点\n\n    然后考虑 相同节点是文本节点的情况\n    前一个节点是文本的话 那么后一个节点也会是文本节点\n\n\n    文本情况: 我们期望比较一下文本的内容\n    相同节点可能是元素 也可能是文本 文本的tag都是undefined\n\n    如果当前节点的tag是undefined 那它就是文本\n  */\n\n  // 将老的DOM赋值给新的节点的el 复用老节点的元素 如果两个都是标签 那么标签只是更改了属性 标签可复用 那就将老的.el 赋给 新的.el\n  let el = vnode.el = oldVnode.el\n\n  // 因为上面做了两个标签的判断 到这里说明两个标签是一样的 那么前一个节点是文本 那么后一个节点也是文本\n  if(!oldVnode.tag) {\n    // 既然前后都是文本 那么就可以判断文本内容\n    if(oldVnode.text != vnode.text) {\n      // el也就是老节点上的el 用新的文本覆盖掉老的节点的文本内容\n      el.textContent = vnode.text\n    }\n  }\n\n\n  // 走到这里 就是相同节点是标签 如果是标签的话 我们需要比对标签的属性\n  // console.log(oldVnode)\n  // console.log(vnode)\n  /*\n    vm: Vue, tag: 'li', key: 'a', data: {…}, children: Array(1)\n        data: style: {color: 'red'}\n\n    vm: Vue, tag: 'li', key: 'a', data: {…}, children: Array(1)\n        data: style: {color: 'red', background: 'blue'}\n  */\n\n\n  /*\n    调用之前写的 patchProps() 方法来对比标签属性\n    参数 \n      el: 老节点 let el = vnode.el = oldVnode.el\n      vnode.data: 新节点的标签属性\n      oldVnode.data: 旧节点的标签属性\n  */\n  patchProps(el, oldVnode.data, vnode.data)\n\n\n  /*\n    比较两个节点的儿子节点的时候分两种情况\n    1. 1方有儿子, 1方没儿子\n      - 要么把儿子全部删掉 要么全部创建新儿子\n\n    2. 2方都有儿子\n\n    我们要针对不同的情况做处理\n  */\n\n  // 获取两个节点的儿子\n  let oldChildren = oldVnode.children || []\n  let newChildren = vnode.children || []\n\n  // 两方都有儿子: 如下情况需要比较两个人的儿子\n  if(oldChildren.length > 0 && newChildren.length > 0) {\n\n    // 比较两个人的儿子 用新的更新旧的\n    updateChildren(el, oldChildren, newChildren)\n\n  // 一方有儿子 老节点的儿子为0 新节点有儿子: 我们直接将新节点的儿子放入\n  } else if(newChildren.length > 0) {\n    // 将新的儿子全部挂上去的方法 \n    mountChildren(el, newChildren)\n\n  // 新的没有 老的有 要将老节点的儿子删除\n  } else if(oldChildren.length > 0) {\n    // 删除节点中 老节点的儿子节点 (可以循环删除)\n    el.innerHTML = \"\"\n  }\n  \n  return el\n}\n\n\nfunction mountChildren(el, newChildren) {\n  // 渲染新儿子 将虚拟节点变为真实节点 挂载到元素上\n  for(let i=0; i<newChildren.length; i++) {\n    let child = newChildren[i]\n\n    // 将虚拟节点变为真实节点 然后插入el中\n    el.appendChild(createElm(child))\n  }\n}\n\n\n// 比较两个儿子\nfunction updateChildren(el, oldChildren, newChildren) {\n  /*\n    为了比较两个儿子的时候 增高性能 会有一些优化手段\n    比如之前 我们有 3个元素\n\n    A  B  C\n    □  □  □\n\n    1  2  3\n    □  □  □\n\n    我们会\n      用 1 依次和 ABC 比较 看看是否一样\n      用 2 依次和 ABC 比较 看看是否一样\n      用 3 依次和 ABC 比较 看看是否一样\n\n    这样比较一圈比较消耗性能\n    \n    我们可以默认 \n      A 和 1 是一样的\n      B 和 2 是一样的\n      c 和 3 是一样的\n\n    vue2中采用双指针的方式 比较两个节点\n\n    比如:\n\n    head   tail\n      ↓     ↓\n      A  B  C\n      □  □  □\n\n\n     head     tail\n      ↓        ↓\n      A  B  C  D\n      □  □  □  □\n\n    以前有一个列表是 [A, B, C] \n    现在有一个列表式 [A, B, C, D]\n\n    上面这种情况就是尾部追加\n    双指针的意思是 给每一个列表加上前后指针\n\n    我们从第一组AA开始比较\n\n      A\n      □\n\n      A\n      □\n\n    情况1: AA相同的情况\n\n    如果 A 和 A 的标签 属性 都一致 那么我们就向后移动指针\n\n         h  t\n         ↓  ↓\n      A  B  C\n      □  □  □\n\n\n         h     t\n         ↓     ↓\n      A  B  C  D\n      □  □  □  □\n\n    如果 B 和 B 标签一样 属性一样 那么我们就向后移动指针\n            h\n            ↓\n            t\n            ↓\n      A  B  C\n      □  □  □\n\n\n            h  t\n            ↓  ↓\n      A  B  C  D\n      □  □  □  □\n\n    \n    当两个列表任一一个 头指针 大于 尾指针 的时候 就停止\n\n\n            t  h\n            ↓  ↓\n      A  B  C\n      □  □  □\n\n\n               h\n               ↓\n               t\n               ↓\n      A  B  C  D\n      □  □  □  □\n\n    那我们就将 h t 指向同一个的节点 D 做插入就可以了\n\n    如果 老节点中有D 新节点中没有D\n               h\n               ↓\n               t\n               ↓\n      A  B  C  D\n      □  □  □  □\n\n\n            t  h\n            ↓  ↓\n      A  B  C\n      □  □  □\n\n    那么我们就将 h t 指向的节点删掉就可以了\n\n    也就是不管上下那个列表中 头指针 和 尾指针 只要头超过了尾 我们就停止循环\n    把 ht指向的节点 删掉 或者 追加进去\n\n\n    我们操作列表 经常会使用 push shift pop unshift 这些方法\n    所以我们针对这些情况做一个优化\n  */\n\n\n  // 特殊情况 新旧节点标签属性都一致 只有数量上的差别 我们使用双指针的形式\n\n  // 定义两个节点分别的头尾指针\n  let oldStartIndex = 0\n  let newStartIndex = 0\n\n  let oldEndIndex = oldChildren.length - 1\n  let newEndIndex = newChildren.length - 1\n\n  // 拿到头尾指针对应的节点\n  let oldStartVnode = oldChildren[0]\n  let newStartVnode = newChildren[0]\n\n  let oldEndVnode = oldChildren[oldEndIndex]\n  let newEndVnode = newChildren[newEndIndex]\n\n  /*\n    console.log(oldStartVnode, newStartVnode)\n    console.log(oldEndVnode, newEndVnode)\n    {vm: Vue, tag: 'li', key: 'a', data: {…}, children: Array(1), …}\n    {vm: Vue, tag: 'li', key: 'a', data: {…}, children: Array(1), …}\n    {vm: Vue, tag: 'li', key: 'c', data: {…}, children: Array(1), …}\n    {vm: Vue, tag: 'li', key: 'd', data: {…}, children: Array(1), …}\n  */\n\n  // 老新列表中 双方列表只要有一方 头 > 尾 的时候停止循环\n  // && 有任何一个不满足就是false 则停止\n  // || 有一个为 true 则继续走\n  while(\n    oldStartIndex <= oldEndIndex &&\n    newStartIndex <= newEndIndex\n  ) {\n    \n  }\n}","import Wacher from \"./observe/watcher\"\nimport { createElementVnode, createTextVnode } from \"./vdom\"\nimport { patch } from \"./vdom/patch\"\n\n// 组件的挂载\nexport function mountComponent(vm, el) {\n\n  /*\n    将 el 也挂载到 vm 上\n\n    options中的el是选择器字符串 \n    这个el是我们通过 querySelector 之后选择的 节点\n\n    我们将这里节点挂载到了 实例 上\n  */\n  vm.$el = el\n\n  // 1. 调用 render 方法 产生虚拟节点(DOM)\n  // 2. 根据虚拟DOM产生真实DOM\n  // 3. 插入到el元素中\n  // vm._update(vm._render())\n\n  // 将上面的逻辑封装到了 watcher 中我们通过watcher来进行调用\n  const updateComponent = () => {\n    vm._update(vm._render())\n  }\n\n  // debugger\n  // 利用 Watcher来进行的更新组件的操作\n  new Wacher(vm, updateComponent, true)\n}\n\n\nexport function initLifeCycle(Vue) {\n  // 将 vnode 转换成 真实dom\n  Vue.prototype._update = function(vnode) {\n\n    // 获取 el \n    const vm = this\n    const el = vm.$el\n    // 该方法既有初始化的功能 也有更新的功能 我们将patch()返回的真实节点 更新 $el 上的节点\n    vm.$el = patch(el, vnode)\n\n  }\n\n\n  // _c(\"div\", {}, 很多children) \n  Vue.prototype._c = function() {\n    // this就是vm\n    return createElementVnode(this, ...arguments)\n  }\n\n\n  // _v(text)\n  Vue.prototype._v = function() {\n    return createTextVnode(this, ...arguments)\n  }\n\n\n  // 将 _s() 包裹的值转成字符串(变量 -> 数据之后转成字符串吧)\n  Vue.prototype._s = function(val) {\n\n    // 判断下 val 的类型 只有val为对象的时候 我们再进行 JSON.stringify(val)\n    if(typeof val != \"object\") return val\n    \n    return JSON.stringify(val)\n  } \n\n  Vue.prototype._render = function() {\n    \n    let vm = this\n\n    // vm.$options.render() 是通过 ast语法树转义后生成的render方法\n    // 因为使用 with() 包装的 让with的this指向vm\n    let vnode = vm.$options.render.call(vm)\n\n    return vnode\n  } \n}\n\n// 参数: 调用哪个实例上的哪个钩子 \nexport function callHook(vm, hook) {\n  let handles = vm.$options[hook]\n  if(handles) {\n    // 注意: 生命周期中的钩子都是当前实例\n    handles.forEach(handler => handler.call(vm))\n  }\n}","// 1. 拿到 Array构造函数的原型对象中的内容\nlet oldArrayProto = Array.prototype\n\n/*\n  我们不能直接修改 Array.prototype 原型对象身上的方法\n  如果我们这样操作\n  Array.prototype.push = function() { }\n\n  相当于将原来的push功能干掉了 不合理 原来的方法应该还在不要影响以前的应该在原来的基础上进行扩展\n*/\n\n// 2. 通过 Object.create() 创建一个新对象\n// newArrayProto.__proto__ == oldArrayProto\n// 这样我们还能通过 newArrayProto读到push等方法\nexport let newArrayProto = Object.create(oldArrayProto)\n\n/*\n  newArrayProto是作为原型对象使用的哦\n\n  这时候我们在这样操作就不会影响到 Array.prototype 身上的push方法了\n  newArrayProto.push = function() {  }\n  这样加是改变 newArrayProto 自己的原型对象 并没有改变 Array.prototype 身上的方法 所以不用担心被覆盖掉\n*/\n\n// 将能修改原数组的方法先找到\nlet methods = [\n  \"push\",\n  \"pop\",\n  \"shift\",\n  \"unshift\",\n  \"reverse\",\n  \"sort\",\n  \"splice\"\n]\n\nmethods.forEach(method => {\n  // 重写这些方法 我们在 newArrayProto 身上增加这些方法\n  newArrayProto[method] = function(...args) {\n    // args参数: 比如 push(1)\n\n    /*\n      我们调用新的重写的方法的时候 默认会调用原来的方法\n      我们要将参数 传递到原生的方法中\n      同时我们还要注意 this 的问题\n      oldArrayProto[method]() 相当于直接 push()\n\n      arr.push() 谁调用的push this就是谁 所以这里我们还要将this传递过去\n    */\n    const result = oldArrayProto[method].call(this, ...args)\n\n\n    // 插入后再做观测 没插就做观测 那叫啥逻辑\n\n    \n    // 定义变量 保存数组新增元素\n    let inserted\n\n    // Observer类中 我们将代表实例的this 绑定到了 data.__ob__ 身上 因为 本函数中的this就是 Observer类中的data 所以可以这么获取\n    let ob = this.__ob__\n\n    switch(method) {\n      // 如果是这两个方法的话 参数肯定是追加的内容\n      case \"push\":\n      case \"unshift\":\n        // 这里我们就要看追加的内容是不是对象 如果是 则做get set\n        // args是数组哦\n        inserted = args\n        break\n      \n      // arr.splice(0, 1, {a:1}, {b:2}) 前两个参数表示位置和删除的个数 后面是新增的内容\n      case \"splice\": \n        // 提取第三个参数\n        inserted = args.slice(2)\n        break\n    }\n\n    // console.log(\"新增的内容: \", inserted)\n\n    // 如果有新增的内容则需要对新增的内容再次的进行观测\n    // inserted 是数组 args是数组 args.slice返回的也是数组\n    if(inserted) {\n      /*\n        如果我们要对数组进行观测调用的是 Observer类中的 observeArray() 方法 这个方法会遍历当前数组 拿到每一项然后对每一项进行观测\n        那怎么拿到 Observer类呢?\n\n        我们思考一个问题 重写后的方法是谁要调用\n        class Observer {\n          // data 就是 options 中的 data\n          constructor(data) {\n\n            if(data是数组) {\n\n              我们是不是要在这里判断 data 是对象 还是数组 如果是数组的话\n              1. 观察数组中的每一项 如果是对象再次观测其中的属性\n              2. 重写数组的方法\n\n              data是数组吧 它要调用 push 等方法\n\n            } else {\n              data不是数组\n            }\n          }\n        }\n        \n        也就是说 Observer类中的data 会调用push()方法 data.push()\n        那就是说谁调用的push this就是谁\n\n        同理说明 newArrayProto[method] = function() {} 函数中的this 就是 Observer类中的data\n        this == Observer.data 是同一个\n\n        这样我们在 Observer类中这样写 将Observer中的this绑定到了 data 身上\n        class Observer {\n          constructor(data) {\n\n            // 这里的this是Observer类实例\n            data.__ob__ = this\n          }\n        }\n\n        上面这样写完后本函数的 this 身上也有 __ob__ 代表 Observer类的实例\n        我们可以通过该实例调用 observeArray() 方法了是么\n      */\n      \n      // 调用 Observer 类中的observeArray()方法 监测数组中的数据\n      ob.observeArray(inserted)\n    }\n\n    // 走到这里需要更新页面 数组变化了通知对应的watcher实现更新逻辑\n    ob.dep.notify()\n\n    return result\n  }\n})","import {newArrayProto} from \"./array\"\nimport Dep from \"./dep\"\n\n// 创建一个观测类 用于判断 data 是否被观测过\nclass Observer {\n  // data 就是 options 中的 data\n  constructor(data) {\n\n    /*\n      data可能是对象 也可能是数组 我们要给data设置dep 让它也能够做依赖收集\n      这样就可以给对象本身 和 数组本身添加dep 监控变化更新组件\n    */\n    this.dep = new Dep()\n\n\n    // 将 __ob__ 设置为不可枚举 循环的时候无法获取 从而避免死循环\n    Object.defineProperty(data, \"__ob__\", {\n      value: this,\n      enumerable: false\n    })\n\n    // 这里的this是Observer类实例\n    // 同时给数组加了一个标识 如果数据上有 __ob__ 则说明这个属性被观测过\n    // data.__ob__ = this\n\n    // 判断 data 是否是数组\n    if(Array.isArray(data)) {\n      // 如果是数组 那就是监控用户有没有调用 操作数组的方法\n\n      // 目的1: 重写数组中的方法\n      // 我们可以重写数组中的方法 7个变异方法(这几个方法是可以修改原数组的)\n\n      // data是数组哦\n      // 保留Array构造函数身上的原始方法 并且可以重写部分方法 newArrayProto里面就有我们重写的方法\n      // data是一个数组, 当这个数组调用方法的时候 就会走 newArrayProto 里面的方法\n      // 这样无论我们调用这7个方法中的任意一个 都可以被监控到 这就实现了数组方法的执行\n      data.__proto__ = newArrayProto\n\n      // 目的2: 对数组中的对象中的属性做劫持\n      // 对数组中的每一个成员都要进行观测 对数组中的每一项进行劫持(里面调用了observ还是只对数组中的对象中的属性做了劫持)\n      // 如果数组中放的是对象 可以监控到对象的变化\n      this.observeArray(data)\n\n\n    } else {\n      // 不是数组\n\n      // 我们要劫持data对象中的每一个属性\n      // Object.defineProperty只能劫持已经存在的属性 后增的 或者删除的它是不知道的\n      // 所以vue2中会为此单独的写一些api 比如 $set $delete 我们先这么用\n      this.walk(data)\n\n    }\n    \n  }\n\n  /*\n    constructor(data) {\n      data.__ob__ = this\n\n      if(Array.isArray(data)) {\n        // 数组的逻辑\n      } else {\n        // 对象的逻辑\n      }\n    }\n\n    这里这么做有bug\n    如果 data 是对象的话 我们也会往 对象身上 添加 __ob__\n\n    但是 走到 else 里面的话 this.walk(data) 会对 data 做循环 \n    循环的时候也会遍历 data 上的 __ob__ 属性\n\n    __ob__  == this == Observer实例对象 对象中又有 Observer 类中的属性\n    这样会走 walk() walk中开发遍历 走defineReactive() 又走observe() 又 new Observer\n    又循环一遍 死循环了\n\n    所以我们要在walk中添加 在循环的时候 不要遍历到 __ob__ 这个属性 我们可以让 __ob__ 设置成不可枚举的\n  */\n \n\n  // 循环对象对属性依次劫持\n  walk(data) {\n    // 拿到data对象的每一个key后 可以重新定义对象中的属性(对传入的data中的属性重新定义相当于将属性重新重写了 所以性能会差 这也是vue2的问题 所以vue3中换了proxy)\n    // 自定义defineReactive() 将data中的 某属性 定义成 响应式的\n    Object.keys(data).forEach(key => defineReactive(data, key, data[key]))\n  }\n\n\n  // 观测数组中的成员\n  observeArray(data) {\n    // 将数组中的每一项都进行观测\n    data.forEach(item => observe(item))\n  }\n}\n\n// 将目标对象的属性重新定义\n// defineReactive()方法可以单独使用 理解为公共的api\n// target: 重新定义哪个对象的属性(我们要重新定义data)\n// key: \n// value:\nexport function defineReactive(target, key, value) { // 参数value 相当于闭包 相当于在defineProperty函数外层定义了一个变量 该变量不会被销毁\n\n  // 这里调用 observe() 传入 value\n  // observe(value) 上一个版本\n\n  // childOb身上就有一个dep属性在constructor里面添加的 childOb.dep 用来收集依赖\n  let childOb = observe(value)\n\n  // 给一个属性都增加一个 dep 属性 这个是闭包区域这里的属性不会被销毁\n  let dep = new Dep()\n\n  // 我们使用这个api 取值的时候会执行get 修改的时候会执行set 这样就拦截了用户的操作\n  Object.defineProperty(target, key, {\n    // 取值: \n    get() {\n\n      // 判断\n      if(Dep.target) {\n        // 让这个属性的收集器记住当前的watcher\n        dep.depend()\n\n\n        // 再取属性的时候 如果有childOb 也就是对象 和 数组实体身上的 __ob__\n        if(childOb) {\n          // 拿到它身上的dep 做依赖收集让其记住当前的watcher 让数组和对象本身也实现依赖收集\n          childOb.dep.depend()\n\n          // 如果当前的值是数组\n          if(Array.isArray(value)) {\n            // 那我们就让数组再次的依赖收集 调用个递归方法\n            dependArray(value)\n          }\n        }\n      }\n\n      // 取值的时候 取参数value\n      return value\n    },\n    // \n    set(val) {\n      // 设置值的时候 设置参数value\n      if(val == value) return // 值一样的话就不用修改了\n\n      // 如果设置的值是一个对象的话我们要对设置的值再次代理\n      /*\n        比如用户这样修改值: \n        vm.address = {\n          num: 1\n        }\n        这样做的话 我们set的val就是一个对象了 我们应该对对象的值再次代理\n      */\n      observe(val)\n      value = val\n\n      // 通知更新\n      dep.notify()\n    }\n  })\n}\n\n// 递归给数组做劫持的方法\nfunction dependArray(arr) {\n  // 拿到里面的每一项 每一项都做依赖收集\n  for(let i=0; i<arr.length; i++) {\n    // arr[i]元素项 元素项身上都有__ob__ __ob__上有dep(ob就是this this身上有dep)\n    arr[i].__ob__ && arr[i].__ob__.dep.depend()\n\n    // 如果里面还是数组\n    if(Array.isArray(arr[i])) {\n      dependArray(arr[i])\n    }\n  }\n}\n\n\nexport function observe(data) {\n  \n  // 监测data是否是对象 如果不是直接return 只对对象进行劫持\n  if(typeof data !== \"object\" || data == null) return\n\n  // 说明这个对象被代理过了 不用再被代理了\n  if(data.__ob__ instanceof Observer) return data.__ob__\n\n\n  // 如果一个对象被劫持过了 那就不需要再被劫持了\n  // (要判断一个对象是否被劫持过 这里增添了一个实例 用实例来判断是否被劫持过)\n  // vue在内部又创建了一个类 这个类的作用是专门观测数据的 如果该数据被观测过 那它的实例就是这个类\n  return new Observer(data)\n}","import Dep from \"./observe/dep.js\"\nimport { observe } from \"./observe/index.js\"\nimport Watcher, { nextTick } from \"./observe/watcher.js\"\n\n// 用于处理 options 中的配置项(状态)\nexport function initState(vm) {\n\n  // 从实例身上取出 $options 获取所有的选项\n  let opts = vm.$options\n\n  // 如果用户有添加 data 配置项\n  if(opts.data) {\n    // 如果有就对 data 进行初始化操作\n    initData(vm)\n  }\n\n\n  // 如果有计算属性 我们就初始化计算属性\n  if(opts.computed) {\n    initComputed(vm)\n  }\n\n\n  // 如果有watch 我们就初始化watch\n  if(opts.watch) {\n    initWatch(vm)\n  }\n\n}\n\n// 初始化 watch \nfunction initWatch(vm) {\n  // 获取用户传入的 watch 配置项 它是一个对象\n  let watch = vm.$options.watch\n  // console.log(\"watch: \", watch)\n\n  // 循环对象中的每一个 key value 做处理\n  for(let key in watch) {\n    // 我们考虑 字符串 数组 和 函数 这三种情况\n    const handler = watch[key]\n\n    // 如果是数组的话\n    if(Array.isArray(handler)) {\n      // 循环创建 watcher\n      for(let i=0; i<handler.length; i++) {\n        // 我们要创建watcher 将watcher放到实例上 key是监控的属性\n        createWatcher(vm, key, handler[i])\n      }\n    } else {\n      // 不是数组就执行创建watcher\n      createWatcher(vm, key, handler)\n    }\n  }\n}\n\nfunction createWatcher(vm, key, handler) {\n  // handle 我们传递过来 它有可能是 字符串 函数\n  if(typeof handler == \"string\") {\n    // firstname: \"fn\" -> fn是methods定义的 但是该方法也会绑定在实例上 所以我们直接从vm上获取该方法\n    handler = vm[handler]\n  } \n\n  return vm.$watch(key, handler)\n}\n\n\n// 初始化 计算属性\nfunction initComputed(vm) {\n  const computed = vm.$options.computed\n\n  // 用于记录哪个属性的watcher 同时保存到实例是方便调用\n  const watchers = vm._computedWatchers = {}\n  \n  // 写法有两种 函数 和 对象 我们要看看 value 是不是 对象\n  for(let key in computed) {\n    // fullname: {} or function 拿到value的部分\n    let userDef = computed[key]\n\n\n    // 我们需要监控 计算属性中get的变化\n    // lazy: true: 如果我们执行new Watcher会直接执行fn 但是我们不希望它立刻执行 而是取值的时候才执行 lazy: true 相当于标识 标识fn不要立即执行\n    // fn: 每次重新执行的方法 我们每次重新执行的就是计算属性的get()方法(或者是计算属性函数式的方法)\n    // 参数:  vm fn bool\n    let fn = typeof userDef == \"function\" ? userDef : userDef.get\n\n    // 将属性和watcher 对应起来\n    // 如果直接 new Watcher 默认就会执行 fn\n    watchers[key] = new Watcher(vm, fn, {lazy: true})\n\n\n\n\n\n    // 如果是一个函数 那么userDef就是getter 如果是对象那我们就取出来getter\n    // const getter = typeof userDef == \"function\" ? userDef : userDef.get\n    // const setter = userDef.set || (() => {})\n\n    // 将计算属性 fullname 定义在 vm 上 \n    // 我们没有从userDef取出getter 和 setter 而是传入userDef(相当于value的部分) 让它在方法内再取getter setter\n    defineComputed(vm, key, userDef)\n  }\n}\n\n\n// 给target定义属性\nfunction defineComputed(target, key, userDef) {\n\n  // 用不到了 我们上面将 getter 放到了 new Watcher 的里面 fn就是 我们也会通过 watcher来调用 所以这里用不到了\n  // const getter = typeof userDef == \"function\" ? userDef : userDef.get\n  const setter = userDef.set || (() => {})\n  \n  // 这样可以通过 实例拿到对应的属性\n  Object.defineProperty(target, key, {\n    // 取值的时候 可以根据key 找到对应的watcher 看其是否是脏的\n    // 第一次的时候 dirty是脏的 所以会执行用户传入的get() 之后 dirty为false 就不会再执行该方法了\n    get: createComputedGetter(key),\n    set: setter\n  })\n}\n\n// 我们需要检查是否需要执行这个getter\nfunction createComputedGetter(key) {\n  // 我们要拿到 watcher 看看 dirty 是不是脏的 怎么拿 watcher?\n\n  // 这里的function就是get的回调 回调中的this指向\n  return function() {\n\n    // 这里是 this 是 vm 因为 getter中的this就是 obj 我们就可以通过this 拿到在vm上保存的 计算属性的所有watcher\n    // 我们可以通过 key 获取到对应属性的 watcher 这个watcher中是有getter的\n    let watcher = this._computedWatchers[key] \n\n    if(watcher.dirty) {\n      // 如果为true(默认就是被修改的) 我们应该实行用户传入的getter\n      watcher.evaluate()\n    }\n\n    // watcher.evaluate() 执行后计算属性会出栈 如果Dep.target还有值 说明还有渲染watcher\n    if(Dep.target) {\n      // 让计算属性watcher里面的属性 也去收集渲染watcher(上层watcher)\n      watcher.depend()\n    }\n\n    // 在调用evaluate()后会将 getter的返回值放在 watcher.value 上 相当于将值缓存在watcher上了\n    return watcher.value\n  }\n}\n\n\nfunction initData(vm) {\n\n  // 拿到 data配置项后 要对里面的数据进行代理\n  let data = vm.$options.data\n\n  // 判断 data 是函数 还是对象 如果是函数的话我们进行调用获取其返回值\n  data = typeof data == \"function\" ? data.call(vm) : data\n\n  // 在 vm 身上增加 _data 我们将 $options的data对象放到了 vm身上\n  vm._data = data\n\n  // vue2中使用 Object.defineProperty() 来做数据的劫持\n  // 我们在这里提供一个方法 观察data\n  observe(data)\n\n  // 到这里就说明给 data对象重新定义完了属性\n  // 遍历data\n  for(let key in data) {\n    // 将 vm._data 用 vm 来代理\n    proxy(vm, \"_data\", key)\n  }\n  \n\n}\n\n/*\n  定义将_data中的所有key 使用Object.defineProperty() 在vm身上重新定义一份的代理方法\n  参数:\n    vm: \n      我们要给vm身上绑定_data对象中的属性名\n\n    target: \n      当 vm.name 的时候从哪个原对象上读取 vm._data\n    \n    key:\n      循环从_data身上取出的key\n\n*/\nfunction proxy(vm, target, key) {\n  Object.defineProperty(vm, key, {\n    // 当从 vm 身上读取属性的时候\n    get() {\n      // 从 vm._data[key] 取值\n      return vm[target][key]\n    },\n    set(val) {\n      vm[target][key] = val \n    }\n  })\n\n}\n\n\nexport function initStateMixin(Vue) {\n  Vue.prototype.$nextTick = nextTick\n\n  // 添加 $watch 最终调用的都是这个方法\n  Vue.prototype.$watch = function(exprOrFn, cb, options = {}) {\n    // console.log(exprOrFn)\n    // console.log(cb)\n    /*\n      firstname\n      firstname(n, o) {\n        console.log(n, o)\n      }\n\n      or\n\n      () => vm.firstname\n      (n, o) => console.log(\"n, o\")\n    */\n\n    /*\n      $watch是一个观察者 它底层也会基于 Watcher\n\n      参数: vm, fn, watcher类型标识\n\n      我们传入\n        this: prototype 中的this都是 vm,\n\n        exprOrFn: 它可能是\n          \"firstname\"\n          () => vm.firsrname\n\n        {user: true}: wacher类型的标识 用户自己写的watcher\n\n        cb: 用户指定的watch 回调\n    */\n    new Watcher(this, exprOrFn, {user: true}, cb)\n  }\n\n}","import { compileToFunction } from \"./compiler\"\nimport { mergeOptions } from \"./global\"\nimport { callHook, mountComponent } from \"./lifecycle\"\nimport { initState } from \"./state\"\n\n\n// 定义给 Vue 添加功能的方法\nexport function initMixin(Vue) {\n  Vue.prototype._init = function(options) {\n\n    // 将this保存起来 以后就使用vm了 构造函数中的this就是实例\n    const vm = this\n\n    // 初始化的时候 将options放到Vue实例身上\n    // vm.$options = options\n\n\n    /*\n      为了完成 mixin 和 用户传入的配置项进行合并 我们这么做\n        mixin会将mixin({options}) options和Vue.options 进行合并\n        用户传入的options也要合并到Vue.options\n\n        所以我们要拿到 Vue.options 和 用户传入的 options进行合并\n        通过 this\n    */\n    vm.$options = mergeOptions(vm.constructor.options, options)\n\n    /*\n      一会组件初始化的时候 会将用户传入的配置项和Vue.options进行合并\n      我们定义的全局指令 和 过滤器都会挂载到实例上 每个实例都能访问到\n\n      Vue.mixin() 的时候 会将 mixin配置对象放到 Vue.options 中\n      当创建组件 组件渲染的时候又会将 Vue.options 对象中的属性 再次合并到vm上\n    */\n    // console.log(this.constructor.options)\n    // console.log(this.$options)\n\n\n    // 调用生命周期 src/lifecycle.js\n    callHook(vm, \"beforeCreate\")\n\n    // 初始化状态\n    initState(vm)\n\n    callHook(vm, \"created\")\n\n\n    // 如果 options.el 说明用户传入了el\n    if(options.el) {\n      // 传入el配置的话 我们就要挂载应用 我们调用$mount(el)传入el\n      // 实现数据的挂载\n      vm.$mount(options.el)\n    }\n  }\n\n  // 给Vue扩展 $mount() 方法\n  Vue.prototype.$mount = function(el) {\n    // 这里我们也要保存this为vm 往实例上添加东西\n    const vm = this\n    el = document.querySelector(el)\n    let opts = vm.$options\n\n    /*\n      首先看看有没有render 如果有render 那我们就不用管了 所以这部分的逻辑是在 if(!render) { } 的情况下完成的\n    */\n    // 如果没有render函数也没有写 template 配置项\n    if(!opts.render) {\n\n      // 进来就是没有render的情况 我们定义template接收模板内容\n      let template\n\n      // 没有 template配置项 但是有el配置项 那我们就直接获取DOM元素作为模板内容\n      if(!opts.template && el) {\n        template = el.outerHTML\n\n      /*\n        因为上面 &&短路运算 如果表达式1为false 则整体为false 走else的逻辑\n        就是说else的逻辑: 如果有 template 配置项\n      */\n      } else {\n        // 到这里就是用户写了template配置项 那么就用用户传递的template中的内容s\n        // 这里老师写的是 if(el) 但我没用哈哈\n        if(opts.template) {\n          template = opts.template\n        }\n      }\n\n      // console.log(template)\n\n      // 如果有模板内容 我们再做模板编译的逻辑 将template编译成render\n      if(template) {\n\n        // 调用 compileToFunction() 方法将 模板内容编译成 render函数\n        let render = compileToFunction(template)\n        opts.render = render\n      }\n    }\n\n    // 组件的挂载的方法 将 vm 挂载到 页面 el 上 (#app)\n    mountComponent(vm, el)\n  }\n}\n\n\n\n","import { compileToFunction } from \"./compiler\"\nimport { initGlobal } from \"./global\"\nimport {initMixin} from \"./init\"\nimport {initLifeCycle} from \"./lifecycle\"\nimport { initStateMixin } from \"./state\"\nimport { createElm, patch } from \"./vdom/patch\"\n\n\nfunction Vue(options) {\n  this._init(options)\n}\n\n\n// init\ninitMixin(Vue)\n\n// 给 vm 扩展生命周期的方法 update render\ninitLifeCycle(Vue)\n\n// 给 vm 扩展mixin的方法\ninitGlobal(Vue)\n\n// 给原型扩展 $nextTick $watch\ninitStateMixin(Vue)\n\n\n// ----- 为了方便观察前后的虚拟节点(测试用) -----\n/*\n  为了生成虚拟节点 需要提供 template 将其变为render 产生虚拟节点\n  我们先用一个模板 然后编译成render\n*/\n\n// 返回的是render函数\nlet render1 = compileToFunction(`<ul a=\"1\" style=\"color: red;\">\n  <li key=\"a\">A</li>\n  <li key=\"b\">B</li>\n  <li key=\"c\">C</li>\n</ul>`)\n\n// 我们要传入vm 所以创建一个vm vm上才有_c()等方法\nlet vm1 = new Vue({data: {name: \"sam\"}})\nlet prevVnode = render1.call(vm1)\n// console.log(\"prevVnode: \", prevVnode)\n\n\n// 再整一个模版\nlet render2 = compileToFunction(`<ul a=\"1\" style=\"color: blue;\">\n  <li key=\"a\">A</li>\n  <li key=\"b\">B</li>\n  <li key=\"c\">C</li>\n  <li key=\"d\">d</li>\n</ul>`)\nlet vm2 = new Vue({data: {name: \"sam\"}})\nlet nextVnode = render2.call(vm2)\n// console.log(\"nextVnode: \", nextVnode)\n\n/* \n  为了能看到页面的变化 我们将 prevVnode 生成真实的DOM 插入到页面上\n  之后用 prevVnode 和 nextVnode 比较结果更新页面\n*/\n\n// 将虚拟节点创建成真实节点\nlet el = createElm(prevVnode)\ndocument.body.appendChild(el)\n\n\n// 我们之前的做法是 当数据发生变化的时候 拿到新的模版再次生成新的虚拟DOM 再次生成真实DOM 替换掉之前的el\n/*\n  这是没有diff算法的操作 直接将心的节点替换掉了老的节点\n  let newEl = createElm(nextVnode)\n  el.parentNode.replaceChild(newEl, el)\n*/\n\n\n/*\n  这样不好 用户自己操作DOM 可能会有性能的浪费 比如获取元素后再操作DOM就会不停的重绘\n  如果之前就是 <li>{{name}}</li> 之后还是 <li>{{name}}</li> 没有变化 用替换么 因为前后元素一致\n  我们希望尽可能的复用 老的节点 所以Vue中 不是直接替换 而是比较两个人的区别之后再替换\n\n  因为 真实节点 上的属性非常的多 而我们的虚拟DOM则没有那么多 能尽量不创建DOM就不创建DOM 这就是diff算法\n*/\n\n\nsetTimeout(() => {\n  patch(prevVnode, nextVnode)\n}, 1000)\n\n\nexport default Vue"],"names":["ncname","qnameCapture","startTagOpen","RegExp","endTag","attribute","startTagClose","parseHTML","html","ELEMENT_TYPE","TEXT_TYPE","stack","cuurentParent","root","createASTElement","tag","attrs","type","parent","children","handleStart","node","push","handleText","txt","replace","text","handleEnd","pop","length","advance","len","substring","parseStartTag","start","match","tagName","attr","end","name","value","textEnd","indexOf","startTagMatch","endTagMatch","compileToFunction","template","ast","code","codegen","render","Function","genChildren","genProps","defaultTagRE","gen","test","JSON","stringify","tokens","lastIndex","exec","index","slice","join","map","child","str","i","obj","split","forEach","item","key","trim","strats","lifecycle","lifecycleName","p","n","concat","mergeOptions","preOptions","newOptions","options","mergeField","hasOwnProperty","initGlobal","Vue","mixin","id","Dep","subs","target","addDep","watcher","update","pushTarget","popTarget","Wacher","vm","exprOrFn","cb","renderWatcher","getter","user","deps","depsId","Set","lazy","dirty","undefined","get","call","dep","has","add","addSub","queueWatcher","oldValue","newValue","depend","queue","pending","nextTick","flushSchedulerQueue","flushQueue","q","run","callbacks","waiting","setTimeout","flushCallbacks","cbs","splice","createElementVnode","data","vnode","createTextVnode","isSameVnode","vnode1","vnode2","createElm","el","document","createElement","patchProps","appendChild","createTextNode","oldProps","props","oldStyle","style","newStyle","removeAttribute","styleName","setAttribute","patch","oldVnode","isRealElement","nodeType","parentEl","parentNode","newELm","insertBefore","nextSibling","removeChild","patchVnode","replaceChild","textContent","oldChildren","newChildren","updateChildren","mountChildren","innerHTML","oldEndIndex","newEndIndex","mountComponent","$el","updateComponent","_update","_render","initLifeCycle","prototype","_c","arguments","_v","_s","val","$options","callHook","hook","handles","handler","oldArrayProto","Array","newArrayProto","Object","create","methods","method","args","result","inserted","ob","__ob__","observeArray","notify","Observer","defineProperty","enumerable","isArray","__proto__","walk","keys","defineReactive","observe","childOb","dependArray","set","arr","initState","opts","initData","computed","initComputed","watch","initWatch","createWatcher","$watch","watchers","_computedWatchers","userDef","fn","Watcher","defineComputed","setter","createComputedGetter","evaluate","_data","proxy","initStateMixin","$nextTick","initMixin","_init","constructor","$mount","querySelector","outerHTML","render1","vm1","prevVnode","render2","vm2","nextVnode","body"],"mappings":"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"}